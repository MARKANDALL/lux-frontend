// scripts/build-harvard-phonemes.mjs
import fs from "node:fs";
import path from "node:path";
import cmuPkg from "cmu-pronouncing-dictionary";
import { harvardPassages } from "../src/data/harvard.js";

function pad2(n) {
  return String(n).padStart(2, "0");
}
function harvardKey(n) {
  return `harvard${pad2(n)}`;
}

const dict = cmuPkg?.dictionary || {};

function cleanWord(raw) {
  // keep apostrophes for possessives; strip other punctuation
  return String(raw || "")
    .toUpperCase()
    .replace(/[^A-Z']/g, "")
    .replace(/^'+|'+$/g, "");
}

function phonesForWord(raw) {
  const w0 = cleanWord(raw);
  if (!w0) return [];

  // try a few fallbacks
  const tries = [
    w0,
    w0.endsWith("'S") ? w0.slice(0, -2) : "",
    w0.includes("'") ? w0.replace(/'/g, "") : "",
  ].filter(Boolean);

  let pron = null;
  for (const w of tries) {
    if (dict[w]) {
      pron = dict[w];
      break;
    }
  }
  if (!pron) return [];

  const s = Array.isArray(pron) ? pron[0] : pron;
  return String(s)
    .trim()
    .split(/\s+/)
    .map((p) => p.replace(/[0-9]/g, "")) // strip stress digits
    .filter(Boolean);
}

function inc(obj, k, by = 1) {
  obj[k] = (obj[k] || 0) + by;
}

function computeCountsForParts(parts) {
  const counts = {};
  let total = 0;

  for (const line of parts || []) {
    const words = String(line)
      .split(/\s+/)
      .map(cleanWord)
      .filter(Boolean);

    for (const w of words) {
      const phones = phonesForWord(w);
      for (const ph of phones) {
        inc(counts, ph, 1);
        total += 1;
      }
    }
  }

  return { counts, totalPhones: total };
}

// 1) per-list counts + global counts
const perList = {};
const globalCounts = {};
let globalTotal = 0;

for (let n = 1; n <= 72; n++) {
  const key = harvardKey(n);
  const parts = harvardPassages?.[key]?.parts || [];
  const { counts, totalPhones } = computeCountsForParts(parts);

  perList[String(n)] = { counts, totalPhones };

  for (const [ph, c] of Object.entries(counts)) {
    inc(globalCounts, ph, c);
    globalTotal += c;
  }
}

// 2) top3 distinctive by lift vs global baseline
function top3ForList(nStr) {
  const rec = perList[nStr];
  const counts = rec?.counts || {};
  const total = rec?.totalPhones || 0;

  if (!total) return [];

  const scored = Object.entries(counts).map(([ph, count]) => {
    const pct = count / total;
    const base = (globalCounts[ph] || 0) / (globalTotal || 1);
    const lift = base > 0 ? pct / base : 0;
    return { ph, count, pct, lift };
  });

  scored.sort((a, b) => {
    if (b.lift !== a.lift) return b.lift - a.lift;
    if (b.count !== a.count) return b.count - a.count;
    return a.ph.localeCompare(b.ph);
  });

  return scored.slice(0, 3);
}

// 3) emit meta + phoneme list
const metaOut = {};
for (let n = 1; n <= 72; n++) {
  const nStr = String(n);
  metaOut[nStr] = {
    top3: top3ForList(nStr),
    totalPhones: perList[nStr]?.totalPhones || 0,
    counts: perList[nStr]?.counts || {},
  };
}

const phonemes = Object.keys(globalCounts).sort((a, b) => {
  // sort by global frequency desc
  const da = globalCounts[a] || 0;
  const db = globalCounts[b] || 0;
  if (db !== da) return db - da;
  return a.localeCompare(b);
});

const outPath = path.join(process.cwd(), "src", "data", "harvard-phoneme-meta.js");
const outJs =
  `// AUTO-GENERATED by scripts/build-harvard-phonemes.mjs\n` +
  `// Do not hand-edit.\n` +
  `export const HARVARD_PHONEME_META = ${JSON.stringify(metaOut, null, 2)};\n\n` +
  `export const HARVARD_PHONEMES = ${JSON.stringify(phonemes, null, 2)};\n`;

fs.writeFileSync(outPath, outJs, "utf8");
console.log("Wrote:", outPath);
