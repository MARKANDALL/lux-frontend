// scripts/build-harvard-phonemes.mjs
import fs from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";
import { createRequire } from "node:module";

import { ensureHarvardPassages, passages } from "../src/data/index.js";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

function pad2(n) {
  return String(n).padStart(2, "0");
}
function harvardKey(n) {
  return `harvard${pad2(n)}`;
}

// ---------- CMU dict loading (handles multiple export shapes) ----------
const require = createRequire(import.meta.url);
const cmuRaw = require("cmu-pronouncing-dictionary");

function parseCmuTextToMap(text) {
  const map = Object.create(null);
  const lines = String(text || "").split(/\r?\n/);
  for (const line of lines) {
    const s = line.trim();
    if (!s || s.startsWith(";;;")) continue;

    // Example: WORD  W ER1 D
    // Example alt: WORD(1)  W ER1 D
    const m = s.match(/^([A-Z0-9'_-]+)(\(\d+\))?\s+(.+)$/);
    if (!m) continue;

    const base = m[1];
    const variant = m[2] || "";
    const phones = m[3].trim();
    const key = (base + variant).toLowerCase();
    if (!map[key]) map[key] = [];
    map[key].push(phones);
  }
  return map;
}

function loadCmuMap(raw) {
  const dict = raw?.dictionary ?? raw;
  if (!dict) return Object.create(null);

  // Case A: dictionary is a raw CMU text blob
  if (typeof dict === "string") return parseCmuTextToMap(dict);

  // Case B: dictionary is already an object map
  if (typeof dict === "object") {
    // normalize to lowercase keys, array-of-prons
    const out = Object.create(null);
    for (const [k, v] of Object.entries(dict)) {
      const key = String(k || "").toLowerCase();
      if (!key) continue;
      if (Array.isArray(v)) out[key] = v.map(String);
      else out[key] = [String(v)];
    }
    return out;
  }

  return Object.create(null);
}

const CMU = loadCmuMap(cmuRaw);

// ---------- phoneme extraction ----------
function tokenizeWords(text) {
  // Keep apostrophes inside words.
  return String(text || "").match(/[A-Za-z']+/g) || [];
}

function stripStress(phone) {
  return String(phone || "").replace(/[0-9]/g, "");
}

function phonesForWord(word) {
  const w = String(word || "").toLowerCase();
  if (!w) return [];

  // Try base and a few common alternates
  const tries = [w, `${w}(1)`, `${w}(2)`, `${w}(3)`];
  let prons = null;

  for (const t of tries) {
    prons = CMU[t];
    if (prons && prons.length) break;
  }
  if (!prons || !prons.length) return [];

  const first = String(prons[0] || "");
  if (!first) return [];

  return first
    .split(/\s+/)
    .map(stripStress)
    .filter(Boolean);
}

// ---------- build meta ----------
async function main() {
  await ensureHarvardPassages();

  // 1) collect list counts + global counts
  const perList = Object.create(null); // n -> { counts, total }
  const globalCounts = Object.create(null);
  let globalTotal = 0;

  for (let n = 1; n <= 72; n++) {
    const key = harvardKey(n);
    const p = passages?.[key];
    const parts = Array.isArray(p?.parts) ? p.parts.slice(0, 10) : [];
    const text = parts.join(" ");
    const words = tokenizeWords(text);

    const counts = Object.create(null);
    let total = 0;

    for (const w of words) {
      const phones = phonesForWord(w);
      for (const ph of phones) {
        counts[ph] = (counts[ph] || 0) + 1;
        globalCounts[ph] = (globalCounts[ph] || 0) + 1;
        total += 1;
        globalTotal += 1;
      }
    }

    perList[n] = { counts, total };
  }

  // 2) compute top3 “distinctive” by lift vs global
  const out = Object.create(null);

  for (let n = 1; n <= 72; n++) {
    const { counts, total } = perList[n];
    const rows = [];

    for (const [ph, count] of Object.entries(counts)) {
      const pct = total ? count / total : 0;
      const gCount = globalCounts[ph] || 0;
      const gPct = globalTotal ? gCount / globalTotal : 0;
      const lift = gPct ? pct / gPct : 0;

      rows.push({ ph, count, pct, lift });
    }

    rows.sort((a, b) => (b.lift - a.lift) || (b.count - a.count) || a.ph.localeCompare(b.ph));

    out[String(n)] = {
      top3: rows.slice(0, 3),
      totalPhones: total,
      // NEW: full counts so the UI can sort by a chosen phoneme
      phCounts: counts,
    };
  }

  const header =
    `// AUTO-GENERATED by scripts/build-harvard-phonemes.mjs\n` +
    `// Do not hand-edit.\n`;

  const body = `export const HARVARD_PHONEME_META = ${JSON.stringify(out, null, 2)};\n`;

  const outFile = path.resolve(__dirname, "../src/data/harvard-phoneme-meta.js");
  fs.mkdirSync(path.dirname(outFile), { recursive: true });
  fs.writeFileSync(outFile, header + body, "utf8");

  console.log("Wrote:", outFile);
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});
