import fs from "fs";
import path from "path";
import { createRequire } from "module";

const require = createRequire(import.meta.url);
const cmuRaw = require("cmu-pronouncing-dictionary");

const cmu = cmuRaw && typeof cmuRaw === "object" ? cmuRaw : {};

const ROOT = process.cwd();
const HARVARD = path.join(ROOT, "src", "data", "harvard-lists.js");
const OUT = path.join(ROOT, "src", "data", "harvard-phoneme-meta.js");

function normalizeWord(w) {
  return w.toLowerCase().replace(/[^a-z']/g, "");
}

function tokenize(text) {
  return text
    .split(/\s+/)
    .map(normalizeWord)
    .filter(Boolean);
}

function pickPron(v) {
  if (!v) return null;
  if (Array.isArray(v)) return v[0] || null;
  if (typeof v === "string") return v;
  return null;
}

function wordToPhones(word) {
  const w0 = word.toLowerCase();
  const w1 = w0.replace(/'/g, "");

  const u0 = w0.toUpperCase();
  const u1 = w1.toUpperCase();

  const v =
    pickPron(cmu[w0]) ||
    pickPron(cmu[w1]) ||
    pickPron(cmu[w1 + "(1)"]) ||
    pickPron(cmu[w0 + "(1)"]) ||
    pickPron(cmu[u0]) ||
    pickPron(cmu[u1]) ||
    pickPron(cmu[u1 + "(1)"]) ||
    pickPron(cmu[u0 + "(1)"]);

  if (!v) return null;

  return String(v)
    .trim()
    .split(/\s+/)
    .map((p) => p.replace(/[0-2]$/, ""));
}


function readHarvardSource() {
  const txt = fs.readFileSync(HARVARD, "utf8");
  const lists = [];

  for (let n = 1; n <= 72; n++) {
    const nn = String(n).padStart(2, "0");
    const re = new RegExp(
      `export\\s+const\\s+harvardList${nn}Parts\\s*=\\s*\\[([\\s\\S]*?)\\];`,
      "m"
    );
    const m = txt.match(re);
    if (!m) throw new Error(`Missing harvardList${nn}Parts`);

    const body = m[1];
    const lines = [];
    const lineRe = /"([^"]+)"/g;

    let lm;
    while ((lm = lineRe.exec(body))) lines.push(lm[1]);

    lists.push({ n, lines });
  }

  return lists;
}

function countPhonesForLines(lines) {
  const counts = new Map();
  let totalPhones = 0;

  for (const line of lines) {
    const words = tokenize(line);
    for (const w of words) {
      const phones = wordToPhones(w);
      if (!phones) continue;
      for (const ph of phones) {
        counts.set(ph, (counts.get(ph) || 0) + 1);
        totalPhones++;
      }
    }
  }

  return { counts, totalPhones };
}

function topDistinctive(listCounts, listTotal, globalCounts, globalTotal, k = 3) {
  const items = [];

  for (const [ph, c] of listCounts.entries()) {
    const pct = listTotal ? c / listTotal : 0;

    const g = globalCounts.get(ph) || 0;
    const gpct = globalTotal ? g / globalTotal : 0;

    const lift = gpct > 0 ? pct / gpct : 0;

    items.push({ ph, count: c, pct, lift });
  }

  items.sort((a, b) => (b.lift - a.lift) || (b.count - a.count));
  return items.slice(0, k);
}

function main() {
  const lists = readHarvardSource();

  const globalCounts = new Map();
  let globalTotal = 0;

  const listData = [];
  for (const L of lists) {
    const { counts, totalPhones } = countPhonesForLines(L.lines);
    listData.push({ n: L.n, counts, totalPhones });

    for (const [ph, c] of counts.entries()) {
      globalCounts.set(ph, (globalCounts.get(ph) || 0) + c);
    }
    globalTotal += totalPhones;
  }

  const out = {};
  for (const L of listData) {
    out[L.n] = {
      top3: topDistinctive(L.counts, L.totalPhones, globalCounts, globalTotal, 3),
      totalPhones: L.totalPhones
    };
  }

  const js = `// AUTO-GENERATED by scripts/build-harvard-phonemes.mjs
// Do not hand-edit.
export const HARVARD_PHONEME_META = ${JSON.stringify(out, null, 2)};
`;

  fs.writeFileSync(OUT, js, "utf8");
  console.log("Wrote:", OUT);
}

main();
