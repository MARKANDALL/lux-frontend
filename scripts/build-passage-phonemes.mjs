console.log("[build-passage-phonemes] start");

import fs from "fs";
import path from "path";
import { createRequire } from "module";

const require = createRequire(import.meta.url);
const cmuPkg = require("cmu-pronouncing-dictionary");

// IMPORTANT: package exports { dictionary }
const CMU = cmuPkg?.dictionary || {};

const ROOT = process.cwd();
const OUT = path.join(ROOT, "src", "data", "passage-phoneme-meta.js");

async function loadModule(relPath) {
  try {
    return await import(relPath);
  } catch (e) {
    console.warn("[build-passage-phonemes] could not import", relPath, e?.message || e);
    return null;
  }
}

function pickPassageMap(mod) {
  if (!mod) return null;
  // Try the most likely export names across your repo
  return (
    mod.basePassages ||
    mod.harvardPassages ||
    mod.passages ||
    mod.PASSAGES ||
    mod.default ||
    null
  );
}

// ---------- helpers ----------
function normalizeWord(w) {
  return w.toLowerCase().replace(/[^a-z']/g, "");
}

function tokenize(text) {
  return text
    .split(/\s+/)
    .map(normalizeWord)
    .filter(Boolean);
}

function pickPron(v) {
  if (!v) return null;
  if (Array.isArray(v)) return v[0] || null;
  if (typeof v === "string") return v;
  return null;
}

function wordToPhones(word) {
  const w0 = word.toLowerCase();
  const w1 = w0.replace(/'/g, "");
  const U0 = w0.toUpperCase();
  const U1 = w1.toUpperCase();

  const v =
    pickPron(CMU[w0]) ||
    pickPron(CMU[w1]) ||
    pickPron(CMU[w1 + "(1)"]) ||
    pickPron(CMU[w0 + "(1)"]) ||
    pickPron(CMU[U0]) ||
    pickPron(CMU[U1]) ||
    pickPron(CMU[U1 + "(1)"]) ||
    pickPron(CMU[U0 + "(1)"]);

  if (!v) return null;

  return String(v)
    .trim()
    .split(/\s+/)
    .map((p) => p.replace(/[0-2]$/, ""));
}

function countPhonesForText(lines) {
  const counts = {};
  let totalPhones = 0;

  for (const line of lines) {
    const words = tokenize(line);
    for (const w of words) {
      const phones = wordToPhones(w);
      if (!phones) continue;

      for (const ph of phones) {
        counts[ph] = (counts[ph] || 0) + 1;
        totalPhones++;
      }
    }
  }

  return { counts, totalPhones };
}

// ---------- MAIN ----------
async function main() {
  const meta = {};

  // Try a couple likely sources for your "all passages" library
  const m1 = await loadModule("../src/data/passages.js");
  const m2 = await loadModule("../src/data/harvard.js");
  const m3 = await loadModule("../src/data/index.js"); // sometimes centralizes exports

  const maps = [
    pickPassageMap(m1),
    pickPassageMap(m2),
    pickPassageMap(m3),
  ].filter(Boolean);

  if (maps.length === 0) {
    throw new Error("Could not find a passage map export in passages.js / harvard.js / index.js");
  }

  for (const passMap of maps) {
    Object.entries(passMap).forEach(([key, p]) => {
      if (!p || typeof p !== "object") return;
      const parts = Array.isArray(p.parts) ? p.parts : [];
      if (parts.length === 0) return;
      // Don't overwrite if already computed from another map
      if (!meta[key]) meta[key] = countPhonesForText(parts);
    });
  }

  const keys = Object.keys(meta);
  const hasHarvard01 = Boolean(meta.harvard01);
  console.log("[build-passage-phonemes] keys:", keys.length, "hasHarvard01:", hasHarvard01);
  if (!hasHarvard01) {
    console.warn("[build-passage-phonemes] WARNING: harvard passages not found in meta. Did harvard.js load/export correctly?");
  }

  const js = `// AUTO-GENERATED by scripts/build-passage-phonemes.mjs
// Do not hand-edit.
export const PASSAGE_PHONEME_META = ${JSON.stringify(meta, null, 2)};
`;

  fs.writeFileSync(OUT, js, "utf8");
  console.log("[build-passage-phonemes] wrote:", OUT);
}

main()
  .then(() => {
    console.log("[build-passage-phonemes] done");
  })
  .catch((err) => {
    console.error("[build-passage-phonemes] fatal:", err);
    process.exitCode = 1;
  });
