This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.eslintrc.json
.gitignore
.repomixignore
01-utils.js
admin/index.html
admin/overview.html
admin/user.html
api/ai.js
api/assess.js
api/attempts.js
api/convo-report.js
api/convo.js
api/identity.js
api/index.js
api/util.js
api/wix.js
app-core/audio-sink.js
app-core/lux-utils.js
app-core/phones-normalize.js
app-core/state.js
convo.html
core/prosody/index.js
core/scoring/index.js
features/balloon/balloon.css
features/balloon/index.js
features/balloon/ui.js
features/convo/convo-api.js
features/convo/convo-coach.js
features/convo/convo-flow.js
features/convo/convo-highlight.js
features/convo/convo-layout.js
features/convo/convo-modes.js
features/convo/convo-shared.js
features/convo/index.js
features/convo/knobs-drawer.js
features/convo/picker-deck.js
features/convo/progress.js
features/convo/scenarios.js
features/convo/scene-atmo.js
features/dashboard/index.js
features/dashboard/ui.js
features/features/08-selfpb-peekaboo.js
features/features/self-playback.css
features/features/selfpb-peekaboo.css
features/features/selfpb/core.js
features/features/selfpb/dom.js
features/features/selfpb/styles.js
features/features/selfpb/ui-GOLD.js
features/features/selfpb/ui.js
features/features/selfpb/waveform-logic.js
features/features/tts-peekaboo.css
features/features/tts.css
features/features/tts/boot-tts.js
features/features/tts/player-core.js
features/features/tts/player-dom.js
features/features/tts/player-ui.js
features/features/tts/tts-overlay.css
features/harvard/index.js
features/interactions/boot.js
features/interactions/helpers.js
features/interactions/index.js
features/interactions/legend-toggle.js
features/interactions/metric-modal.js
features/interactions/metric-modal/derive.js
features/interactions/metric-modal/events.js
features/interactions/metric-modal/index.js
features/interactions/metric-modal/render.js
features/interactions/ph-audio.js
features/interactions/ph-chips.js
features/interactions/ph-hover.js
features/interactions/ph-hover/chip-events.js
features/interactions/ph-hover/dom.js
features/interactions/ph-hover/header-preview.js
features/interactions/ph-hover/index.js
features/interactions/ph-hover/tooltip-carousel.js
features/interactions/ph-hover/tooltip-modal.js
features/interactions/ph-hover/tooltip-render.js
features/interactions/ph-hover/tooltip-video.js
features/interactions/ph-hover/utils.js
features/interactions/score-collapse.js
features/interactions/tips.js
features/interactions/utils.js
features/interactions/yg-hover.js
features/my-words/index.js
features/my-words/launcher.js
features/my-words/library-modal.js
features/my-words/my-words.css
features/my-words/normalize.js
features/my-words/panel.js
features/my-words/service.js
features/my-words/stats.js
features/my-words/store.js
features/next-activity/next-activity.js
features/onboarding/lux-onboarding.js
features/passages/dom.js
features/passages/index.js
features/progress/attempt-detail-modal.js
features/progress/attempt-detail/ai-coach-section.js
features/progress/attempt-detail/attempts-section.js
features/progress/attempt-detail/chip-explainers.js
features/progress/attempt-detail/chips.js
features/progress/attempt-detail/derive.js
features/progress/attempt-detail/format.js
features/progress/attempt-detail/header.js
features/progress/attempt-detail/metrics.js
features/progress/attempt-detail/modal-shell.js
features/progress/attempt-detail/trouble-sections.js
features/progress/attempt-pickers.js
features/progress/progress-utils.js
features/progress/render.js
features/progress/render/dashboard.js
features/progress/render/export.js
features/progress/render/format.js
features/progress/render/index.js
features/progress/render/mini.js
features/progress/render/sparkline.js
features/progress/rollups.js
features/progress/wordcloud/action-sheet.js
features/progress/wordcloud/attempt-utils.js
features/progress/wordcloud/compute.js
features/progress/wordcloud/context.js
features/progress/wordcloud/data-loader.js
features/progress/wordcloud/dom.js
features/progress/wordcloud/drawing-orchestrator.js
features/progress/wordcloud/event-handlers.js
features/progress/wordcloud/events.js
features/progress/wordcloud/index.js
features/progress/wordcloud/index.module.js
features/progress/wordcloud/labels.js
features/progress/wordcloud/libs.js
features/progress/wordcloud/plan.js
features/progress/wordcloud/render-canvas.js
features/progress/wordcloud/render.js
features/progress/wordcloud/sheet-controller.js
features/progress/wordcloud/side-drawers.js
features/progress/wordcloud/state-store.js
features/progress/wordcloud/strips.js
features/progress/wordcloud/template.js
features/progress/wordcloud/timeline.js
features/progress/wordcloud/ui-manager.js
features/progress/wordcloud/url-state.js
features/progress/wordcloud/view-logic.js
features/progress/wordcloud/wordcloud-dock.css
features/recorder/audio-inspector.js
features/recorder/audio-mode-core.js
features/recorder/audio-mode-switch.js
features/recorder/audio-mode.js
features/recorder/index.js
features/recorder/media.js
features/recorder/ui.js
features/results/deps.js
features/results/header-modern.js
features/results/header.js
features/results/index.js
features/results/render-core.js
features/results/render-helpers.js
features/results/render-modern.js
features/results/rows-logic.js
features/results/rows.js
features/results/summary-feedback.js
features/results/summary-shell.js
features/results/summary.js
features/results/syllables.js
helpers/assess.js
helpers/core.js
helpers/dom.js
helpers/index.js
index.html
lux-audio-mode.css
lux-convo.atmo.css
lux-convo.chat.css
lux-convo.css
lux-convo.knobs.css
lux-convo.picker.css
lux-convo.system.css
lux-convo.tokens.css
lux-layout.ai-feedback.css
lux-layout.core.css
lux-layout.css
lux-layout.harvard.css
lux-layout.interactions.css
lux-layout.messaging.css
lux-layout.nav-cta.css
lux-layout.scrollbar.css
lux-layout.tokens.css
lux-layout.top-banner.css
lux-onboarding.css
lux-popover.css
lux-popover.js
lux-progress.css
lux-results.accordion.css
lux-results.ai.css
lux-results.css
lux-results.legacy.css
lux-results.prosody.css
lux-results.table.css
lux-widgets.buttons.css
lux-widgets.core.css
lux-widgets.css
lux-widgets.metric-modal.css
lux-widgets.record-viz.css
lux-widgets.results-panels.css
lux-widgets.score-tiles.css
lux-widgets.table.css
lux-wordcloud.css
package.json
progress.html
prosody/annotate.js
prosody/core-calc.js
prosody/prosody-help-bars.js
prosody/prosody-render-bars.js
README.md
repomix.config.json
scripts/lux-release.ps1
scripts/lux-snapshot.ps1
scripts/make-thumbs.mjs
src/api/index.js
src/api/util.js
src/convo.js
src/data/harvard-lists.js
src/data/harvard.js
src/data/index.js
src/data/passages.js
src/data/phonemes/assets.js
src/data/phonemes/core.js
src/data/phonemes/details.js
src/main.js
src/progress.js
src/supabase.js
src/wordcloud.js
ui/auth-dom.js
ui/lazy-assets.js
ui/ui-ai-ai-dom.js
ui/ui-ai-ai-logic.js
ui/ui-arrow-trail.css
ui/ui-arrow-trail.js
ui/ui-ripple-filter.js
ui/ui-shell-typing.js
ui/warp-core.js
ui/warp-nav.js
ui/warp.css
vite.config.js
wordcloud.html
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".eslintrc.json">
{
  "env": {
    "browser": true,
    "es2021": true
  },
  "extends": ["eslint:recommended"],
  "parser": "babel-eslint",
  "parserOptions": {
    "ecmaVersion": 6,
    "sourceType": "module"
  }
}
</file>

<file path="01-utils.js">
/* ============================================================================
   LEGACY DUPLICATE — DO NOT USE FOR NEW CODE
   ---------------------------------------------------------------------------
   This file defines an old norm() helper.
   Canonical norm now lives here:

     src/data/phonemes/core.js   ✅ truth source

   Live code should import norm from the canonical core or via ui/views/deps.js.
   Keep this only for reference until Phase 3 cleanup moves it to /legacy.
============================================================================ */
/* NON-MODULE: helpers & globals */
// fallbacks/data accessors
var G = window;
var norm =
  window.norm ||
  function norm(s) {
    return String(s || "")
      .trim()
      .toLowerCase()
      .replace(/\s+/g, " ");
  };
var getPhonemeAssetByIPA =
  window.getPhonemeAssetByIPA ||
  function () {
    return {};
  };
var articulatorPlacement = window.articulatorPlacement || {};
var phonemeDetailsByIPA = window.phonemeDetailsByIPA || {};
var ytLink = window.ytLink;

// tiny helpers
var isCorrupt =
  window.isCorrupt ||
  function (word) {
    return /[�‘’“”—–…•-￿]/.test(word);
  };
var encouragingLine =
  window.encouragingLine ||
  function () {
    var m = [
      "Great effort! Keep going—your persistence is paying off.",
      "Nice work! Every attempt brings you closer to perfect pronunciation.",
      "You're improving with every try—keep it up!",
      "Excellent focus! Small adjustments make a big difference.",
      "Keep practicing—you're making real progress!",
    ];
    return m[Math.floor(Math.random() * m.length)];
  };

var safePlayVideo =
  window.safePlayVideo ||
  function safePlayVideo(vidEl, canonicalUrl, opts) {
    opts = opts || {};
    if (!vidEl) return;
    var muted = opts.muted;
    var restart = "restart" in opts ? !!opts.restart : true;

    var needsBust = /(\.csb\.app|codesandbox\.io)$/i.test(location.hostname);
    if (needsBust && canonicalUrl) {
      var bust =
        canonicalUrl +
        (canonicalUrl.includes("?") ? "&" : "?") +
        "nocache=" +
        Date.now();
      if (vidEl.src !== bust) {
        vidEl.src = bust;
        vidEl.load();
      }
    }
    if (muted !== undefined) vidEl.muted = !!muted;
    if (restart) vidEl.currentTime = 0;
    var p = vidEl.play();
    if (p && typeof p.then === "function") p.catch(function () {});
  };

var resolveYTLink =
  window.resolveYTLink ||
  function resolveYTLink(arg) {
    try {
      if (typeof ytLink === "function") return ytLink(arg);
      if (typeof ytLink === "string") return ytLink;
    } catch (_) {}
    return null;
  };

var scoreClass =
  window.scoreClass ||
  function (score) {
    if (score == null) return "";
    if (score >= 85) return "score-good";
    if (score >= 70) return "score-warn";
    return "score-bad";
  };

var buildYouglishUrl =
  window.buildYouglishUrl ||
  function (word) {
    return (
      "https://youglish.com/pronounce/" + encodeURIComponent(word) + "/english"
    );
  };

var numOrNull =
  window.numOrNull ||
  function (v) {
    var n = Number(v);
    return Number.isFinite(n) ? n : null;
  };
var fmtPct =
  window.fmtPct ||
  function (v) {
    if (v == null) return "–";
    var n = Number(v);
    if (!Number.isFinite(n)) return "–";
    return Number.isInteger(n) ? n + "%" : n.toFixed(1) + "%";
  };
</file>

<file path="admin/index.html">
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>User Progress (admin)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <script>
    (function ensureToken() {
      const qs = new URLSearchParams(location.search);
      const fromQS = qs.get('token') || qs.get('t');
      if (fromQS) sessionStorage.setItem('lux_admin_token', fromQS);
      if (!sessionStorage.getItem('lux_admin_token')) {
        const entered = prompt('Enter admin token');
        if (entered) sessionStorage.setItem('lux_admin_token', entered.trim());
      }
    })();
  </script>

  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

  <style>
    :root{ --gap:10px; }
    *{ box-sizing:border-box }
    body{ font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Arial; padding:16px; color:#111 }
    h1{ margin:0 0 14px }

    .nav { display:flex; gap:10px; align-items:center; margin-bottom:8px; }
    .nav-link { padding:2px 6px; text-decoration:none; color:inherit; border-radius:6px; }
    .nav-link.active { font-weight:600; text-decoration:underline; }
    .right{ margin-left:auto }
    .note{ color:#666; font-size:12px }

    .bar{ display:flex; flex-wrap:wrap; align-items:center; gap:10px; margin-bottom:10px }
    .bar small{ color:#666; margin-left:auto }
    input[type="text"], input[type="number"], input[type="date"]{ padding:8px; border:1px solid #ccc; border-radius:8px; height:36px; }
    button, a.btn{ padding:8px 12px; border:1px solid #ccc; border-radius:8px; background:#fff; cursor:pointer; text-decoration:none; display:inline-flex; align-items:center; height:36px; }
    button:disabled{ opacity:.6; cursor:default }
    .pill{ display:inline-block; min-width:92px; padding:8px 10px; border:1px solid #ddd; border-radius:10px; background:#fafafa }
    .pill b{ display:block; font-size:18px; }
    #chartWrap{ margin:16px 0 12px }
    #chart{ width:100%; max-width:1100px; height:360px }
    .row{ display:flex; flex-wrap:wrap; gap:10px; align-items:center; margin:8px 0 }
    .checks{ display:flex; gap:14px; align-items:center; flex-wrap:wrap }

    table{ border-collapse:collapse; width:100%; margin-top:10px; font-size:13px }
    th,td{ border:1px solid #e7e7e7; padding:8px; vertical-align:top }
    th{ background:#f7f9fc; position:sticky; top:0; z-index:1 }
    td.text{ max-width:600px }
    .muted{ color:#666 }
    .ok{ color:#0a7; }
    .err{ color:#c00; }
  </style>
</head>
<body>
  <nav class="nav">
    <a href="/admin/overview.html" class="nav-link">Cohort</a>
    <a href="/admin/user.html" class="nav-link">Attempts</a>
    <a href="/admin/index.html" class="nav-link active">User Progress</a>
    <span class="right note">Token lives in this tab</span>
  </nav>

  <h1>User Progress (admin)</h1>

  <div class="bar">
    <label>UID <input id="uid" type="text" placeholder="user id" style="width:380px"></label>
    <label>Limit <input id="limit" type="number" value="500" min="1" max="20000" style="width:96px"></label>
    <button id="loadBtn">Load</button>
    <a id="csvBtn" class="btn" target="_blank" rel="noopener">Download CSV</a>
    <button id="troubleCsvBtn">Download trouble CSV</button>
    <button id="copyBtn">Copy link</button>
  </div>

  <div class="row">
    <label style="flex:1; min-width:320px">Display name
      <input id="labelInput" type="text" placeholder="e.g., Mark H." style="width:100%">
    </label>
    <button id="saveNameBtn">Save name</button>
    <span id="saveMsg" class="muted"></span>
  </div>

  <div class="row">
    <label>From <input id="from" type="date"></label>
    <label>To <input id="to" type="date"></label>
    <label>Smoothing
      <select id="smooth">
        <option value="7">7-day</option>
        <option value="3">3-day</option>
        <option value="0">None</option>
      </select>
    </label>

    <div class="checks">
      <span>Passages:</span>
      <label><input class="pass" type="checkbox" value="grandfather" checked> grandfather</label>
      <label><input class="pass" type="checkbox" value="rainbow" checked> rainbow</label>
      <label><input class="pass" type="checkbox" value="sentences" checked> sentences</label>
      <label><input class="pass" type="checkbox" value="wordList" checked> wordList</label>
    </div>

    <button id="applyBtn">Apply</button>
    <button id="clearBtn">Clear</button>
  </div>

  <div class="row" style="gap:16px">
    <div class="pill"><div class="muted">Attempts</div><b id="statAttempts">0</b></div>
    <div class="pill"><div class="muted">Avg Pron</div><b id="statAvg">–</b></div>
  </div>

  <div id="chartWrap">
    <canvas id="chart"></canvas>
  </div>

  <div class="row" style="gap:16px; margin-top:8px">
    <div style="max-width:520px; flex:1">
      <h3 style="margin:8px 0 6px">Trouble sounds</h3>
      <table id="troublePh">
        <thead><tr><th>Phoneme</th><th>Count</th><th>Avg score</th></tr></thead>
        <tbody></tbody>
      </table>
    </div>
    <div style="max-width:520px; flex:1">
      <h3 style="margin:8px 0 6px">Trouble words</h3>
      <table id="troubleWord">
        <thead><tr><th>Word</th><th>Count</th><th>Avg score</th></tr></thead>
        <tbody></tbody>
      </table>
    </div>
  </div>

  <table id="grid">
    <thead>
      <tr>
        <th style="width:170px">Time (local)</th>
        <th>Passage</th>
        <th>Part</th>
        <th>Acc</th>
        <th>Flu</th>
        <th>Comp</th>
        <th>Pron</th>
        <th class="text">Text</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>

<script>
(function () {
const API_BASE = "";
  const TOKEN = sessionStorage.getItem('lux_admin_token') || '';
  const headers = TOKEN ? { 'x-admin-token': TOKEN } : {};

  const uidEl   = document.getElementById('uid');
  const limitEl = document.getElementById('limit');
  const fromEl  = document.getElementById('from');
  const toEl    = document.getElementById('to');
  const smoothEl= document.getElementById('smooth');
  const passEls = Array.from(document.querySelectorAll('.pass'));
  const csvBtn  = document.getElementById('csvBtn');
  const loadBtn = document.getElementById('loadBtn');
  const applyBtn= document.getElementById('applyBtn');
  const clearBtn= document.getElementById('clearBtn');
  const copyBtn = document.getElementById('copyBtn');
  const labelInput = document.getElementById('labelInput');
  const saveBtn = document.getElementById('saveNameBtn');
  const saveMsg = document.getElementById('saveMsg');
  const statAttempts = document.getElementById('statAttempts');
  const statAvg = document.getElementById('statAvg');
  const tbody  = document.querySelector('#grid tbody');
  const chartCanvas = document.getElementById('chart');
  const troubleBtn = document.getElementById('troubleCsvBtn');

  // ... (rest of logic same as source, but URL patched) ...
  // Minimal re-implementation of critical functions to use API_BASE

  const qs = new URLSearchParams(location.search);
  uidEl.value = qs.get('uid') || '';
  limitEl.value = Number(qs.get('limit') || 500);

  (function initDates(){
    const pad = (n)=>String(n).padStart(2,'0');
    const toStr = (d)=>`${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}`;
    const today = new Date();
    const fromDefault = new Date(); fromDefault.setDate(fromDefault.getDate()-14);
    fromEl.value = qs.get('from') || toStr(fromDefault);
    toEl.value   = qs.get('to')   || toStr(today);
  })();

  (function initPassages(){
    const p = qs.get('passages');
    if (p) {
      const set = new Set(p.split(',').map(s=>s.trim()));
      passEls.forEach(el => el.checked = set.has(el.value));
    }
  })();
  smoothEl.value = qs.get('smooth') ?? '7';

  let lineChart = null;
  let currentRows = [];

  const dateOnly = (iso)=>iso.slice(0,10);
  const toLocal  = (iso)=> new Date(iso).toLocaleString();

  function buildPassagesParam() {
    return passEls.filter(e => e.checked).map(e => e.value).join(',');
  }

  function updateCsvHref() {
    const uid = uidEl.value.trim();
    const limit = Number(limitEl.value||500);
    const passages = buildPassagesParam();
    const from = fromEl.value; const to = toEl.value;

    let url = `${API_BASE}/api/admin-recent?format=csv&limit=${encodeURIComponent(limit)}&token=${encodeURIComponent(TOKEN)}`;
    if (uid) url += `&uid=${encodeURIComponent(uid)}`;
    if (from) url += `&from=${encodeURIComponent(from)}`;
    if (to) url += `&to=${encodeURIComponent(to)}`;
    if (passages) url += `&passages=${encodeURIComponent(passages)}`;
    csvBtn.href = url;
  }

  function copyLinkToClipboard() {
    const url = new URL(location.href);
    const params = new URLSearchParams();
    if (uidEl.value) params.set('uid', uidEl.value);
    if (fromEl.value) params.set('from', fromEl.value);
    if (toEl.value) params.set('to', toEl.value);
    if (smoothEl.value) params.set('smooth', smoothEl.value);
    const passages = buildPassagesParam();
    if (passages) params.set('passages', passages);
    if (limitEl.value) params.set('limit', limitEl.value);
    url.search = params.toString();
    navigator.clipboard.writeText(url.toString())
      .then(()=>{ copyBtn.textContent='Copied!'; setTimeout(()=>copyBtn.textContent='Copy link',1000); });
  }

  function computeDailyAndSMA(rows, windowDays) {
    const sorted = rows.slice().sort((a,b)=> new Date(a.ts) - new Date(b.ts));
    const byDay = new Map();
    for (const r of sorted) {
      const p = Number(r?.summary?.pron);
      if (!Number.isFinite(p)) continue;
      const d = dateOnly(r.ts);
      const arr = byDay.get(d) || [];
      arr.push(p);
      byDay.set(d, arr);
    }
    const days = Array.from(byDay.keys()).sort();
    const daily = days.map(d => ({
      date: d,
      value: byDay.get(d).reduce((a,b)=>a+b,0)/byDay.get(d).length
    }));
    if (!windowDays || windowDays <= 0) return {daily, sma:[]};
    const sma = [];
    for (let i=0;i<daily.length;i++){
      const start = Math.max(0, i - (windowDays - 1));
      let sum = 0, count = 0;
      for (let j=start;j<=i;j++){ sum += daily[j].value; count++; }
      sma.push({ date: daily[i].date, value: sum / count });
    }
    return {daily, sma};
  }

  function renderChart(rows) {
    const smoothDays = Number(smoothEl.value||0);
    const {daily, sma} = computeDailyAndSMA(rows, smoothDays);
    const labels = daily.map(d => d.date);
    const pronSeries = daily.map(d => Number(d.value.toFixed(1)));
    const smaSeries = sma.map(d => Number(d.value.toFixed(1)));
    const data = {
      labels,
      datasets: [
        { label: 'Pron score (daily avg)', data: pronSeries, borderWidth: 2, pointRadius: 3, tension: 0.2 },
        { label: smoothDays ? `${smoothDays}-day avg` : 'moving avg (off)', data: smaSeries, borderWidth: 2, pointRadius: 0, borderDash: smoothDays ? [] : [4,4], tension: 0.2 }
      ]
    };
    if (lineChart) lineChart.destroy();
    lineChart = new Chart(chartCanvas.getContext('2d'), { type: 'line', data, options:{responsive:true, maintainAspectRatio:false, scales:{y:{min:0,max:100}}} });
  }

  function renderTable(rows) {
    tbody.innerHTML = '';
    for (const r of rows) {
      const s = r.summary || {};
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td>${toLocal(r.ts)}</td>
        <td>${r.passage_key || ''}</td>
        <td>${r.part_index ?? ''}</td>
        <td>${s.acc ?? ''}</td>
        <td>${s.flu ?? ''}</td>
        <td>${s.comp ?? ''}</td>
        <td>${s.pron ?? ''}</td>
        <td class="text">${String(r.text||'').replace(/[<>&]/g,c=>({ '<':'&lt;', '>':'&gt;', '&':'&amp;' }[c]))}</td>
      `;
      tbody.appendChild(tr);
    }
  }

  function renderTrouble(rows){
    const ph = new Map(), wd = new Map();
    for (const r of rows){
      const lows = r?.summary?.lows;
      if (!Array.isArray(lows)) continue;
      for (const L of lows){
        const score = Number(L.score);
        if (!Number.isFinite(score)) continue;
        if (L.phoneme){ const a=ph.get(L.phoneme)||{sum:0,n:0}; a.sum+=score; a.n++; ph.set(L.phoneme,a); }
        if (L.word){ const a=wd.get(L.word)||{sum:0,n:0}; a.sum+=score; a.n++; wd.set(L.word,a); }
      }
    }
    const top = (m) => [...m.entries()].map(([k,v])=>({k, n:v.n, avg:v.sum/v.n})).sort((a,b)=>b.n-a.n).slice(0,10);
    document.querySelector('#troublePh tbody').innerHTML = top(ph).map(r=>`<tr><td>${r.k}</td><td>${r.n}</td><td>${r.avg.toFixed(1)}</td></tr>`).join('');
    document.querySelector('#troubleWord tbody').innerHTML = top(wd).map(r=>`<tr><td>${r.k}</td><td>${r.n}</td><td>${r.avg.toFixed(1)}</td></tr>`).join('');
  }

  async function loadData() {
    const uid = uidEl.value.trim();
    if (!uid) { alert('Enter a UID'); return; }
    loadBtn.disabled = true;
    try {
      const limit = Number(limitEl.value || 500);
      const passages = buildPassagesParam();
      let url = `${API_BASE}/api/admin-recent?limit=${encodeURIComponent(limit)}&uid=${encodeURIComponent(uid)}`;
      if (fromEl.value) url += `&from=${encodeURIComponent(fromEl.value)}`;
      if (toEl.value)   url += `&to=${encodeURIComponent(toEl.value)}`;
      if (passages)     url += `&passages=${encodeURIComponent(passages)}`;

      const r = await fetch(url, { cache:'no-store', headers });
      if (!r.ok) throw new Error(`HTTP ${r.status}`);
      const json = await r.json();
      currentRows = json.rows || [];
      if (currentRows[0] && currentRows[0].label) labelInput.value = currentRows[0].label;

      statAttempts.textContent = currentRows.length;
      const vals = currentRows.map(r => Number(r?.summary?.pron)).filter(Number.isFinite);
      statAvg.textContent = vals.length ? (vals.reduce((a,b)=>a+b,0)/vals.length).toFixed(1) : '–';

      renderChart(currentRows);
      renderTrouble(currentRows);
      renderTable(currentRows);
      updateCsvHref();
    } catch(e) {
      alert('Load failed: '+e.message);
    } finally {
      loadBtn.disabled = false;
    }
  }

  async function saveLabel() {
    const uid = uidEl.value.trim();
    const label = labelInput.value.trim();
    if (!uid) return;
    saveMsg.textContent = 'Saving...';
    try {
      await fetch(`${API_BASE}/api/admin-label-user`, {
        method:'POST', headers: { 'Content-Type':'application/json', ...headers },
        body: JSON.stringify({ uid, label })
      });
      saveMsg.textContent = 'Saved';
    } catch { saveMsg.textContent = 'Error'; }
  }

  loadBtn.onclick = loadData;
  applyBtn.onclick = loadData;
  clearBtn.onclick = ()=>{ fromEl.value=''; loadData(); };
  saveBtn.onclick = saveLabel;
  copyBtn.onclick = copyLinkToClipboard;
  [uidEl, limitEl, fromEl, toEl, smoothEl, ...passEls].forEach(el => el.addEventListener('change', updateCsvHref));

  updateCsvHref();
  if (uidEl.value) loadData();
})();
</script>
</body>
</html>
</file>

<file path="admin/overview.html">
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Cohort Overview (admin)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <style>
    body { font-family: system-ui, sans-serif; padding: 16px; }
    h1 { margin: 0 0 14px; }
    .nav { display:flex; gap:10px; margin-bottom:10px; }
    .bar { display:flex; gap:10px; flex-wrap:wrap; margin-bottom:12px; }
    table { border-collapse:collapse; width:100%; margin-top:12px; font-size:13px; }
    th,td { border:1px solid #e7e7e7; padding:8px; }
    th { background:#f7f9fc; }
    .spark { width:100px; height:26px; }
  </style>
</head>
<body>
  <nav class="nav">
    <a href="/admin/overview.html" style="font-weight:bold">Cohort</a>
    <a href="/admin/user.html">Attempts</a>
    <a href="/admin/index.html">User Progress</a>
  </nav>

  <h1>Cohort Overview</h1>

  <div class="bar">
    <label>Quick range <select id="quick"><option value="14">14 days</option><option value="30">30 days</option></select></label>
    <button id="reload">Reload</button>
  </div>

  <table id="grid">
    <thead><tr><th>User</th><th>Attempts</th><th>Avg Pron</th><th>Last Seen</th><th>Trend</th></tr></thead>
    <tbody></tbody>
  </table>

<script>
const API_BASE = "";
  const TOKEN = sessionStorage.getItem('lux_admin_token');
  
  async function loadCohort() {
    const days = document.getElementById('quick').value;
    const to = new Date();
    const from = new Date(); from.setDate(from.getDate() - days);
    
    // We fetch a larger list to aggregate locally
    const url = `${API_BASE}/api/admin-recent?limit=2000&from=${from.toISOString().slice(0,10)}`;
    const res = await fetch(url, { headers: { 'x-admin-token': TOKEN } });
    if (!res.ok) return alert('Load failed');
    const json = await res.json();
    
    // Simple Aggregation
    const map = new Map();
    json.rows.forEach(r => {
        if(!map.has(r.uid)) map.set(r.uid, { uid: r.uid, label: r.label, attempts:0, sum:0, scores:[], last: r.ts });
        const entry = map.get(r.uid);
        entry.attempts++;
        if(r.summary?.pron) {
            entry.sum += Number(r.summary.pron);
            entry.scores.push(Number(r.summary.pron));
        }
    });

    const tbody = document.querySelector('#grid tbody');
    tbody.innerHTML = '';
    
    for(const u of map.values()) {
        const avg = u.scores.length ? (u.sum / u.scores.length).toFixed(1) : '-';
        const tr = document.createElement('tr');
        tr.innerHTML = `
            <td><a href="/admin/index.html?uid=${u.uid}">${u.label || u.uid}</a></td>
            <td>${u.attempts}</td>
            <td>${avg}</td>
            <td>${new Date(u.last).toLocaleString()}</td>
            <td><canvas class="spark" width="100" height="26"></canvas></td>
        `;
        tbody.appendChild(tr);
        
        // Sparkline
        if(u.scores.length > 1) {
            new Chart(tr.querySelector('canvas'), {
                type: 'line',
                data: { labels: u.scores.map((_,i)=>i), datasets: [{ data: u.scores.reverse(), borderColor: 'blue', borderWidth: 1, pointRadius: 0 }] },
                options: { responsive: false, plugins: { legend: {display:false} }, scales: { x:{display:false}, y:{display:false} } }
            });
        }
    }
  }

  document.getElementById('reload').onclick = loadCohort;
  if(TOKEN) loadCohort();
  else {
      const t = prompt('Admin Token');
      if(t) { sessionStorage.setItem('lux_admin_token', t); location.reload(); }
  }
</script>
</body>
</html>
</file>

<file path="admin/user.html">
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Attempts (admin)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { font-family: system-ui, -apple-system, sans-serif; margin: 14px; color:#222; }
    h1 { font-size: 1.4rem; margin: 0 0 12px; }
    .row { display:flex; gap:12px; flex-wrap:wrap; align-items:center; }
    .row > * { margin: 4px 0; }
    input, button { padding:6px 10px; border:1px solid #ccc; border-radius:6px; }
    button { background:#0a66ff; color:#fff; border:0; cursor:pointer; }
    table { width:100%; border-collapse:collapse; margin-top:10px; }
    th, td { border:1px solid #ddd; padding:8px; font-size:13px; }
    th { background:#f5f7fa; text-align:left; }
    .nav { display:flex; gap:10px; margin-bottom:8px; }
    .nav-link { padding:2px 6px; text-decoration:none; color:inherit; }
    .nav-link.active { font-weight:600; text-decoration:underline; }
  </style>
</head>
<body>
  <nav class="nav">
    <a href="/admin/overview.html" class="nav-link">Cohort</a>
    <a href="/admin/user.html" class="nav-link active">Attempts</a>
    <a href="/admin/index.html" class="nav-link">User Progress</a>
  </nav>

  <h1>Attempts (admin)</h1>

  <div class="row">
    <label>UID <input id="uidFilter" type="text" placeholder="uid..."></label>
    <label>Limit <input id="limit" type="number" value="200" style="width:60px"></label>
    <button id="reloadBtn">Reload</button>
    <span>Rows: <strong id="count">0</strong></span>
  </div>

  <table>
    <thead><tr><th>Time</th><th>User</th><th>Passage</th><th>Score</th><th>Text</th></tr></thead>
    <tbody id="rows"></tbody>
  </table>

<script>
const API_BASE = "";
  const TOKEN = sessionStorage.getItem('lux_admin_token');
  const headers = TOKEN ? { 'x-admin-token': TOKEN } : {};

  async function loadAttempts() {
    const uid = document.getElementById('uidFilter').value;
    const limit = document.getElementById('limit').value;
    const res = await fetch(`${API_BASE}/api/admin-recent?limit=${limit}&uid=${uid}`, { headers });
    if (!res.ok) return alert('Failed');
    const json = await res.json();
    const rows = json.rows || [];
    
    document.getElementById('count').textContent = rows.length;
    document.getElementById('rows').innerHTML = rows.map(r => `
      <tr>
        <td>${new Date(r.ts).toLocaleString()}</td>
        <td>${r.label || r.uid}</td>
        <td>${r.passage_key}</td>
        <td>${r.summary?.pron || '-'}</td>
        <td>${r.text}</td>
      </tr>
    `).join('');
  }

  document.getElementById('reloadBtn').onclick = loadAttempts;
  if (TOKEN) loadAttempts();
  else {
    const t = prompt('Admin Token');
    if(t) { sessionStorage.setItem('lux_admin_token', t); location.reload(); }
  }
</script>
</body>
</html>
</file>

<file path="api/ai.js">
// api/ai.js
// GPT coaching fetcher

import { API_BASE, dbg, jsonOrThrow } from "./util.js";

const FEEDBACK_URL = `${API_BASE}/api/pronunciation-gpt`;

/**
 * Get GPT-powered coaching sections.
 * Now supports 'chunk' to fetch partial reports and 'persona' for tone.
 * Also supports QuickTips paging + optional history injection.
 * @param {{
 * referenceText: string,
 * azureResult: any,
 * firstLang?: string,
 * mode?: "simple"|"detailed",
 * chunk?: number,
 * persona?: "tutor"|"drill"|"linguist",
 * uid?: string,
 * attemptId?: number|null,
 * tipIndex?: number,
 * tipCount?: number,
 * includeHistory?: boolean|undefined
 * }} params
 */
export async function fetchAIFeedback({
  referenceText,
  azureResult,
  firstLang = "universal",
  mode = "detailed",
  chunk = 1,
  persona = "tutor", // <--- Default to Tutor

  // NEW
  uid = window.LUX_USER_ID || "",
  attemptId = window.lastAttemptId || null,
  tipIndex = 0,
  tipCount = 3,
  includeHistory = undefined
}) {
  // Add new fields to payload so backend can do model selection + tip paging + optional history
  const payload = {
    referenceText,
    azureResult,
    firstLang,
    mode,
    chunk,
    persona,
    uid,
    attemptId,
    tipIndex,
    tipCount,
    includeHistory
  };

  dbg("POST", FEEDBACK_URL, { firstLang, mode, chunk, persona, uid, attemptId, tipIndex, tipCount, includeHistory });

  const resp = await fetch(FEEDBACK_URL, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(payload),
  });

  return jsonOrThrow(resp);
}
</file>

<file path="api/attempts.js">
// api/attempts.js
// UPDATED: Added updateAttempt() to save AI feedback

import { API_BASE, dbg, jsonOrThrow } from "./util.js";

const ATTEMPT_URL = `${API_BASE}/api/attempt`;
const HISTORY_URL = `${API_BASE}/api/user-recent`;
const UPDATE_URL  = `${API_BASE}/api/update-attempt`; // New!

// Helper: YYYY-MM-DD in the user's local day (best-effort)
function localDayKey(ts) {
  const d = new Date(ts);
  try { return d.toLocaleDateString("en-CA"); } catch (_) {}
  const y = d.getFullYear();
  const m = String(d.getMonth() + 1).padStart(2, "0");
  const da = String(d.getDate()).padStart(2, "0");
  return `${y}-${m}-${da}`;
}

export async function saveAttempt({
  uid,
  passageKey,
  partIndex,
  text,
  azureResult,
  l1,
  sessionId,
  localTime,

  // NEW (optional): allow callers to pass extra summary fields later
  summary,

  // NEW (optional): gated raw Azure storage (only if you set true)
  storeRawAzure
}) {
  const effectiveLocalTime = localTime || new Date().toISOString();

  const pk = String(passageKey || "");
  const modeDefault = pk.startsWith("convo:") ? "convo" : "practice";
  const day = localDayKey(effectiveLocalTime);

  const baseMeta = {
    schema_version: "attempt.v2",
    mode: modeDefault,
    client_local_day: day
  };
  if (l1) baseMeta.l1 = l1;

  const inSummary = summary && typeof summary === "object" ? summary : {};
  const inMeta =
    inSummary.meta && typeof inSummary.meta === "object" ? inSummary.meta : {};

  const outSummary = {
    ...inSummary,
    meta: { ...baseMeta, ...inMeta }
  };

  const body = {
    uid,
    passageKey,
    partIndex,
    text,
    azureResult,
    l1,
    sessionId,
    localTime: effectiveLocalTime,

    // NEW: this is what enables Patch B’s merge on the backend
    summary: outSummary,

    // NEW (optional): only send if explicitly enabled
    ...(storeRawAzure === true ? { storeRawAzure: true } : {})
  };

  dbg("POST", ATTEMPT_URL, { uid, passageKey, partIndex, l1 });

  const resp = await fetch(ATTEMPT_URL, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(body),
  });

  // We need to return the ID so we can update this record later!
  return jsonOrThrow(resp);
}

export async function fetchHistory(uid) {
  if (!uid) throw new Error("fetchHistory: UID is required");

  const url = `${HISTORY_URL}?uid=${encodeURIComponent(uid)}`;
  dbg("GET", url);

  const resp = await fetch(url, {
    method: "GET",
    headers: { "Content-Type": "application/json" }
  });

  const json = await jsonOrThrow(resp);
  return json.rows || [];
}

/**
 * Updates an existing attempt (e.g. to attach AI feedback)
 */
export async function updateAttempt(id, aiFeedbackData) {
  if (!id) {
    console.warn("updateAttempt: No ID provided, cannot save.");
    return;
  }

  const body = {
    id: id,
    ai_feedback: aiFeedbackData
  };

  dbg("POST", UPDATE_URL, body);

  try {
    const resp = await fetch(UPDATE_URL, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body),
    });
    return jsonOrThrow(resp);
  } catch (err) {
    console.error("Failed to update attempt:", err);
    // Don't throw, just log. It's not critical if saving feedback fails.
  }
}
</file>

<file path="api/convo-report.js">
// file: /api/convo-report.js
import { API_BASE, jsonOrThrow } from "./util.js";

const REPORT_URL = `${API_BASE}/api/convo-report`;

export async function convoReport({ uid, sessionId, passageKey }) {
  const resp = await fetch(REPORT_URL, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ uid, sessionId, passageKey }),
  });

  return jsonOrThrow(resp);
}
</file>

<file path="api/convo.js">
// api/convo.js
import { API_BASE, dbg, jsonOrThrow } from "./util.js";

const API_URL = import.meta.env.VITE_API_URL || "";
const CONVO_URL = `${API_URL}${API_BASE}/api/convo-turn`;

function isValidConvoTurn(x) {
  return (
    x &&
    typeof x.assistant === "string" &&
    x.assistant.trim().length > 0 &&
    Array.isArray(x.suggested_replies) &&
    x.suggested_replies.length === 3 &&
    x.suggested_replies.every((s) => typeof s === "string" && s.trim().length > 0)
  );
}

async function postConvoTurn(payload, { signal } = {}) {
  const resp = await fetch(CONVO_URL, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(payload),
    signal,
  });

  return jsonOrThrow(resp);
}

export async function convoTurn({ scenario, knobs, messages }, opts = {}) {
  const payload = { scenario, knobs, messages };
  dbg("POST", CONVO_URL, { scenario: scenario?.id, knobs });

  const timeoutMs = Number(opts.timeoutMs ?? 25000);
  const attempts = Math.max(1, Number(opts.attempts ?? 2));

  let lastErr = null;

  for (let i = 0; i < attempts; i++) {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);

    try {
      const data = await postConvoTurn(payload, { signal: ctrl.signal });

      if (isValidConvoTurn(data)) return data;

      lastErr = new Error(
        "Invalid convo-turn payload (empty assistant or bad suggested_replies)."
      );
    } catch (err) {
      lastErr =
        err && err.name === "AbortError" ? new Error("convo-turn timed out") : err;
    } finally {
      clearTimeout(t);
    }
  }

  throw lastErr || new Error("convo-turn failed");
}
</file>

<file path="api/identity.js">
// api/identity.js
// Single source of truth for User Identity (UID).
// Handles generation, persistence (localStorage), and global exposure.

const KEY = "LUX_USER_ID";
// Legacy key that older code wrote to. We'll migrate + keep in sync for now.
const LEGACY_KEY = "lux_user_id";

function isUUID(u) {
  const s = String(u || "").trim();
  return /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(
    s
  );
}

function makeUUID() {
  if (typeof crypto !== "undefined" && crypto.randomUUID) {
    return crypto.randomUUID();
  }
  // Fallback for older envs
  const s = [];
  const h = "0123456789abcdef";
  for (let i = 0; i < 36; i++) s[i] = h[Math.floor(Math.random() * 16)];
  s[14] = "4";
  s[19] = h[(parseInt(s[19], 16) & 0x3) | 0x8];
  s[8] = s[13] = s[18] = s[23] = "-";
  return s.join("");
}

function looksValid(u) {
  return isUUID(u);
}

/**
 * Initializes the UID.
 * 1. Checks URL param ?uid=...
 * 2. Checks localStorage
 * 3. Checks global window.LUX_USER_ID
 * 4. Generates new if missing.
 * 5. Saves to all stores.
 */
export function ensureUID() {
  if (typeof window === "undefined") return null;

  const qs = new URLSearchParams(location.search);
  const fromQuery = (qs.get("uid") || "").trim();

  let fromKey = "";
  let fromLegacy = "";
  try {
    fromKey = localStorage.getItem(KEY) || "";
    fromLegacy = localStorage.getItem(LEGACY_KEY) || "";
  } catch (_) {}

  // Precedence (strongest → weakest):
  // 1) ?uid= (explicit override)
  // 2) localStorage KEY (canonical persisted)
  // 3) window.LUX_USER_ID (runtime)
  // 4) legacy localStorage key (migration)
  const existingWin = (window.LUX_USER_ID || "").trim();

  const finalUID = looksValid(fromQuery)
    ? fromQuery
    : looksValid(fromKey)
    ? fromKey
    : looksValid(existingWin)
    ? existingWin
    : looksValid(fromLegacy)
    ? fromLegacy
    : makeUUID();

  // Persist
  window.LUX_USER_ID = finalUID;
  try {
    localStorage.setItem(KEY, finalUID);
    // Keep legacy in sync temporarily (so any straggler code still sees the same UID).
    localStorage.setItem(LEGACY_KEY, finalUID);
  } catch (_) {}

  // Set attribute for CSS/DOM queries
  document.documentElement.setAttribute("data-uid", finalUID);

  return finalUID;
}

/**
 * Passive getter. Returns currently active UID or null.
 */
export function getUID() {
  if (typeof window !== "undefined" && window.LUX_USER_ID) {
    return window.LUX_USER_ID;
  }
  return ensureUID(); // lazy init if needed
}
</file>

<file path="api/index.js">
// api/index.js
// The Public API Gatekeeper

export { assessPronunciation } from "./assess.js";
export { fetchAIFeedback } from "./ai.js";

// ✅ THE FIX: Export *everything* from attempts.js
// This automatically includes saveAttempt, fetchHistory, AND updateAttempt
export * from "./attempts.js"; 

export { getUID, ensureUID } from "./identity.js";
export { API_BASE, dbg } from "./util.js";
</file>

<file path="api/util.js">
// api/util.js
const PROD_API = "https://luxury-language-api.vercel.app";

export const API_BASE = (() => {
  const API_BASE = globalThis.API_BASE || import.meta.env.VITE_API_BASE || PROD_API;
  return API_BASE;
})();

export function dbg(...args) {
  if (globalThis?.__DEBUG_AI === true) console.log("[AI]", ...args);
}

export async function jsonOrThrow(resp) {
  const text = await resp.text();
  let data = null;
  try {
    data = text ? JSON.parse(text) : null;
  } catch {
    const snippet = text?.slice(0, 200) || "(empty)";
    const err = new Error(`Bad JSON (${resp.status}): ${snippet}`);
    err.status = resp.status;
    throw err;
  }
  if (!resp.ok) {
    const msg =
      (data && (data.error || data.message)) ||
      resp.statusText ||
      "Request failed";
    const err = new Error(msg);
    err.status = resp.status;
    err.body = data;
    throw err;
  }
  return data;
}
</file>

<file path="api/wix.js">
// api/wix.js
import { dbg, jsonOrThrow } from "./util.js";

// feature flag (matches original behavior)
export const ENABLE_WIX_SAVE = false;

function isProdHost() {
  try {
    return location.hostname.endsWith("luxurylanguagelearninglab.com");
  } catch {
    return false;
  }
}

function wixFunctionsBase() {
  const host = (typeof location !== "undefined" && location.hostname) || "";
  return host.includes("wix-editor")
    ? "https://www.luxurylanguagelearninglab.com/_functions-dev"
    : "https://www.luxurylanguagelearninglab.com/_functions";
}

export async function savePronunciationResult({
  userId = null,
  passageKey,
  partIndex,
  text,
  azureResult,
}) {
  const url = `${wixFunctionsBase()}/pronunciationResults`;

  if (!(ENABLE_WIX_SAVE && isProdHost())) {
    console.info("Skipping Wix save (disabled or not on prod host).");
    return { skipped: true };
  }

  const body = { userId, passageKey, partIndex, text, azureResult };
  dbg("POST", url, { passageKey, partIndex });
  const resp = await fetch(url, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(body),
  });
  return jsonOrThrow(resp);
}

export function saveToWix(payload) {
  return savePronunciationResult(payload);
}

export function canSaveToWix() {
  return ENABLE_WIX_SAVE && isProdHost();
}
</file>

<file path="app-core/audio-sink.js">
// app-core/audio-sink.js
// Handles the hidden learner audio element.
// UPDATED: Simplified. Passes Blob directly to Waveform Logic (no manual decoding).

import { loadLearnerBlob } from "../features/features/selfpb/waveform-logic.js"; 

export function initAudioSink() {
  const AUDIO_ID = "playbackAudio";
  const FN = "__attachLearnerBlob";

  const audio = document.getElementById(AUDIO_ID) || (() => {
    const a = document.createElement("audio");
    a.id = AUDIO_ID;
    a.hidden = true;
    document.body.appendChild(a);
    return a;
  })();

  if (audio.__sinkV7) return; 
  audio.__sinkV7 = true;
  audio.preload = "auto";

  const safeLoad = async (url, blob) => {
    try {
      audio.pause();
      audio.src = url;
      audio.load();

      // 1. Dispatch legacy event
      document.dispatchEvent(new CustomEvent("lux:new-learner-audio", { detail: { blob, url } }));

      // 2. Pass Blob to WaveSurfer (Simple!)
      if (blob && loadLearnerBlob) {
          loadLearnerBlob(blob);
      }

      if (window.LuxSelfPB?.setLearnerArrayBuffer) {
        const arr = await blob.arrayBuffer();
        await window.LuxSelfPB.setLearnerArrayBuffer(arr);
      }
    } catch (err) {
      console.warn("[learner] Audio load error:", err);
    }
  };

  window[FN] = function attachLearnerBlob(blob) {
    if (!(blob instanceof Blob)) return;
    if (audio.__blobUrl) URL.revokeObjectURL(audio.__blobUrl);
    const url = URL.createObjectURL(blob);
    audio.__blobUrl = url; 
    safeLoad(url, blob);
  };
  
  console.log("[LUX] Audio Sink initialized");
}
</file>

<file path="app-core/lux-utils.js">
// app-core/lux-utils.js

const PREFIX = "[LUX]";

export function logStatus(message, data) {
  if (data !== undefined) {
    console.log(`${PREFIX} ${message}`, data);
  } else {
    console.log(`${PREFIX} ${message}`);
  }
}

export function logError(message, detail) {
  if (detail !== undefined) {
    console.error(`${PREFIX} error: ${message}`, detail);
  } else {
    console.error(`${PREFIX} error: ${message}`);
  }
}

export function debug(message, data) {
  if (data !== undefined) {
    console.debug(`${PREFIX} ${message}`, data);
  } else {
    console.debug(`${PREFIX} ${message}`);
  }
}

// Lightweight DOM helpers (only used by recording-related code)
export function qs(selector) {
  return document.querySelector(selector);
}

export function setText(el, text) {
  if (!el) return;
  el.textContent = text;
}

export function setVisible(el, show) {
  if (!el) return;
  el.style.display = show ? "" : "none";
}
</file>

<file path="app-core/phones-normalize.js">
// app-core/phones-normalize.js
export function normalizeAssessmentPhonesInPlace(res) {
  const nbest = Array.isArray(res?.NBest) ? res.NBest : [];
  for (const nb of nbest) {
    const words = Array.isArray(nb.Words) ? nb.Words : [];
    for (const w of words) {
      if (!Array.isArray(w.Phonemes)) continue;
      const src = w.Phonemes;
      const out = [];
      for (let i = 0; i < src.length; i++) {
        const cur = src[i]?.Phoneme;
        const nxt = src[i + 1]?.Phoneme;
        const score = (j) => src[j]?.AccuracyScore ?? 100;
        const err = (j) => src[j]?.ErrorType;

        if (cur === "ax" && nxt === "r") {
          out.push({
            Phoneme: "axr",
            AccuracyScore: Math.min(score(i), score(i + 1)),
            ErrorType: err(i) || err(i + 1),
          });
          i++;
          continue;
        }
        if (cur === "er" && nxt === "r") {
          out.push({
            Phoneme: "er",
            AccuracyScore: Math.min(score(i), score(i + 1)),
            ErrorType: err(i) || err(i + 1),
          });
          i++;
          continue;
        }
        if ((cur === "ah" || cur === "uh") && nxt === "r") {
          out.push({
            Phoneme: "er",
            AccuracyScore: Math.min(score(i), score(i + 1)),
            ErrorType: err(i) || err(i + 1),
          });
          i++;
          continue;
        }
        out.push(src[i]);
      }
      w.Phonemes = out;
    }
  }
}
</file>

<file path="app-core/state.js">
// app-core/state.js
import { passages } from "../src/data/index.js";

// --- global debug hook (browser only)
if (typeof window !== "undefined") {
  const qs = new URLSearchParams(window.location.search);
  const flag =
    qs.has("luxdebug") || window.localStorage.getItem("luxdebug") === "1";

  // default OFF; only enable in dev *and* when opted-in
  window.LUX_DEBUG = !!(import.meta?.env?.DEV && flag);

  window.luxDbg = function (label, extra) {
    if (!window.LUX_DEBUG) return;
    const ts = new Date().toISOString().split("T")[1].slice(0, 8);
    console.log(`[LUX ${ts}] ${label}`, extra ?? "");
  };
}


const dbg = (label, extra) =>
  typeof window !== "undefined" &&
  typeof window.luxDbg === "function" &&
  window.luxDbg(label, extra);

const IS_PROD =
  typeof location !== "undefined" &&
  /luxurylanguagelearninglab\.com$/.test(location.hostname);

export const DEFAULT_PASSAGE = "custom"; 

// ---- Mutables (single source of truth)
export let currentPassageKey = DEFAULT_PASSAGE;

export let currentParts = (currentPassageKey === "custom") 
  ? [""] 
  : (passages[currentPassageKey]?.parts || []);

export let currentPartIdx = 0;
export let allPartsResults = []; // <--- The Source of Truth
export let playbackUrl = null;

export let isCustom = (currentPassageKey === "custom");

// ---- Session State
let _sessionId = null;

// Small helpers
export const $ = (sel, r = document) => r.querySelector(sel);
export const $$ = (sel, r = document) => Array.from(r.querySelectorAll(sel));

export function setCustom(v) {
  isCustom = !!v;
  dbg("state:setCustom", { isCustom });
}
export function setPassageKey(k) {
  currentPassageKey = k;
  dbg("state:setPassageKey", { currentPassageKey });
}
export function setParts(p) {
  currentParts = p || [];
  dbg("state:setParts", { partsLen: currentParts.length });
}
export function setPartIdx(i) {
  currentPartIdx = i | 0;
  dbg("state:setPartIdx", { currentPartIdx });
}
export function setAllPartsResults(arr) {
  allPartsResults = Array.isArray(arr) ? arr : [];
  dbg("state:setAllPartsResults", { resultsLen: allPartsResults.length });
}
export function setPlaybackUrl(u) {
  playbackUrl = u || null;
  dbg("state:setPlaybackUrl", { playbackUrl });
}

// --- NEW: Atomic State Updates (Cleaner than manual array manipulation) ---
export function pushPartResult(idx, result) {
  allPartsResults[idx] = result;
  dbg("state:pushPartResult", { idx, score: result?.NBest?.[0]?.AccuracyScore });
}

export function resetSessionResults() {
  allPartsResults = [];
  dbg("state:resetSessionResults", "cleared");
}

export function getChosenLang() {
  const l1Select = $("#l1Select");
  const v = (l1Select?.value || "").trim();
  const lang = v === "" ? "universal" : v;
  return lang;
}

export function getSessionId() {
  if (!_sessionId) {
    _sessionId = Math.random().toString(36).substring(2, 15) + 
                 Math.random().toString(36).substring(2, 15);
  }
  return _sessionId;
}

export function nukeSWInDev() {
  if (!IS_PROD && typeof navigator !== "undefined" && "serviceWorker" in navigator) {
    navigator.serviceWorker.getRegistrations?.().then((rs) => rs.forEach((r) => r.unregister())).catch(() => {});
    dbg("state:nukeSWInDev", "Service workers unregistered");
  }
}
</file>

<file path="core/prosody/index.js">
/* ============================================================================
   CANONICAL PROSODY GATEWAY — ES MODULES (MODERN)
   ---------------------------------------------------------------------------
   - Aggregates the modernized prosody modules.
   - Consumers (like ui/views/rows.js) import from here.
============================================================================ */

export { computeTimings, median } from "../../prosody/core-calc.js";
export { classifyTempo, classifyGap } from "../../prosody/annotate.js";
export { renderProsodyRibbon } from "../../prosody/prosody-render-bars.js";
</file>

<file path="core/scoring/index.js">
// core/scoring/index.js
/* ============================================================================
   core/scoring/index.js — Canonical Scoring Gateway
   STATUS: LOCKED to Universal Blue/Yellow/Red Schema (80/60)
============================================================================ */

export const fmtPct = (v) => {
  if (v == null || !Number.isFinite(+v)) return "–";
  const n = +v;
  return Number.isInteger(n) ? `${n}%` : `${n.toFixed(1)}%`;
};

// SCORING CONSTITUTION:
// >= 80: Blue (Good)
// >= 60: Yellow (Warn)
// < 60:  Red (Bad)
export const scoreClass = (s) =>
  s == null
    ? ""
    : s >= 80
    ? "score-good"
    : s >= 60
    ? "score-warn"
    : "score-bad";

export function getAzureScores(data) {
  const nbest = data?.NBest?.[0] || {};
  const pa =
    nbest?.PronunciationAssessment || data?.PronunciationAssessment || {};
  const ca = nbest?.ContentAssessment || data?.ContentAssessment || {};

  const num = (v) => (Number.isFinite(+v) ? +v : null);

  return {
    accuracy: num(nbest?.AccuracyScore ?? pa?.AccuracyScore),
    fluency: num(nbest?.FluencyScore ?? pa?.FluencyScore),
    completeness: num(nbest?.CompletenessScore ?? pa?.CompletenessScore),
    overall: num(
      nbest?.PronScore ?? pa?.PronunciationScore ?? pa?.PronScore
    ),
    prosody: num(
      nbest?.ProsodyScore ??
        pa?.ProsodyScore ??
        data?.ProsodyScore ??
        data?.PronunciationAssessment?.ProsodyScore
    ),
    content: {
      vocab: num(ca?.vocabularyScore ?? ca?.VocabularyScore),
      grammar: num(ca?.grammarScore ?? ca?.GrammarScore),
      topic: num(ca?.topicScore ?? ca?.TopicScore),
    },
    nbest,
  };
}

export function deriveFallbackScores(data) {
  const nbest = data?.NBest?.[0] || {};
  const words = nbest?.Words || [];

  const toNum = (x) => (Number.isFinite(+x) ? +x : null);
  const avg = (arr) =>
    arr.length ? arr.reduce((a, b) => a + b, 0) / arr.length : null;

  const accs = words
    .map((w) => toNum(w?.AccuracyScore))
    .filter(Number.isFinite);

  const accAvg = avg(accs);

  const okCount = words.filter(
    (w) => !w?.ErrorType || w.ErrorType === "None"
  ).length;

  const completenessFallback = words.length
    ? Math.round((okCount / words.length) * 100)
    : null;

  const pa =
    nbest?.PronunciationAssessment || data?.PronunciationAssessment || {};

  const overallFallback =
    toNum(nbest?.PronScore ?? pa?.PronunciationScore ?? pa?.PronScore) ??
    (accAvg != null ? Math.round(accAvg) : null);

  const getSpeakingRate =
    globalThis.getSpeakingRate ||
    function () {
      return { label: "" };
    };

  const rate = getSpeakingRate(data);

  // Updated fallback logic to match new 80/60 threshold
  const fluFallback = rate.label ? (rate.label === "ok" ? 85 : 65) : null;

  return {
    accuracy: accAvg != null ? Math.round(accAvg) : null,
    completeness: completenessFallback,
    overall: overallFallback,
    fluency: fluFallback,
    rate,
  };
}

export default scoreClass;
</file>

<file path="features/balloon/balloon.css">
/* features/balloon/balloon.css */

/* Enable smooth animation of CSS variables (Chromium/Safari). */
@property --scale {
  syntax: "<number>";
  inherits: true;
  initial-value: 1;
}

@property --balloonL {
  syntax: "<percentage>";
  inherits: true;
  initial-value: 25%;
}

@property --inflateDur {
  syntax: "<time>";
  inherits: true;
  initial-value: 0.9s;
}

/* Container: Drifts BROADLY across the screen */
#lux-balloon-wrapper {
  position: fixed;
  bottom: 40px; 
  right: 40px;
  width: 100px;
  height: 180px; 
  z-index: 9999;
  pointer-events: none;
  
  /* CHAOTIC FLOAT: Prime numbers (7s, 5s) prevent sync */
  animation: 
    wanderX 7s ease-in-out infinite alternate,
    wanderY 5s ease-in-out infinite alternate;
  
  transition: bottom var(--inflateDur) ease;
}

/* --- The Balloon (Outer = SCALE / inflate) --- */
#lux-balloon {
  --scale: 1;
  --scale-prev: 1;
  --inflateDur: 0.9s;

  width: 50px;
  height: 62px;

  pointer-events: auto;

  /* CURSOR: Tack 📌 */
  cursor: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='32' height='32' style='font-size:24px'><text y='24'>📌</text></svg>") 0 20, pointer;

  position: absolute;
  top: 20%;
  left: 50%;
  margin-left: -25px;
  margin-top: -31px;

  transform: scale(var(--scale));
  will-change: transform;
}

/* One-shot “inflate” each step */
#lux-balloon.lux-balloon-inflating {
  animation: inflateBounce var(--inflateDur) cubic-bezier(0.34, 1.56, 0.64, 1) 1;
}

/* Inner = VISUALS + wobble rotate (no scaling here) */
#lux-balloon-core {
  width: 100%;
  height: 100%;
  border-radius: 50% 50% 50% 50% / 40% 40% 60% 60%;

  /* 3D Shading */
  background: radial-gradient(circle at 35% 35%,
              rgba(255,255,255,0.8) 0%,
              rgba(255,255,255,0.2) 20%,
              transparent 50%);

  box-shadow:
    inset -5px -5px 15px rgba(0,0,0,0.4),
    inset 2px 2px 5px rgba(255,255,255,0.4),
    2px 8px 15px rgba(0,0,0,0.3);

  position: relative;

  /* Wobble lives here now */
  transform-origin: 50% 80%;
  animation: balloonWobble 6s ease-in-out infinite alternate;

  /* Smooth color shifts */
  transition: background-color 0.9s ease-in-out;
}

/* Shine */
#lux-balloon-core::before {
  content: "";
  position: absolute;
  top: 15%;
  left: 20%;
  width: 12px;
  height: 20px;
  border-radius: 50%;
  background: rgba(255,255,255,0.7);
  transform: rotate(-45deg);
  filter: blur(1px);
}

/* --- THE STRING (Randomized & White) --- */
#lux-balloon-core::after {
  content: "";
  position: absolute;
  top: 96%; /* Attached to bottom */
  left: 50%; /* Center */
  
  width: 25px; /* Width accommodates curve */
  height: 65px; /* Long tail */
  
  /* COLOR FIX: Pure White + Crisp Shadow (No Brown) */
  border-left: 2px solid #ffffff;
  filter: drop-shadow(1px 1px 1px rgba(0,0,0,0.3));
  
  /* PHYSICS: Anchor Top-Left (Base of Balloon) */
  transform-origin: top left; 
  
  /* TWO LAYERS OF CHAOS */
  animation: 
    stringSway 3.1s ease-in-out infinite alternate,
    stringCurl 2.3s ease-in-out infinite alternate-reverse;
}


/* --- ANIMATION KEYFRAMES --- */

/* Balloon Wobble: MUST INCLUDE SCALE VARIABLE */
@keyframes balloonWobble {
  0% { transform: rotate(-3deg); }
  100% { transform: rotate(3deg); }
}

@keyframes inflateBounce {
  0% {
    transform: scale(var(--scale-prev));
  }
  45% {
    /* slight vertical “pressurize” stretch */
    transform: scaleX(calc(var(--scale) * 0.985)) scaleY(calc(var(--scale) * 1.045));
  }
  75% {
    /* a touch of overshoot */
    transform: scaleX(calc(var(--scale) * 1.06)) scaleY(calc(var(--scale) * 0.995));
  }
  100% {
    transform: scale(var(--scale));
  }
}

/* Drastic Side-to-Side (80px Range) */
@keyframes wanderX {
  0% { transform: translateX(-40px); } 
  100% { transform: translateX(40px); }
}

/* Up/Down (Vertical Drift) */
@keyframes wanderY {
  0% { transform: translateY(0px); }
  100% { transform: translateY(-30px); }
}

/* String Sway (Pendulum) */
@keyframes stringSway {
  0% { transform: rotate(10deg); }
  100% { transform: rotate(-10deg); }
}

/* String Curl (Shape Morpher) */
@keyframes stringCurl {
  0% { border-bottom-left-radius: 0%; }   /* Straight */
  50% { border-bottom-left-radius: 40%; } /* Slight Hook */
  100% { border-bottom-left-radius: 80%; } /* Deep Hook */
}


/* --- Tooltip --- */
#lux-balloon-tip {
  position: absolute;
  right: 130%; /* Push further left */
  top: 30%;
  background: #1e293b;
  color: #fff;
  padding: 6px 12px;
  border-radius: 8px;
  font-size: 13px;
  font-weight: 700;
  white-space: nowrap;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.2s, transform 0.2s;
  box-shadow: 0 4px 12px rgba(0,0,0,0.2);
}
#lux-balloon:hover + #lux-balloon-tip {
  opacity: 1;
  transform: translateX(-5px);
}

/* --- CONFETTI --- */
.lux-confetti {
  position: absolute;
  width: 8px;
  height: 8px;
  top: 30%; 
  left: 50%;
  opacity: 1;
  pointer-events: none;
  border-radius: 2px;
}

@keyframes confettiFall {
  0% { 
    transform: translate(0,0) rotate(0deg); 
    opacity: 1; 
    animation-timing-function: cubic-bezier(0.25, 0.1, 0.25, 1);
  }
  35% { 
    transform: translate(var(--x-mid), var(--y-up)) rotate(180deg); 
    opacity: 1;
    animation-timing-function: cubic-bezier(0.42, 0, 1, 1);
  }
  100% { 
    transform: translate(var(--x-end), 300px) rotate(720deg); 
    opacity: 0; 
  }
}
</file>

<file path="features/balloon/index.js">
// features/balloon/index.js
import { updateVisuals, popAnimation } from "./ui.js";

export function updateBalloon(count, max) {
  updateVisuals(count, max);
}

export function popBalloon() {
  popAnimation();
}
</file>

<file path="features/balloon/ui.js">
// features/balloon/ui.js
// Handles DOM creation, visual updates, and the "Confetti Pop" physics.

let wrapper = null;
let balloon = null;
let core = null;
let tip = null;

function ensureDOM() {
  if (wrapper) return;
  
  if (!document.querySelector('link[href*="balloon.css"]')) {
    const link = document.createElement("link");
    link.rel = "stylesheet";
    link.href = "./features/balloon/balloon.css";
    document.head.appendChild(link);
  }

  wrapper = document.createElement("div");
  wrapper.id = "lux-balloon-wrapper";
  
  balloon = document.createElement("div");
  balloon.id = "lux-balloon";
  balloon.title = "Click to Pop!";
  balloon.addEventListener("click", popAnimation);

  core = document.createElement("div");
  core.id = "lux-balloon-core";
  balloon.appendChild(core);
  
  tip = document.createElement("div");
  tip.id = "lux-balloon-tip";
  
  wrapper.appendChild(balloon);
  wrapper.appendChild(tip); 
  document.body.appendChild(wrapper);
}

export function updateVisuals(count, max) {
  ensureDOM();
  
  wrapper.style.display = "block";

  const safeMax = max || 1; 
  const ratio = Math.min(Math.max(count, 0) / safeMax, 1.0);

  // Swell: 1.0 -> 2.2
  const nextScale = 1.0 + (ratio * 1.2);

  // Compute delta so bigger jumps inflate slower
  const curScale = parseFloat(getComputedStyle(balloon).getPropertyValue("--scale")) || 1.0;
  const delta = Math.abs(nextScale - curScale);
  const durBase = Math.min(1.4, Math.max(0.65, 0.55 + delta * 0.9));
  const dur = Math.min(1.8, durBase * 1.3); // slower, capped
  const durStr = `${dur.toFixed(2)}s`;

  // Set previous + next scale for the inflate keyframes
  balloon.style.setProperty("--inflateDur", durStr);
  balloon.style.setProperty("--scale-prev", curScale.toFixed(3));
  balloon.style.setProperty("--scale", nextScale.toFixed(3));

  // Retrigger the one-shot inflate animation each step
  balloon.classList.remove("lux-balloon-inflating");
  void balloon.offsetWidth; // force reflow
  balloon.classList.add("lux-balloon-inflating");

  // Lift: keep string visible (match duration)
  wrapper.style.transitionDuration = durStr;
  const lift = 40 + (ratio * 60);
  wrapper.style.bottom = `${lift}px`;

  // Color: Crimson -> Bright Red (apply to the CORE; match duration)
  if (core) core.style.transitionDuration = durStr;
  const lightness = 25 + (ratio * 35);
  if (core) core.style.backgroundColor = `hsl(0, 90%, ${lightness}%)`;

  // Tooltip
  if (ratio >= 1) {
    tip.textContent = "Full! Click to Pop 📌";
  } else {
    const isCustom = max === 15; 
    tip.textContent = isCustom 
      ? `${count}/${max} parts` 
      : `Part ${count + 1} of ${max}`;
  }
}

export function popAnimation() {
  if (!balloon || !wrapper) return;

  balloon.classList.remove("lux-balloon-inflating");

  // 1. Vanish Balloon
  balloon.style.transition = "transform 0.05s";
  balloon.style.transform = "scale(1.5)"; 
  setTimeout(() => {
    balloon.style.opacity = "0";
    if(tip) tip.style.opacity = "0";
  }, 50);

  // 2. Spawn Confetti with "Arc" variables
  const colors = ['#ef4444', '#3b82f6', '#10b981', '#f59e0b', '#8b5cf6'];
  
  for (let i = 0; i < 50; i++) {
    const p = document.createElement("div");
    p.className = "lux-confetti";
    
    // Random spread
    const spread = (Math.random() - 0.5) * 300; 
    
    // Set 3 points for the arc
    p.style.setProperty('--x-mid', (spread * 0.5) + "px");
    p.style.setProperty('--x-end', spread + "px");
    
    // Upward force
    const yUp = -(80 + Math.random() * 150) + "px";
    p.style.setProperty('--y-up', yUp);
    
    p.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
    
    const dur = 1.0 + Math.random() * 0.8;
    p.style.animation = `confettiFall ${dur}s forwards`;
    
    wrapper.appendChild(p);
  }

  // 3. Remove DOM
  setTimeout(() => {
    if(wrapper) wrapper.remove();
    wrapper = null;
    balloon = null;
    core = null;
    tip = null;
  }, 2500);
}
</file>

<file path="features/convo/convo-api.js">
// features/convo/convo-api.js
import { convoTurn } from "../../api/convo.js";

// Convo turn with a UI-friendly fallback message (never throw).
export async function convoTurnWithUi(payload, opts = {}) {
  const timeoutMs = opts.timeoutMs ?? 25000;
  const attempts = opts.attempts ?? 2;

  try {
    return await convoTurn(payload, { timeoutMs, attempts });
  } catch (err) {
    return {
      assistant:
        "⚠️ I couldn’t get the next AI turn. " +
        (err?.message ? `(${err.message}) ` : "") +
        "Press Record again to retry.",
      suggested_replies: ["Press Record again", "Try again", "Back to scenarios"],
    };
  }
}
</file>

<file path="features/convo/convo-coach.js">
// features/convo/convo-coach.js

export function createConvoCoach({ state, coachBar, input, el }) {
  function targetsInline(plan) {
    const ph = plan?.targets?.phoneme?.ipa ? `/${plan.targets.phoneme.ipa}/` : "";
    const words = (plan?.targets?.words || []).map((x) => x.word).filter(Boolean).slice(0, 6);
    const w = words.length ? words.join(", ") : "";
    if (ph && w) return `${ph} · ${w}`;
    return ph || w || "";
  }

  function showCoachCard({ title, body, meta, onDismiss }) {
    const card = el("div", "lux-coachcard");
    const left = el("div", "lux-coachtext");
    left.append(el("strong", "", title), el("div", "", body));
    if (meta) left.append(el("div", "lux-coachmeta", meta));
    const btn = el("button", "btn ghost lux-coachbtn", "Got it");
    btn.addEventListener("click", () => {
      card.remove();
      if (onDismiss) onDismiss();
    });
    card.append(left, btn);
    coachBar.append(card);
  }

  function maybeShowStartTip() {
    if (!state.nextActivity) return;
    if (state.coach.startTipShown) return;
    state.coach.startTipShown = true;
    const t = targetsInline(state.nextActivity);
    showCoachCard({
      title: "Targeted practice loaded",
      body:
        "Tip: read BOTH parts out loud. The assistant lines are packed with your focus sound/words. Then click a suggested reply and record it.",
      meta: t ? `Focus: ${t}` : "",
    });
  }

  function noteSuggestionsRendered(list) {
    if (!state.nextActivity) return;
    if (!(list || []).length) return;
    if (state.coach.replyTipShown) return;

    state.coach.replyTipShown = true;
    const t = targetsInline(state.nextActivity);
    showCoachCard({
      title: "Recommended for best results",
      body:
        "This time, please use the suggested replies (at least for a few turns). They’re designed to include the sounds/words you need most.",
      meta: t ? `Targets inside the suggestions: ${t}` : "",
    });
  }

  function wireTypeTip() {
    input.addEventListener("focus", () => {
      if (!state.nextActivity) return;
      if (state.coach.typeTipShown) return;
      state.coach.typeTipShown = true;
      showCoachCard({
        title: "Quick note before typing",
        body:
          "The suggested replies are packed with the exact sounds/words Lux thinks you need most right now. You can still type your own, but you might accidentally skip the targeted practice if you do.",
      });
    });
  }

  return {
    targetsInline,
    showCoachCard,
    maybeShowStartTip,
    noteSuggestionsRendered,
    wireTypeTip,
  };
}
</file>

<file path="features/convo/convo-highlight.js">
// features/convo/convo-highlight.js
import { norm } from "../../src/data/phonemes/core.js";

function escHtml(s) {
  return String(s)
    .replaceAll("&", "&amp;")
    .replaceAll("<", "&lt;")
    .replaceAll(">", "&gt;")
    .replaceAll('"', "&quot;")
    .replaceAll("'", "&#039;");
}

function escapeRegExp(s) {
  return String(s).replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}

// Normalize a token for comparisons (word-bank matching, focus testing).
function normToken(tok) {
  let s = String(tok || "").trim().toLowerCase();
  if (!s) return "";
  s = s.replace(/^[^a-z0-9]+|[^a-z0-9]+$/g, ""); // trim edge punctuation
  s = s.replace(/’/g, "'"); // curly apostrophe
  s = s.replace(/'s$/g, ""); // possessive
  return s;
}

function makeFocusTester(ipa) {
  const k = norm(String(ipa || "").trim());

  // Return a function(word)->boolean, or null if we don't have safe spelling cues.
  if (!k) return null;

  const map = {
    f: /(?:f|ph|gh)/i, // far, flight, phone, laugh
    v: /v/i,
    θ: /th/i, // think
    ð: /th/i, // this
    ʃ: /sh/i, // she
    "tʃ": /(?:ch|tch)/i, // chair, match
    "dʒ": /(?:j|dge|dg)/i, // job, bridge
    ŋ: /ng/i, // sing
    ɹ: /(?:r|wr)/i,
    r: /(?:r|wr)/i,
    l: /l/i,

    // /t/ is tricky, but we need a practical rule so blue can exist.
    // Accept most “t” spellings; avoid very common t→sh/ch patterns + a tiny silent-t denylist.
    t: (word) => {
      const s = normToken(word);
      if (!s) return false;
      if (!s.includes("t")) return false;
      if (/(tion|tial|tious|ture)/i.test(s)) return false; // nation, special, future (often not /t/)
      if (/stle$/i.test(s)) return false; // castle, whistle (t often silent)
      if (/(listen|often)/i.test(s)) return false; // common silent-t words
      return true;
    },
  };

  const rule = map[k];
  if (!rule) return null;
  if (rule instanceof RegExp) return (word) => rule.test(String(word || ""));
  if (typeof rule === "function") return rule;
  return null;
}

export function stripMarks(s) {
  return String(s || "")
    .replace(/\{~([^}]+)~\}/g, "$1")
    .replace(/\{\^([^}]+)\^\}/g, "$1");
}

/**
 * Convert marked convo text to safe HTML.
 *
 * Inputs (passed in via opts; no state coupling):
 * - wordBank: array of strings (target words)
 * - focusIpa: string (e.g. "t", "θ", "tʃ")
 * - autoBlue: boolean (defaults true) — only inject blue when allowed + safe
 */
export function highlightHtml(text, opts = {}) {
  const raw = String(text || "");
  const autoBlue = opts.autoBlue !== false;

  const wb = (opts.wordBank || []).map((w) => String(w || "").trim()).filter(Boolean);
  const wbSet = new Set(wb.map(normToken).filter(Boolean));

  const focusIpa = norm(String(opts.focusIpa || ""));
  const focusTester = focusIpa ? makeFocusTester(focusIpa) : null;

  const dbgOn = localStorage.getItem("lux.debugMarks") === "1";
  const dbg =
    dbgOn && autoBlue
      ? { focusIpa, wbCount: wbSet.size, gotBlue: 0, okBlue: 0, badBlue: 0 }
      : null;

  // Protect explicit marks so fallback word-bank highlighting can’t wrap inside them.
  const stash = [];
  let marked = raw
    .replace(/\{~([^}]+)~\}/g, (_m, w) => {
      const i = stash.length;
      stash.push({ t: "wb", w: String(w) });
      return `\u0001${i}\u0002`;
    })
    .replace(/\{\^([^}]+)\^\}/g, (_m, w) => {
      const i = stash.length;
      stash.push({ t: "ph", w: String(w) });
      return `\u0003${i}\u0004`;
    });

  // Fallback: wrap unmarked word-bank words with {~ ~} (so yellow still appears if the model forgets).
  const tw = [...wb].sort((a, b) => b.length - a.length);
  for (const w of tw) {
    const re = new RegExp(`\\b(${escapeRegExp(w)})\\b`, "gi");
    marked = marked.replace(re, "{~$1~}");
  }

  // Restore protected explicit marks
  marked = marked
    .replace(/\u0001(\d+)\u0002/g, (_m, i) => `{~${stash[Number(i)]?.w ?? ""}~}`)
    .replace(/\u0003(\d+)\u0004/g, (_m, i) => `{^${stash[Number(i)]?.w ?? ""}^}`);

  // AUTO-BLUE FALLBACK:
  // If the model provided zero {^ ^}, inject up to 2 safe focus words.
  // We only do this when we have a conservative focusTester (trust boundary).
  if (autoBlue && focusTester && !/\{\^/.test(marked)) {
    const STOP = new Set([
      "the",
      "a",
      "an",
      "and",
      "or",
      "but",
      "to",
      "of",
      "in",
      "on",
      "for",
      "at",
      "by",
      "with",
      "as",
      "is",
      "are",
      "was",
      "were",
      "be",
      "been",
      "being",
      "i",
      "you",
      "he",
      "she",
      "we",
      "they",
      "it",
      "this",
      "that",
      "these",
      "those",
      "my",
      "your",
      "his",
      "her",
      "our",
      "their",
    ]);

    // Protect existing {~ ~} blocks so we don’t nest marks inside them.
    const prot = [];
    let scan = marked.replace(/\{~([^}]+)~\}/g, (m) => {
      const i = prot.length;
      prot.push(m);
      return `\u0005${i}\u0006`;
    });

    let added = 0;
    scan = scan.replace(/\b[A-Za-z][A-Za-z']*\b/g, (tok) => {
      if (added >= 2) return tok;
      const key = normToken(tok);
      if (!key) return tok;
      if (STOP.has(key)) return tok;
      if (wbSet.has(key)) return tok; // word-bank handled separately (can become double-hit)
      if (!focusTester(key)) return tok;
      added++;
      return `{^${tok}^}`;
    });

    marked = scan.replace(/\u0005(\d+)\u0006/g, (_m, i) => prot[Number(i)] || "");
  }

  // Escape once, then convert marks to spans (no double-escaping).
  let html = escHtml(marked);

  // Only honor {~ ~} if it’s truly in the current word bank.
  html = html.replace(/\{~([^}]+)~\}/g, (_m, w) => {
    const key = normToken(w);
    if (!wbSet.has(key)) return w;

    // Double-hit without requiring the model to mark {^ ^}:
    if (focusTester && focusTester(key)) return `<span class="lux-hl lux-hl2">${w}</span>`;
    return `<span class="lux-hl">${w}</span>`;
  });

  // Blue: validate against focusTester when available. If invalid, strip highlight.
  html = html.replace(/\{\^([^}]+)\^\}/g, (_m, w) => {
    if (dbg) dbg.gotBlue++;
    const key = normToken(w);
    if (focusTester && !focusTester(key)) {
      if (dbg) dbg.badBlue++;
      return w;
    }
    if (dbg) dbg.okBlue++;
    const cls = wbSet.has(key) ? "lux-hl lux-hl2" : "lux-hl2";
    return `<span class="${cls}">${w}</span>`;
  });

  if (dbg) console.debug("[Lux blue marks]", dbg);

  return html;
}
</file>

<file path="features/convo/convo-modes.js">
// features/convo/convo-modes.js

export function createConvoModeController({ root, state, setParallaxEnabled, setKnobs, render }) {
  const VALID_MODES = new Set(["intro", "picker", "chat"]);

  function normalizeMode(m) {
    const s = (m ?? "").toString().replace(/^#/, "");
    return VALID_MODES.has(s) ? s : null;
  }

  function syncHistory(mode, push) {
    try {
      const url = `${location.pathname}${location.search}#${mode}`;
      const st = { luxConvo: 1, mode };
      if (push) history.pushState(st, "", url);
      else history.replaceState(st, "", url);
    } catch (_) {}
  }

  function setMode(mode, opts = {}) {
    const changed = state.mode !== mode;

    state.mode = mode;
    root.dataset.mode = mode;

    // Used by lux-convo.css to gate drawers (TTS + SelfPB) until chat mode.
    document.documentElement.dataset.luxConvoMode = mode;

    // Parallax ONLY on intro screen.
    setParallaxEnabled(mode === "intro");

    // Keep knobs overlay from bleeding into intro/picker.
    if (mode !== "chat") setKnobs(false);

    // honor push:false (and also tolerate legacy opts.opts if it ever existed)
    const allowPush = (opts.push ?? opts.opts) !== false;

    // Browser back/forward steps: intro -> picker -> chat
    if (opts.replace) {
      syncHistory(mode, false);
    } else if (allowPush && changed) {
      syncHistory(mode, true);
    }

    render();
  }

  function wirePopstate({ warpSwap }) {
    window.addEventListener("popstate", (e) => {
      const m = normalizeMode(e.state?.luxConvo ? e.state.mode : location.hash);
      if (!m) return;
      warpSwap(() => setMode(m, { push: false }), { outMs: 140, inMs: 200 });
    });
  }

  return { normalizeMode, setMode, wirePopstate };
}
</file>

<file path="features/convo/convo-shared.js">
// features/convo/convo-shared.js
import { ensureUID } from "../../api/index.js";
import { computeRollups } from "../progress/rollups.js";
import { promptUserForAI } from "../../ui/ui-ai-ai-logic.js";

// --- Deck card sizing: make the CARD match the media's natural aspect ratio ---
const _luxMediaMeta = new Map();

export function applyMediaSizingVars(host, imgSrc) {
  if (!host || !imgSrc) return;

  const cached = _luxMediaMeta.get(imgSrc);
  if (cached) {
    host.style.setProperty("--lux-media-ar", cached.ar);
    host.style.setProperty("--lux-media-h", cached.h);
    return;
  }

  const im = new Image();
  im.onload = () => {
    const ar = `${im.naturalWidth} / ${im.naturalHeight}`;
    const h = `${im.naturalHeight}px`;
    _luxMediaMeta.set(imgSrc, { ar, h });

    host.style.setProperty("--lux-media-ar", ar);
    host.style.setProperty("--lux-media-h", h);
  };
  im.src = imgSrc;
}

export function uid() {
  return ensureUID();
}

export function newSessionId() {
  if (crypto?.randomUUID) return crypto.randomUUID();
  return `sess_${Math.random().toString(16).slice(2)}_${Date.now()}`;
}

export function el(tag, cls, text) {
  const n = document.createElement(tag);
  if (cls) n.className = cls;
  if (text != null) n.textContent = text;
  return n;
}

function escapeHtml(s) {
  return String(s)
    .replaceAll("&", "&amp;")
    .replaceAll("<", "&lt;")
    .replaceAll(">", "&gt;")
    .replaceAll('"', "&quot;")
    .replaceAll("'", "&#039;");
}

function wordSetFromText(text) {
  const s = String(text || "").toLowerCase();
  const out = new Set();
  const m = s.match(/[a-z']+/g) || [];
  for (const w of m) out.add(w);
  return out;
}

function uniqLower(list) {
  const out = [];
  const seen = new Set();
  for (const x of list || []) {
    const k = String(x || "").trim().toLowerCase();
    if (!k || seen.has(k)) continue;
    seen.add(k);
    out.push(String(x).trim());
  }
  return out;
}

function chipRow(items) {
  if (!items || !items.length) return `<div style="opacity:.7">—</div>`;
  return `
    <div style="display:flex; flex-wrap:wrap; gap:8px;">
      ${items
        .map(
          (x) =>
            `<span style="border:1px solid rgba(255,255,255,0.14); border-radius:999px; padding:6px 10px; font-size:12px;">${escapeHtml(
              x
            )}</span>`
        )
        .join("")}
    </div>
  `;
}

function wireCoachTurnList(host, turns) {
  const list = host?.querySelector("#luxConvoCoachTurnList");
  if (!list) return;

  const all = Array.isArray(turns) ? turns : [];
  const shown = all.slice(-10); // keep it compact

  if (!shown.length) {
    list.innerHTML = `<div style="font-size:12px; opacity:0.85;">No turns saved for this session yet.</div>`;
    return;
  }

  list.innerHTML = shown
    .map((t, idx) => {
      const has = !!t?.azureResult?.NBest?.[0];
      const text = String(t?.userText || "").trim();
      const label = text ? (text.length > 90 ? text.slice(0, 90) + "…" : text) : "(no text)";
      const turnNum = Number.isFinite(t?.turn) ? (t.turn + 1) : (all.length - shown.length + idx + 1);

      return `
        <button data-i="${idx}" ${has ? "" : "disabled"} style="
          text-align:left;
          width: 100%;
          appearance:none;
          border: 1px solid rgba(255,255,255,0.10);
          background: ${has ? "rgba(255,255,255,0.06)" : "rgba(255,255,255,0.03)"};
          color: ${has ? "#e5e7eb" : "rgba(229,231,235,0.55)"};
          border-radius: 10px;
          padding: 10px 12px;
          cursor: ${has ? "pointer" : "not-allowed"};
        ">
          <div style="font-weight:800; margin-bottom:4px;">Coach Turn ${turnNum}</div>
          <div style="font-size:12px; opacity:0.9;">${escapeHtml(label)}</div>
        </button>
      `;
    })
    .join("");

  list.querySelectorAll("button[data-i]").forEach((btn) => {
    btn.addEventListener("click", () => {
      const idx = Number(btn.getAttribute("data-i") || -1);
      const t = shown[idx];
      if (!t?.azureResult?.NBest?.[0]) return;

      // Close overlay first so coach panel is visible
      host.remove();

      window.lastAttemptId = t.attemptId || null;
      promptUserForAI(t.azureResult, t.userText || "", "universal");

      document.getElementById("aiFeedbackSection")?.scrollIntoView?.({
        behavior: "smooth",
        block: "start",
      });
    });
  });
}

export function showConvoReportOverlay(report, turns = []) {
  let host = document.getElementById("luxConvoReportOverlay");
  const pretty = escapeHtml(JSON.stringify(report, null, 2));

  const plan = null;
  const targetPh = "";
  const targetWords = [];

  const said = new Set();
  for (const t of turns) {
    const ws = wordSetFromText(t?.userText || "");
    for (const w of ws) said.add(w);
  }
  const saidTargets = targetWords.filter((w) => said.has(w.toLowerCase()));

  // Build attempt-like objects for session-local rollups
  const baseTS = Date.now();
  const attempts = turns.map((t, i) => ({
    ts: baseTS - (turns.length - i) * 1000,
    passage_key: "",
    session_id: "",
    text: t?.userText || "",
    azureResult: t?.azureResult || null,
  }));

  let sessionModel = null;
  try {
    sessionModel = computeRollups(attempts);
  } catch (e) {
    console.error("[ConvoReportOverlay] computeRollups failed", e);
  }

  const troubleWords = sessionModel?.trouble?.wordsAll || [];
  const troublePhonemes = sessionModel?.trouble?.phonemesAll || [];

  // "Targets you said that still need work today"
  const saidTargetsNeedingWork = troubleWords
    .filter((x) => {
      const w = String(x?.word || "").toLowerCase();
      if (!w) return false;
      if (!saidTargets.map((s) => s.toLowerCase()).includes(w)) return false;
      const avg = Number(x?.avg);
      return Number.isFinite(avg) ? avg < 85 : true;
    })
    .slice(0, 10)
    .map((x) => {
      const avg = Number.isFinite(Number(x?.avg)) ? Number(x.avg).toFixed(0) : "—";
      const c = Number.isFinite(Number(x?.count)) ? `×${x.count}` : "";
      return `${x.word} (${avg}${c ? `, ${c}` : ""})`;
    });

  const topTroubleWords = troubleWords
    .slice(0, 12)
    .map((x) => {
      const avg = Number.isFinite(Number(x?.avg)) ? Number(x.avg).toFixed(0) : "—";
      const c = Number.isFinite(Number(x?.count)) ? `×${x.count}` : "";
      return `${x.word} (${avg}${c ? `, ${c}` : ""})`;
    });

  const topTroublePh = troublePhonemes
    .slice(0, 10)
    .map((x) => {
      const avg = Number.isFinite(Number(x?.avg)) ? Number(x.avg).toFixed(0) : "—";
      const c = Number.isFinite(Number(x?.count)) ? `×${x.count}` : "";
      return `${x.ipa} (${avg}${c ? `, ${c}` : ""})`;
    });

  let focusPhLine = "—";
  if (targetPh) {
    const hit = troublePhonemes.find((x) => String(x?.ipa || "") === targetPh);
    if (hit) {
      const avg = Number.isFinite(Number(hit?.avg)) ? Number(hit.avg).toFixed(0) : "—";
      const c = Number.isFinite(Number(hit?.count)) ? `×${hit.count}` : "";
      focusPhLine = `${targetPh} (today: ${avg}${c ? `, ${c}` : ""})`;
    } else {
      focusPhLine = `${targetPh} (today: not enough data)`;
    }
  }

  const headerSub = "";

  if (!host) {
    host = document.createElement("div");
    host.id = "luxConvoReportOverlay";
    host.style.cssText = `
      position: fixed; inset: 0; z-index: 99999;
      background: rgba(0,0,0,0.45);
      display:flex; align-items:center; justify-content:center;
      padding: 18px;
    `;

    host.innerHTML = `
      <dialog open style="
        width: min(880px, 96vw);
        max-height: min(86vh, 920px);
        overflow: hidden;
        border: 1px solid rgba(255,255,255,0.12);
        border-radius: 16px;
        background: rgba(12,12,14,0.96);
        color: #e5e7eb;
        box-shadow: 0 16px 64px rgba(0,0,0,0.45);
        padding: 0;
      ">
        <div style="display:flex; align-items:center; justify-content:space-between; padding: 12px 14px; border-bottom: 1px solid rgba(255,255,255,0.08);">
          <div>
            <div style="font-weight: 800;">End Session Report</div>
            <div style="opacity:.75; font-size:12px; margin-top:2px;">${escapeHtml(headerSub || "")}</div>
          </div>
          <button id="luxConvoReportClose" style="background: transparent; border: 1px solid rgba(255,255,255,0.18); color:#e5e7eb; padding: 8px 12px; border-radius: 10px; cursor:pointer;">Close</button>
        </div>
        <div style="padding: 12px 14px; overflow:auto;">
          <div style="display:grid; grid-template-columns: 1fr; gap: 14px;">

            <div style="border:1px solid rgba(255,255,255,0.10); background: rgba(255,255,255,0.04); border-radius: 14px; padding: 12px;">
              <div style="font-weight: 800; margin-bottom: 8px;">Targets loaded</div>
              <div style="font-size: 12px; opacity:.9;">Focus sound</div>
              <div style="margin: 6px 0 10px;">${escapeHtml(focusPhLine)}</div>
              <div style="font-size: 12px; opacity:.9; margin-top: 6px;">Word bank</div>
              ${chipRow(targetWords)}
            </div>

            <div style="border:1px solid rgba(255,255,255,0.10); background: rgba(255,255,255,0.04); border-radius: 14px; padding: 12px;">
              <div style="font-weight: 800; margin-bottom: 8px;">What you actually practiced</div>
              <div style="font-size: 12px; opacity:.9;">Target words you said</div>
              ${chipRow(saidTargets)}
              <div style="font-size: 12px; opacity:.9; margin-top: 10px;">Target words you said that still need work today</div>
              ${chipRow(saidTargetsNeedingWork)}
            </div>

            <div style="border:1px solid rgba(255,255,255,0.10); background: rgba(255,255,255,0.04); border-radius: 14px; padding: 12px;">
              <div style="font-weight: 800; margin-bottom: 8px;">Needs work today (this session)</div>
              <div style="font-size: 12px; opacity:.9;">Top trouble words</div>
              ${chipRow(topTroubleWords)}
              <div style="font-size: 12px; opacity:.9; margin-top: 10px;">Top trouble sounds (phonemes)</div>
              ${chipRow(topTroublePh)}
            </div>

            <details style="border:1px solid rgba(255,255,255,0.10); background: rgba(255,255,255,0.03); border-radius: 14px; padding: 10px 12px;">
              <summary style="cursor:pointer; font-weight: 800;">Debug JSON</summary>
              <div style="padding: 12px 14px;">

                <div style="
                  margin: 0 0 12px 0;
                  padding: 12px;
                  border: 1px solid rgba(255,255,255,0.08);
                  border-radius: 12px;
                  background: rgba(255,255,255,0.04);
                ">
                  <div style="font-weight:800; margin-bottom:8px;">AI Coach</div>
                  <div id="luxConvoCoachTurnList" style="display:flex; flex-direction:column; gap:8px;"></div>
                  <div style="font-size:12px; opacity:0.85; margin-top:8px;">
                    Choose a turn to coach (turns without analysis are disabled).
                  </div>
                </div>

                <pre id="luxConvoReportPre" style="
                  white-space: pre-wrap;
                  word-break: break-word;
                  font-size: 12px;
                  line-height: 1.35;
                  margin: 10px 0 0;
                  background: rgba(255,255,255,0.06);
                  border: 1px solid rgba(255,255,255,0.10);
                  padding: 12px;
                  border-radius: 12px;
                ">${pretty}</pre>
              </div>
            </details>

          </div>
        </div>
      </dialog>
    `;

    host.querySelector("#luxConvoReportClose")?.addEventListener("click", () =>
      host.remove()
    );

    wireCoachTurnList(host, turns);
  } else {
    // If reusing existing overlay, just update Debug JSON block
    const pre = host.querySelector("#luxConvoReportPre");
    if (pre) pre.textContent = JSON.stringify(report, null, 2);

    wireCoachTurnList(host, turns);
  }

  document.body.appendChild(host);
}
</file>

<file path="features/convo/knobs-drawer.js">
// features/convo/knobs-drawer.js

const KNOBS_KEY = "lux_knobs_v1";

const DEFAULTS = {
  tone: "friendly",   // friendly | neutral | playful | formal | flirty
  stress: "medium",   // low | medium | high
  pace: "normal",     // slow | normal | fast
};

function read() {
  try {
    const raw = localStorage.getItem(KNOBS_KEY);
    if (!raw) return { ...DEFAULTS };
    const parsed = JSON.parse(raw);
    return { ...DEFAULTS, ...(parsed || {}) };
  } catch {
    return { ...DEFAULTS };
  }
}

function write(next) {
  localStorage.setItem(KNOBS_KEY, JSON.stringify(next));
  window.dispatchEvent(new CustomEvent("lux:knobs", { detail: next }));
}

export function getKnobs() {
  return read();
}

export function setKnobs(patch) {
  const cur = read();
  const next = { ...cur, ...(patch || {}) };
  write(next);
  return next;
}

export function onKnobsChange(fn) {
  const handler = (e) => fn(e.detail || read());
  window.addEventListener("lux:knobs", handler);
  return () => window.removeEventListener("lux:knobs", handler);
}

export function formatKnobsSummary(k) {
  const tone = (k.tone || DEFAULTS.tone);
  const stress = (k.stress || DEFAULTS.stress);
  const pace = (k.pace || DEFAULTS.pace);
  const cap = (s) => s.charAt(0).toUpperCase() + s.slice(1);
  return `Tone: ${cap(tone)} • Stress: ${cap(stress)} • Pace: ${cap(pace)}`;
}

function ensureDom() {
  let overlay = document.getElementById("luxKnobsOverlay");
  let drawer = document.getElementById("luxKnobsDrawer");

  if (!overlay) {
    overlay = document.createElement("div");
    overlay.id = "luxKnobsOverlay";
    overlay.className = "lux-knobsOverlay";
    document.body.appendChild(overlay);
  }

  if (!drawer) {
    drawer = document.createElement("aside");
    drawer.id = "luxKnobsDrawer";
    drawer.className = "lux-knobsDrawer";
    drawer.setAttribute("aria-hidden", "true");
    drawer.innerHTML = `
      <div class="lux-knobsHeader">
        <div class="lux-knobsTitle">Scene knobs</div>
        <button class="lux-knobsClose" type="button" aria-label="Close">✕</button>
      </div>

      <div class="lux-knobsBody">
        <div class="lux-knobsGroup" data-key="tone">
          <div class="lux-knobsLabel">Tone</div>
          <div class="lux-knobsChips">
            <button type="button" data-value="friendly">Friendly</button>
            <button type="button" data-value="neutral">Neutral</button>
            <button type="button" data-value="playful">Playful</button>
            <button type="button" data-value="formal">Formal</button>
            <button type="button" data-value="flirty">Flirty</button>
          </div>
        </div>

        <div class="lux-knobsGroup" data-key="stress">
          <div class="lux-knobsLabel">Stress level</div>
          <div class="lux-knobsChips">
            <button type="button" data-value="low">Low</button>
            <button type="button" data-value="medium">Medium</button>
            <button type="button" data-value="high">High</button>
          </div>
        </div>

        <div class="lux-knobsGroup" data-key="pace">
          <div class="lux-knobsLabel">Pace</div>
          <div class="lux-knobsChips">
            <button type="button" data-value="slow">Slow</button>
            <button type="button" data-value="normal">Normal</button>
            <button type="button" data-value="fast">Fast</button>
          </div>
        </div>
      </div>
    `;
    document.body.appendChild(drawer);
  }

  return { overlay, drawer };
}

function paintSelection(drawer, knobs) {
  drawer.querySelectorAll(".lux-knobsGroup").forEach((group) => {
    const key = group.getAttribute("data-key");
    const val = knobs[key];
    group.querySelectorAll("button[data-value]").forEach((b) => {
      const on = b.getAttribute("data-value") === val;
      b.classList.toggle("is-on", on);
      b.setAttribute("aria-pressed", on ? "true" : "false");
    });
  });
}

export function mountKnobsDrawer() {
  const { overlay, drawer } = ensureDom();

  const open = () => {
    const knobs = getKnobs();
    paintSelection(drawer, knobs);
    overlay.dataset.open = "1";
    drawer.dataset.open = "1";
    drawer.setAttribute("aria-hidden", "false");
  };

  const close = () => {
    overlay.dataset.open = "0";
    drawer.dataset.open = "0";
    drawer.setAttribute("aria-hidden", "true");
  };

  overlay.addEventListener("click", close);
  drawer.querySelector(".lux-knobsClose").addEventListener("click", close);

  drawer.addEventListener("click", (e) => {
    const btn = e.target.closest("button[data-value]");
    if (!btn) return;

    const group = btn.closest(".lux-knobsGroup");
    if (!group) return;

    const key = group.getAttribute("data-key");
    const value = btn.getAttribute("data-value");
    const next = setKnobs({ [key]: value });

    paintSelection(drawer, next);
  });

  document.addEventListener("keydown", (e) => {
    if (e.key === "Escape" && drawer.dataset.open === "1") close();
  });

  return { open, close };
}
</file>

<file path="features/convo/picker-deck.js">
// features/convo/picker-deck.js
import { mountKnobsDrawer, getKnobs, onKnobsChange, formatKnobsSummary } from "./knobs-drawer.js";

const knobsDrawer = mountKnobsDrawer();

export function wirePickerDeck({
  scenarios,
  state,
  thumbs,
  deckActive,
  deckPreview,
  backBtn,
  nextBtn,

  // helpers / deps
  el,
  applyMediaSizingVars,
  applySceneVisuals,

  // callback
  onBeginScenario,
}) {
  const list = Array.isArray(scenarios) ? scenarios : [];

  function safeBeginScenario() {
    try {
      const p = onBeginScenario?.();
      if (p && typeof p.catch === "function") p.catch(console.error);
    } catch (e) {
      console.error(e);
    }
  }

  // --- thumbs: lazy/progressive background-image hydration (prevents 24 immediate loads) ---
  let _thumbIO = null;

  function toThumbUrl(url){
    const s = String(url || "");
    if (!s) return "";
    if (s.includes("/convo-img/thumbs/")) return s;

    // Turn /convo-img/foo.(webp|png|jpg|jpeg) into /convo-img/thumbs/foo.webp
    const m = s.match(/\/convo-img\/([^\/?#]+)\.(webp|png|jpe?g)(?:[?#].*)?$/i);
    if (!m) return s;

    return `/convo-img/thumbs/${m[1]}.webp`;
  }

  function scenarioThumbUrl(s){
    const t =
      (s && (
        s.thumb ||
        s.thumbnail ||
        s.preview ||
        s.img ||
        s.image ||
        (s.media && (s.media.poster || s.media.thumb))
      )) || "";

    const raw =
      (typeof t === "string") ? t :
      (t && typeof t === "object") ? (t.url || t.src || "") :
      "";

    return toThumbUrl(raw);
  }

  function applyThumb(btn){
    if (!btn) return;
    const u = btn.dataset.thumbSrc;
    if (!u || btn.dataset.hydrated === "1") return;

    btn.style.backgroundImage = `url("${u}")`;
    btn.dataset.hydrated = "1";
  }

  function hydrateThumbButtons(container, { immediate = 8 } = {}) {
    if (!container) return () => {};

    // Kill any previous IO watcher to avoid leaks across re-renders
    if (_thumbIO) {
      _thumbIO.disconnect();
      _thumbIO = null;
    }

    const btns = Array.from(container.querySelectorAll(".lux-thumb[data-thumb-src]"));

    // Load the first N immediately (what you expected to see: ~8)
    btns.slice(0, immediate).forEach(applyThumb);

    // Then hydrate the rest gradually (doesn't dogpile the network)
    const rest = btns.slice(immediate);
    let i = 0;

    const pump = () => {
      const tick = () => {
        // a couple at a time so we don't stampede the network
        for (let k = 0; k < 2 && i < rest.length; k++, i++) applyThumb(rest[i]);
        if (i < rest.length) setTimeout(tick, 120);
      };
      tick();
    };

    // Prefer idle time if available
    if ("requestIdleCallback" in window) {
      window.requestIdleCallback(pump, { timeout: 800 });
    } else {
      setTimeout(pump, 250);
    }

    // Also load on demand if the strip is scrollable / off-screen thumbs
    _thumbIO = new IntersectionObserver((entries) => {
      for (const e of entries) {
        if (e.isIntersecting) {
          applyThumb(e.target);
          _thumbIO.unobserve(e.target);
        }
      }
    }, { root: container, rootMargin: "120px 0px", threshold: 0.01 });

    rest.forEach((b) => _thumbIO.observe(b));

    return () => {
      if (_thumbIO) {
        _thumbIO.disconnect();
        _thumbIO = null;
      }
    };
  }

  function renderThumbs({ thumbs, list, selectedId, onPick }){
    if (!thumbs) return;

    thumbs.innerHTML = "";

    list.forEach((s, i) => {
      const isActive = i === state.scenarioIdx;
      const b = el("button", "lux-thumb" + (isActive ? " is-active" : ""));
      b.type = "button";
      b.title = s?.title || `Scenario ${i + 1}`;

      // accessibility + "active" marker
      b.setAttribute("aria-label", b.title);
      b.setAttribute("aria-current", isActive ? "true" : "false");

      const thumb = scenarioThumbUrl(s);
      if (thumb) {
        b.dataset.thumbSrc = thumb;     // store only
        b.classList.add("has-img");
        b.textContent = "";
        // DO NOT set backgroundImage here
      } else {
        // fallback (keeps your “color dots” behavior if a scenario has no image)
        const hue = (i * 37) % 360;
        b.style.backgroundImage = `linear-gradient(135deg, hsl(${hue} 55% 70%), hsl(${(hue+18)%360} 55% 62%))`;
        b.textContent = (s?.title || "?").trim().slice(0, 1).toUpperCase();
      }

      b.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        state.scenarioIdx = i;
        renderDeck();
      });

      thumbs.append(b);
    });
  }

  function fillDeckCard(host, scenario, isActive) {
    if (!host) return;

    // Hard reset (prevents duplicate media / handlers across re-renders)
    host.replaceChildren();
    host.onpointerenter = null;
    host.onpointerleave = null;

    // Always collapse when re-rendering a card
    host.classList.remove("isExpanded");

    // image background (existing behavior)
    host.classList.toggle("has-img", !!scenario.img);
    if (scenario.img) host.style.setProperty("--lux-card-img", `url("${scenario.img}")`);
    else host.style.removeProperty("--lux-card-img");

    applyMediaSizingVars?.(host, scenario.img);

    // --- media layer (sits behind text) ---
    const media = el("div", "lux-cardMedia");
    host.append(media);

    // --- VIDEO RESOLUTION (zero-touch fallback) ---
    // If you later add scenario.video explicitly, it will win.
    const resolveVideoSrc = (s) => {
      if (s?.video) return s.video;
      const img = String(s?.img || "");
      const m = img.match(/\/convo-img\/([^\/?#]+)\.(webp|png|jpe?g)(?:[?#].*)?$/i);
      if (!m) return "";
      return `/convo-vid/${m[1].toLowerCase()}.mp4`;
    };

    // reset any prior video state
    host.classList.toggle("has-video", false);
    delete host.dataset.vstate;
    delete host.dataset.vtoken;

    // --- active-card video (optional) ---
    // Inactive/preview: NEVER mounts video.
    if (isActive) {
      const vsrc = resolveVideoSrc(scenario);

      if (vsrc) {
        host.classList.add("has-video");
        host.dataset.vstate = "idle";

        const v = document.createElement("video");
        v.className = "lux-cardVideo";
        v.src = vsrc;
        v.preload = "metadata";

        // autoplay-friendly + iOS/Safari friendliness
        v.muted = true;
        v.setAttribute("muted", "");
        v.setAttribute("playsinline", "");
        v.setAttribute("webkit-playsinline", "");

        media.append(v);

        const reduced = window.matchMedia("(prefers-reduced-motion: reduce)").matches;

        // Token prevents stale timeouts from starting an old card’s video
        const token = `${Date.now()}_${Math.random().toString(16).slice(2)}`;
        host.dataset.vtoken = token;

        if (!reduced) {
          // Start AFTER the deck transition settles (tune if needed)
          const SETTLE_MS = 560;

          setTimeout(() => {
            if (host.dataset.vtoken !== token) return;
            if (!document.body.contains(host)) return;

            host.dataset.vstate = "playing";
            try {
              v.currentTime = 0;
            } catch (_) {}

            const p = v.play();
            if (p && typeof p.catch === "function") {
              p.catch(() => {
                // autoplay/codec/path failure => fall back to still image
                if (host.dataset.vtoken !== token) return;
                host.dataset.vstate = "error";
              });
            }
          }, SETTLE_MS);

          v.addEventListener("error", () => {
            if (host.dataset.vtoken !== token) return;
            host.dataset.vstate = "error";
          });

          // When finished, fade video away (reveals still background)
          v.addEventListener("ended", () => {
            if (host.dataset.vtoken !== token) return;
            host.dataset.vstate = "ended";

            // Optional replay on hover (only after it ended)
            host.onpointerenter = () => {
              if (host.dataset.vtoken !== token) return;
              host.dataset.vstate = "playing";
              try {
                v.currentTime = 0;
              } catch (_) {}
              v.play().catch(() => {
                if (host.dataset.vtoken !== token) return;
                host.dataset.vstate = "error";
              });
            };
          });

          // If you EVER want looping instead of “play once then still”:
          // v.loop = true;
        }
      }
    }

    // --- your existing text content (now wrapped so we can style readability) ---
    const textWrap = el("div", "lux-deckText");

    textWrap.append(
      el("div", "lux-pill", "DIALOGUE"),
      el("div", "lux-deckTitle", scenario.title),
      el("div", "lux-deckDesc", scenario.desc || "")
    );

    // “more” content node (shown when expanded via CSS)
    const moreText =
      scenario.more ||
      "More details coming next: goals, moves, and what to listen for.";

    textWrap.append(el("div", "lux-deckMore", moreText));

    // CTA only on active card (keeps preview calm / non-interactive)
    if (isActive) {
      const cta = el("button", "lux-deckCta", "Practice this dialogue");
      cta.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        safeBeginScenario();
      });
      textWrap.append(cta);

      // NEW: Knobs row in picker card (active card only)
      const knobsRow = el("div", "lux-deckKnobsRow");

      const knobsBtn = el("button", "lux-deckKnobsBtn", "Knobs");
      knobsBtn.type = "button";
      knobsBtn.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();       // IMPORTANT: don't advance deck
        knobsDrawer.open();
      });

      const summary = el("div", "lux-deckKnobsSummary", formatKnobsSummary(getKnobs()));
      const unsub = onKnobsChange((k) => { summary.textContent = formatKnobsSummary(k); });

      // If you ever destroy/rebuild cards aggressively, you can call unsub() then.
      knobsRow.append(knobsBtn, summary);
      host.append(knobsRow);

      // Active card: click toggles expanded description (never advances, never begins)
      host.onclick = () => {
        host.classList.toggle("isExpanded");
      };
    } else {
      // Preview card: don't set onclick here (wirePickerDeck already has a click listener on deckPreview)
      host.onclick = null;
    }

    host.append(textWrap);
  }

  let disposeThumbHydrator = null;

  function renderDeck() {
    applySceneVisuals?.();

    if (!list.length) {
      renderThumbs({ thumbs, list, selectedId: null, onPick: () => {} });
      return;
    }

    const idx = state.scenarioIdx;
    const next = (idx + 1) % list.length;

    fillDeckCard(deckActive, list[idx], true);
    fillDeckCard(deckPreview, list[next], false);

    renderThumbs({
      thumbs,
      list,
      selectedId: list[idx]?.id,
      onPick: (id) => {
        const i = list.findIndex((s) => s?.id === id);
        if (i >= 0) {
          state.scenarioIdx = i;
          renderDeck();
        }
      }
    });

    if (disposeThumbHydrator) disposeThumbHydrator();
    disposeThumbHydrator = hydrateThumbButtons(thumbs, { immediate: 8 });
  }

  // --- wire controls (once) ---
  backBtn?.addEventListener("click", () => {
    if (!list.length) return;
    state.scenarioIdx = (state.scenarioIdx - 1 + list.length) % list.length;
    renderDeck();
  });

  nextBtn?.addEventListener("click", () => {
    if (!list.length) return;
    state.scenarioIdx = (state.scenarioIdx + 1) % list.length;
    renderDeck();
  });

  // Preview click behaves like Next (Edge feel)
  deckPreview?.addEventListener("click", () => {
    if (!list.length) return;
    state.scenarioIdx = (state.scenarioIdx + 1) % list.length;
    renderDeck();
  });

  return { renderDeck };
}
</file>

<file path="features/convo/progress.js">
// features/convo/progress.js
// Conversation Skills progress panel (same look as Practice Results, but filtered to convo:* attempts).
// Renders as a collapsed drawer; loads on expand.

import { fetchHistory, ensureUID } from "/src/api/index.js";
import { computeRollups } from "../progress/rollups.js";
import { renderProgressDashboard } from "../progress/render.js";

const HUB_HREF = "./progress.html";

let _state = null;

function pickPassageKey(a) {
  return a?.passage_key || a?.passageKey || a?.passage || "";
}

function isConvoAttempt(a) {
  return String(pickPassageKey(a)).startsWith("convo:");
}

function fmtMini(totals = {}) {
  const avg = Math.round(Number(totals.avgScore || 0));
  const attempts = totals.attempts ?? 0;
  const last = totals.lastTS ? new Date(totals.lastTS) : null;
  const lastStr = last ? last.toLocaleDateString(undefined, { month: "short", day: "numeric" }) : "—";
  return `Avg ${avg}% · Attempts ${attempts} · Last ${lastStr}`;
}

export async function refreshConvoProgress() {
  if (!_state?.host) return;

  try {
    const uid = ensureUID();
    const attempts = await fetchHistory(uid);
    const filtered = (attempts || []).filter(isConvoAttempt);
    const model = computeRollups(filtered, { windowDays: 30 });

    if (_state.miniEl) _state.miniEl.textContent = fmtMini(model.totals);

    if (_state.detailsEl?.open && _state.mountEl) {
      renderProgressDashboard(_state.mountEl, filtered, model, {
        title: "My Progress",
        subtitle: "Conversation Skills (AI Conversations)",
        showActions: false,
      });
    }
  } catch (err) {
    console.error("[ConvoProgress] refresh failed:", err);
    if (_state.miniEl) _state.miniEl.textContent = "History unavailable";
  }
}

export async function initConvoProgress() {
  const host = document.getElementById("convoProgress");
  if (!host) return;

  // expose refresh hook so convo/index.js can call it after saveAttempt
  window.refreshConvoProgress = refreshConvoProgress;

  host.innerHTML = `
    <details class="lux-progress-drawer">
      <summary class="lux-progress-drawer-summary">
        <div class="lux-progress-drawer-left">
          <div class="lux-progress-drawer-title">My Progress · Conversation Skills</div>
          <div class="lux-progress-drawer-mini" data-role="mini">Tap to load</div>
        </div>
        <a class="lux-progress-drawer-link" href="${HUB_HREF}">All Data</a>
      </summary>
      <div class="lux-progress-drawer-body">
        <div class="lux-progress-drawer-mount" data-role="mount">
          <div style="color:#64748b; padding: 14px 16px;">Open to load your history.</div>
        </div>
      </div>
    </details>
  `;

  const detailsEl = host.querySelector("details.lux-progress-drawer");
  const miniEl = host.querySelector('[data-role="mini"]');
  const mountEl = host.querySelector('[data-role="mount"]');

  _state = { host, detailsEl, miniEl, mountEl };

  let loadedOnce = false;

  async function loadIfNeeded() {
    if (loadedOnce) return;
    loadedOnce = true;

    if (mountEl) mountEl.innerHTML = `<div style="color:#64748b; padding: 14px 16px;">Loading…</div>`;

    try {
      const uid = ensureUID();
      const attempts = await fetchHistory(uid);
      const filtered = (attempts || []).filter(isConvoAttempt);
      const model = computeRollups(filtered, { windowDays: 30 });

      if (miniEl) miniEl.textContent = fmtMini(model.totals);

      if (mountEl) {
        renderProgressDashboard(mountEl, filtered, model, {
          title: "My Progress",
          subtitle: "Conversation Skills (AI Conversations)",
          showActions: false,
        });
      }
    } catch (err) {
      console.error("[ConvoProgress] Drawer load failed:", err);
      loadedOnce = false; // allow retry
      if (miniEl) miniEl.textContent = "History unavailable";
      if (mountEl) mountEl.innerHTML = `<div style="color:#ef4444; padding: 14px 16px;">History unavailable.</div>`;
    }
  }

  if (detailsEl) {
    detailsEl.addEventListener("toggle", () => {
      if (detailsEl.open) loadIfNeeded();
    });
  }
}
</file>

<file path="features/convo/scenarios.js">
// features/convo/scenarios.js
export const SCENARIOS = [
  {
    id: "coffee",
    title: "Order Coffee",
    desc: "Quick small talk + ordering under mild time pressure.",
    img: "/convo-img/coffee.webp",
    thumb: "/convo-img/thumbs/coffee.webp",
    video: "/convo-vid/coffee.mp4", // ← ADD
  },
  {
    id: "doctor",
    title: "Doctor Visit",
    desc: "Explain symptoms, answer follow-ups, confirm instructions.",
    img: "/convo-img/doctor.webp",
    thumb: "/convo-img/thumbs/doctor.webp",
    video: "/convo-vid/doctor.mp4", // ← ADD
  },
  {
    id: "job",
    title: "Job Interview",
    desc: "Tell your story, strengths, and handle tricky questions.",
    img: "/convo-img/job.webp",
    thumb: "/convo-img/thumbs/job.webp",
    
  },
  {
    id: "landlord",
    title: "Call Your Landlord",
    desc: "Report an issue, ask for a repair schedule, be polite.",
    img: "/convo-img/landlord.webp",
    thumb: "/convo-img/thumbs/landlord.webp",
  },
  {
    id: "airport",
    title: "Airport Problem",
    desc: "Gate changes, delays, rebooking, and clarity under stress.",
    img: "/convo-img/airport.webp",
    thumb: "/convo-img/thumbs/airport.webp",
  },
  {
    id: "restaurant",
    title: "Restaurant Order",
    desc: "Order, modify politely, handle a mistake, pay.",
    img: "/convo-img/restaurant.webp",
    thumb: "/convo-img/thumbs/restaurant.webp",
  },
{
  id: "school",
  title: "School Meeting",
  desc: "Discuss goals and progress with an advisor or teacher.",
  img: "/convo-img/school.webp",
  thumb: "/convo-img/thumbs/school.webp",
  video: "/convo-vid/parents.mp4", // explicit override
},

{
  id: "network",
  title: "Networking Chat",
  desc: "Introduce yourself, keep it natural, ask good questions.",
  img: "/convo-img/networking.webp",
  thumb: "/convo-img/thumbs/networking.webp",
},
  {
    id: "banking",
    title: "Open a bank account",
    desc: "Ask about requirements, fees, and next steps.",
    img: "/convo-img/banking.webp",
    thumb: "/convo-img/thumbs/banking.webp",
    video: "/convo-vid/banking.mp4",
    more: "Bring up ID/documents, minimum balance, and fees. Ask clarifying questions and confirm the next steps."
  },
  {
    id: "calling",
    title: "Make an important phone call",
    desc: "Call to ask for information or solve a problem.",
    img: "/convo-img/calling.webp",
    thumb: "/convo-img/thumbs/calling.webp",
    video: "/convo-vid/calling.mp4",
    more: "Practice polite openings, explaining your reason, and confirming details before ending the call."
  },
  {
    id: "car",
    title: "Conversation in the car",
    desc: "Make small talk and discuss plans while driving.",
    img: "/convo-img/car.jpg",
    thumb: "/convo-img/thumbs/car.webp",
    video: "/convo-vid/car.mp4",
    more: "Practice natural turn-taking, reacting, and asking follow-up questions in a casual conversation."
  },
  {
    id: "choosing",
    title: "Choose items at the grocery store",
    desc: "Ask about products, prices, and recommendations.",
    img: "/convo-img/choosing.webp",
    thumb: "/convo-img/thumbs/choosing.webp",
    video: "/convo-vid/choosing.mp4",
    more: "Practice asking for help, comparing options, and confirming what you want to buy."
  },
  {
    id: "concern",
    title: "Raise a concern politely",
    desc: "Explain a problem and ask for a solution.",
    img: "/convo-img/concern.webp",
    thumb: "/convo-img/thumbs/concern.webp",
    video: "/convo-vid/concern.mp4",
    more: "Practice calm tone, clear details, and proposing options while staying respectful."
  },
  {
    id: "couple",
    title: "Chat with a couple at a party",
    desc: "Introduce yourself and keep the conversation going.",
    img: "/convo-img/couple.jpg",
    thumb: "/convo-img/thumbs/couple.webp",
    video: "/convo-vid/couple.mp4",
    more: "Practice greetings, friendly questions, and smooth topic changes in a social setting."
  },
  {
    id: "dinner",
    title: "Catch up over dinner",
    desc: "Talk with friends and share updates and stories.",
    img: "/convo-img/dinner.webp",
    thumb: "/convo-img/thumbs/dinner.webp",
    video: "/convo-vid/dinner.mp4",
    more: "Practice storytelling, reactions, and asking for more details while keeping it natural."
  },
  {
    id: "joke",
    title: "Tell a joke and react",
    desc: "Share something funny and respond appropriately.",
    img: "/convo-img/joke.jpg",
    thumb: "/convo-img/thumbs/joke.webp",
    video: "/convo-vid/joke.mp4",
    more: "Practice timing, tone, and quick reactions (laughing, clarifying, and keeping it light)."
  },
  {
    id: "lifeguard",
    title: "Talk to a lifeguard",
    desc: "Ask for help or information at the pool/beach.",
    img: "/convo-img/lifeguard.webp",
    thumb: "/convo-img/thumbs/lifeguard.webp",
    video: "/convo-vid/lifeguard.mp4",
    more: "Practice urgent-but-calm requests, describing the situation, and confirming safety instructions."
  },
  {
    id: "mail",
    title: "Ask about mail delivery",
    desc: "Ask where to drop mail off and understand the route.",
    img: "/convo-img/mail.jpg",
    thumb: "/convo-img/thumbs/mail.webp",
    video: "/convo-vid/mail.mp4",
    more: "Practice short clear questions, confirming locations, and thanking the worker politely."
  },
  {
    id: "networking",
    title: "Networking",
    desc: "TODO: one-sentence hook",
    img: "/convo-img/networking.webp",
    thumb: "/convo-img/thumbs/networking.webp",
    video: "/convo-vid/networking.mp4",
    more: "TODO: optional details"
  },
  {
    id: "parking",
    title: "Parking ticket situation",
    desc: "Explain what happened and ask what to do next.",
    img: "/convo-img/parking.webp",
    thumb: "/convo-img/thumbs/parking.webp",
    video: "/convo-vid/parking.mp4",
    more: "Practice explaining timing, asking for options, and staying calm under pressure."
  },
  {
    id: "police",
    title: "Ask a police officer for help",
    desc: "Request assistance, directions, or report a problem.",
    img: "/convo-img/police.webp",
    thumb: "/convo-img/thumbs/police.webp",
    video: "/convo-vid/police.mp4",
    more: "Practice respectful language, clear details, and confirming what you should do next."
  },
  {
    id: "shopping",
    title: "Shopping assistance",
    desc: "Ask about sizes, prices, and returns.",
    img: "/convo-img/shopping.jpg",
    thumb: "/convo-img/thumbs/shopping.webp",
    video: "/convo-vid/shopping.mp4",
    more: "Practice store phrases, comparing items, and confirming what you need before purchasing."
  },
  {
    id: "student",
    title: "Talk to the teacher after class",
    desc: "Ask questions and get feedback or help.",
    img: "/convo-img/student.webp",
    thumb: "/convo-img/thumbs/student.webp",
    video: "/convo-vid/student.mp4",
    more: "Practice asking for clarification, requesting help, and confirming what to do next."
  },
  {
    id: "technology",
    title: "Tech support problem",
    desc: "Explain an issue and troubleshoot step-by-step.",
    img: "/convo-img/technology.webp",
    thumb: "/convo-img/thumbs/technology.webp",
    video: "/convo-vid/technology.mp4",
    more: "Practice describing symptoms, following instructions, and confirming whether the fix worked."
  },
  {
    id: "understanding",
    title: "Clear up a misunderstanding",
    desc: "Ask for clarification and restate what you mean.",
    img: "/convo-img/understanding.webp",
    thumb: "/convo-img/thumbs/understanding.webp",
    video: "/convo-vid/understanding.mp4",
    more: "Practice ‘Did you mean…?’, paraphrasing, and confirming mutual understanding."
  },
];
</file>

<file path="features/convo/scene-atmo.js">
// features/convo/scene-atmo.js

export function initSceneAtmo({ root, atmo, state, scenarios = [] }) {
  // --- Edge-style scene tiles (scatter + depth + independent drift) ---
  const sceneHost = atmo.querySelector(".lux-scene-cards");

  const SCENE_SPECS = [
    { cls: "c1", w: 420, h: 270, rot: -10, parX: 24, parY: 16, depth: 0.92 },
    { cls: "c2", w: 460, h: 290, rot: 9, parX: -26, parY: 18, depth: 0.86 },
    { cls: "c3", w: 520, h: 320, rot: 6, parX: 30, parY: -22, depth: 0.8 },
    { cls: "c4", w: 480, h: 300, rot: -6, parX: -24, parY: -18, depth: 0.74 },
    { cls: "c5", w: 380, h: 240, rot: -4, parX: 16, parY: -14, depth: 0.64 },
    { cls: "c6", w: 400, h: 250, rot: 5, parX: -18, parY: -14, depth: 0.58 },
    { cls: "c7", w: 360, h: 230, rot: 3, parX: 14, parY: 12, depth: 0.5 },
    { cls: "c8", w: 440, h: 280, rot: 7, parX: 22, parY: 16, depth: 0.7 },
    { cls: "c9", w: 360, h: 230, rot: -8, parX: -20, parY: 14, depth: 0.68 },
    { cls: "c10", w: 420, h: 260, rot: 10, parX: 18, parY: -12, depth: 0.54 },
    { cls: "c11", w: 340, h: 220, rot: -2, parX: -14, parY: -10, depth: 0.46 },
  ];

  // --- Scene image assignment (11 visible, rotate through full scenarios list) ---
  const sceneCards = SCENE_SPECS
    .map((spec) => sceneHost?.querySelector(`.lux-scene-card.${spec.cls}`))
    .filter(Boolean);

  const used = new Set(); // scenario indices currently shown
  let queue = [];
  let qi = 0;
  let rotTimer = 0;

  function shuffleInPlace(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }

  function refillQueue() {
    queue = Array.from({ length: scenarios.length }, (_, i) => i);
    shuffleInPlace(queue);
    qi = 0;
  }

  function nextScenarioIdx() {
    if (!scenarios?.length) return -1;
    if (!queue.length || qi >= queue.length) refillQueue();

    // pick the next index not currently used (avoid duplicates on screen)
    let safety = 0;
    while (safety++ < scenarios.length * 2) {
      if (qi >= queue.length) refillQueue();
      const idx = queue[qi++];
      if (!used.has(idx)) return idx;
    }
    // fallback (should be rare)
    return Math.floor(Math.random() * scenarios.length);
  }

  function setCardScenario(cardEl, scenarioIdx) {
    const s = scenarios?.[scenarioIdx];
    if (!s) return;

    // Prefer full-size image for crisp tiles
    const img = s.img || s.thumb;
    if (!img) return;

    cardEl.dataset.sceneIdx = String(scenarioIdx);
    cardEl.dataset.sceneId = s.id || "";
    cardEl.style.setProperty("--img", `url("${img}")`);
  }

  function seedSceneImagesOnce() {
    if (!sceneHost || !sceneCards.length || !scenarios?.length) return;
    if (sceneHost.dataset.imgSeeded === "1") return;

    sceneHost.dataset.imgSeeded = "1";
    used.clear();
    refillQueue();

    for (const card of sceneCards) {
      const idx = nextScenarioIdx();
      used.add(idx);
      setCardScenario(card, idx);
    }

    ensureRotation();
  }

  function ensureRotation() {
    if (rotTimer) return;
    if (!scenarios?.length || scenarios.length <= sceneCards.length) return;

    const ROTATE_MS = 4200;
    const FADE_MS = 520;

    rotTimer = window.setInterval(() => {
      if (state.mode !== "intro") return;

      // make sure we’ve seeded (intro can be entered after a hash route)
      seedSceneImagesOnce();

      const card = sceneCards[Math.floor(Math.random() * sceneCards.length)];
      if (!card) return;

      const oldIdx = parseInt(card.dataset.sceneIdx || "-1", 10);
      if (oldIdx >= 0) used.delete(oldIdx);

      const nextIdx = nextScenarioIdx();
      used.add(nextIdx);

      // fade out → swap → fade in
      card.classList.add("is-swap");
      window.setTimeout(() => setCardScenario(card, nextIdx), Math.floor(FADE_MS * 0.55));
      window.setTimeout(() => card.classList.remove("is-swap"), FADE_MS);
    }, ROTATE_MS);
  }

  const sRand = (a, b) => a + Math.random() * (b - a);
  const sClamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const sShuffle = (arr) => {
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  };

  function mkRect(x, y, w, h) {
    return { x, y, w, h, x2: x + w, y2: y + h };
  }
  function rectIntersects(a, b, pad = 0) {
    return !(
      a.x2 + pad < b.x ||
      a.x - pad > b.x2 ||
      a.y2 + pad < b.y ||
      a.y - pad > b.y2
    );
  }
  function rectAreaIntersect(a, b) {
    const x = Math.max(0, Math.min(a.x2, b.x2) - Math.max(a.x, b.x));
    const y = Math.max(0, Math.min(a.y2, b.y2) - Math.max(a.y, b.y));
    return x * y;
  }

  function layoutSceneCards(force = false) {
    if (!sceneHost) return;
    if (state.mode !== "intro") return;

    // Don’t re-run constantly unless forced (resize / re-enter intro)
    if (!force && sceneHost.dataset.seeded === "1") return;
    sceneHost.dataset.seeded = "1";
    seedSceneImagesOnce();

    const hostRect = sceneHost.getBoundingClientRect();
    const W = hostRect.width;
    const H = hostRect.height;

    // Soft keep-out around the center hero card (Edge keeps background “around” it)
    const hero = root.querySelector(".lux-heroCard");
    const heroRect = hero?.getBoundingClientRect();
    const KEEP_PAD = 70;

    const keep = heroRect
      ? mkRect(
          heroRect.left - hostRect.left - KEEP_PAD,
          heroRect.top - hostRect.top - KEEP_PAD,
          heroRect.width + KEEP_PAD * 2,
          heroRect.height + KEEP_PAD * 2
        )
      : null;

    // Zones to avoid left/right poles and populate the center band
    const ZONES = sShuffle([
      { x0: 0.05, x1: 0.33, y0: 0.08, y1: 0.38 },
      { x0: 0.33, x1: 0.67, y0: 0.02, y1: 0.3 },
      { x0: 0.67, x1: 0.95, y0: 0.08, y1: 0.38 },

      { x0: 0.05, x1: 0.35, y0: 0.58, y1: 0.96 },
      { x0: 0.3, x1: 0.7, y0: 0.46, y1: 0.94 },
      { x0: 0.65, x1: 0.95, y0: 0.58, y1: 0.96 },
    ]);

    // Build placement list (big cards first)
    const items = [];

    for (const s of SCENE_SPECS) {
      const node = sceneHost.querySelector(`.lux-scene-card.${s.cls}`);
      if (!node) continue;
      items.push({ node, spec: s, kind: "main" });
    }

    const placed = [];
    const GAP = 120; // bigger gap => fewer crossings/overlaps

    // Place each item with rejection sampling, scoring collisions/keep-out
    items.forEach((it) => {
      const d = it.spec.depth;

      // depth mapping: keep depth via size + z + shadow only
      const scale = 0.78 + d * 0.3; // ~0.83..1.07
      const shadowA = 0.1 + d * 0.16; // ~0.13..0.26
      const z = Math.round(d * 100);

      const w = Math.round(it.spec.w * scale);
      const h = Math.round(it.spec.h * scale);

      // Parallax: far moves less, near moves more (but keep calm)
      const parScale = 0.6 + d * 0.55;
      const parX = Math.round(it.spec.parX * parScale);
      const parY = Math.round(it.spec.parY * parScale);

      // Drift: desynced
      const driftMag = sRand(16, 38);
      const driftX = Math.round(driftMag * sRand(0.7, 1.2));
      const driftY = Math.round(driftMag * sRand(0.6, 1.15));
      const driftR = sRand(1.4, 3.8).toFixed(2);

      const dur = sRand(12, 24).toFixed(2);
      const delay = (-sRand(0, 10)).toFixed(2); // negative = random phase immediately

      // Try to find a good placement
      let best = null;
      for (let t = 0; t < 220; t++) {
        const zc = ZONES[t % ZONES.length];
        const cx = sRand(W * zc.x0, W * zc.x1);
        const cy = sRand(H * zc.y0, H * zc.y1);

        const x = Math.round(cx - w / 2);
        const y = Math.round(cy - h / 2);

        const r = mkRect(x, y, w, h);

        let collisions = 0;
        let minDist = Infinity;

        for (const p of placed) {
          if (rectIntersects(r, p, GAP)) collisions++;
          const dx = r.x + r.w / 2 - (p.x + p.w / 2);
          const dy = r.y + r.h / 2 - (p.y + p.h / 2);
          const dist = Math.hypot(dx, dy);
          if (dist < minDist) minDist = dist;
        }

        const keepArea = keep ? rectAreaIntersect(r, keep) : 0;

        // Score: collisions are catastrophic, keep-out is heavy penalty, distance is a tiebreaker
        const score = collisions * 1e6 + keepArea * 40 - minDist;

        if (!best || score < best.score) best = { r, score };
        if (collisions === 0 && keepArea < 300) break; // good enough
      }

      const finalR = best ? best.r : mkRect(0, 0, w, h);
      placed.push(finalR);

      // Allow a little offscreen, but prevent the “only 2 visible” extreme.
      const OFF_X = 44;
      const OFF_Y = 34;

      finalR.x = sClamp(finalR.x, -OFF_X, W - w + OFF_X);
      finalR.y = sClamp(finalR.y, -OFF_Y, H - h + OFF_Y);

      // Commit CSS variables
      it.node.style.setProperty("--ax", `${finalR.x}px`);
      it.node.style.setProperty("--ay", `${finalR.y}px`);
      it.node.style.setProperty("--w", `${w}px`);
      it.node.style.setProperty("--h", `${h}px`);

      it.node.style.setProperty("--baseRot", `${it.spec.rot}deg`);
      it.node.style.setProperty("--parX", `${parX}px`);
      it.node.style.setProperty("--parY", `${parY}px`);

      it.node.style.setProperty("--driftX", `${driftX}px`);
      it.node.style.setProperty("--driftY", `${driftY}px`);
      it.node.style.setProperty("--driftR", `${driftR}deg`);
      it.node.style.setProperty("--driftDur", `${dur}s`);
      it.node.style.setProperty("--driftDelay", `${delay}s`);

      // keep shadow depth if you want:
      it.node.style.setProperty("--shadowA", shadowA.toFixed(3));

      // force these, even if old CSS still references them:
      it.node.style.setProperty("--alpha", "1");
      it.node.style.setProperty("--blur", "0px");

      it.node.style.setProperty("--s", "1"); // width/height already include scale
      it.node.style.setProperty("--z", String(z));
    });
  }

  // Resize: re-layout (intro only)
  let sceneResizeTimer = 0;
  window.addEventListener(
    "resize",
    () => {
      if (state.mode !== "intro") return;
      clearTimeout(sceneResizeTimer);
      sceneResizeTimer = setTimeout(() => layoutSceneCards(true), 120);
    },
    { passive: true }
  );

  // --- Scene visuals / parallax ---
  function applySceneVisuals() {
    const hue = (185 + state.scenarioIdx * 34) % 360;
    root.style.setProperty("--lux-hue", String(hue));
    root.dataset.side = state.scenarioIdx % 2 === 0 ? "left" : "right";
  }

  // --- Parallax driver (Edge-like: stage-relative + eased + recenters on leave) ---
  const par = { tx: 0, ty: 0, x: 0, y: 0, raf: 0 };
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

  function parTick() {
    // Ease gives that “float / inertia” feel
    par.x += (par.tx - par.x) * 0.18;
    par.y += (par.ty - par.y) * 0.18;

    root.style.setProperty("--lux-mx", par.x.toFixed(4));
    root.style.setProperty("--lux-my", par.y.toFixed(4));

    const done = Math.abs(par.tx - par.x) < 0.001 && Math.abs(par.ty - par.y) < 0.001;
    if (done) {
      par.raf = 0;
      return;
    }
    par.raf = requestAnimationFrame(parTick);
  }
  function parKick() {
    if (!par.raf) par.raf = requestAnimationFrame(parTick);
  }

  function parSetFromEvent(e) {
    if (state.mode !== "intro" || root.dataset.parallax !== "on") return;

    const BOOST = 1.55; // more lively than the “restricted” version
    const MAX = 1.25; // still far from the old ±2 insanity

    const nx = (e.clientX / window.innerWidth - 0.5) * 2;
    const ny = (e.clientY / window.innerHeight - 0.5) * 2;

    par.tx = clamp(nx * BOOST, -MAX, MAX);
    par.ty = clamp(ny * BOOST, -MAX, MAX);

    parKick();
  }

  window.addEventListener("pointermove", parSetFromEvent, { passive: true });
  window.addEventListener("pointerdown", parSetFromEvent, { passive: true });

  window.addEventListener("blur", () => {
    par.tx = 0;
    par.ty = 0;
    parKick();
  });

  // When the pointer leaves the browser window, re-center
  window.addEventListener("mouseout", (e) => {
    if (!e.relatedTarget && !e.toElement) {
      par.tx = 0;
      par.ty = 0;
      parKick();
    }
  });

  // ensure neutral at boot
  root.style.setProperty("--lux-mx", "0");
  root.style.setProperty("--lux-my", "0");

  function setParallaxEnabled(on) {
    root.dataset.parallax = on ? "on" : "off";

    if (!on) {
      par.tx = 0;
      par.ty = 0;
      par.x = 0;
      par.y = 0;
      par.raf = 0;
      root.style.setProperty("--lux-mx", "0");
      root.style.setProperty("--lux-my", "0");
    } else {
      layoutSceneCards(true); // <-- ADD THIS
    }
  }

  return { applySceneVisuals, setParallaxEnabled };
}
</file>

<file path="features/dashboard/ui.js">
// features/dashboard/ui.js
import { computeRollups } from "../progress/rollups.js";
import { renderProgressDashboard } from "../progress/render.js";

export function renderDashboard(targetId) {
  const container = document.getElementById(targetId);
  if (!container) return;

  container.innerHTML = `
    <section class="lux-progress-shell">
      <div style="color:#64748b; padding: 14px 0;">Loading progress…</div>
    </section>
  `;
}

export function renderHistoryRows(attempts) {
  const container = document.getElementById("dashboard-root");
  if (!container) return;

  const model = computeRollups(attempts || [], { windowDays: 30 });
  renderProgressDashboard(container, attempts || [], model);
}

export function renderError(msg) {
  const container = document.getElementById("dashboard-root");
  if (!container) return;
  container.innerHTML = `
    <section class="lux-progress-shell">
      <div class="lux-pcard">
        <div class="lux-pcard-label">Progress</div>
        <div class="lux-pcard-value">—</div>
        <div class="lux-pcard-mini" style="color:#dc2626; font-weight:800">${msg || "Error"}</div>
      </div>
    </section>
  `;
}
</file>

<file path="features/features/self-playback.css">
/* =========================================================
   Self Playback (Inner Controls)
   File: features/features/self-playback.css
   STATUS: FIXED (Light Theme + Correct ID)
   ========================================================= */

:root {
  /* LIGHT THEME PALETTE */
  --sp-bg: #ffffff;
  --sp-fg: #333333;
  --sp-muted: #6b7280;
  --sp-card: #f3f4f6; /* Light grey for buttons/cards */

  --sp-border: #e5e7eb;
  --sp-accent: #2d6cdf;
  --sp-accent-2: #5aa0ff;
  --sp-danger: #ef4444;

  --sp-radius-lg: 14px;
  --sp-radius-md: 10px;
  --sp-shadow: 0 10px 28px rgba(0, 0, 0, 0.15); /* Softer shadow */
}

/* Host shell */
#selfpb-lite {
  position: fixed;
  top: 12px;
  left: 12px;
  z-index: 9999;
  font: 600 13px/1.3 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
  color: var(--sp-fg);
}

/* Hiding logic */
#selfpb-lite[data-luxHidden="1"] {
  width: 44px;
  height: 36px;
  overflow: visible;
}
#selfpb-lite[data-luxHidden="0"] {
  width: auto;
  height: auto;
}

/* Toggle Tab */
.selfpb-toggle {
  cursor: pointer;
  user-select: none;
  display: inline-flex;
  gap: 6px;
  align-items: center;
  padding: 8px 10px;
  border-radius: var(--sp-radius-md);
  background: #ffffff; /* White tab */
  color: #333;
  box-shadow: 0 4px 14px rgba(0, 0, 0, 0.1);
  border: 1px solid var(--sp-border);
  transition: transform 0.18s ease, filter 0.18s ease, box-shadow 0.18s ease;
}
.selfpb-toggle:hover {
  transform: translateX(1px);
  filter: brightness(0.98);
}
.selfpb-toggle:active {
  transform: translateX(0);
  filter: brightness(0.95);
}
.selfpb-toggle:focus-visible {
  outline: 2px solid var(--sp-accent);
  outline-offset: 2px;
}

/* Safe Nudge Animation */
@keyframes spNudge {
  0% { transform: translateX(0) scale(1); box-shadow: none; }
  30% { transform: translateX(3px) scale(1.02); box-shadow: 0 0 0 4px rgba(45, 108, 223, 0.1); }
  60% { transform: translateX(0) scale(1.04); box-shadow: 0 0 0 8px rgba(45, 108, 223, 0.05); }
  100% { transform: translateX(0) scale(1); box-shadow: none; }
}
.selfpb-toggle.selfpb-nudge {
  animation: spNudge 1.1s ease-in-out 1;
}

/* Panel Internals */
.selfpb-panel {
  position: absolute;
  top: 0; left: 0;
  width: min(460px, 92vw);
  background: var(--sp-bg);
  color: var(--sp-fg);
  border: 1px solid var(--sp-border);
  border-radius: var(--sp-radius-lg);
  padding: 10px;
  box-shadow: var(--sp-shadow);
  display: block;
  transform: translateX(calc(-100% - 12px));
  opacity: 0;
  pointer-events: none;
  transition: transform 0.35s cubic-bezier(0.2, 0.8, 0.2, 1), opacity 0.25s ease;
}

#selfpb-lite[data-luxHidden="0"] .selfpb-panel {
  transform: translateX(0);
  opacity: 1;
  pointer-events: auto;
}

.selfpb-row {
  display: flex;
  gap: 8px;
  align-items: center;
  margin-top: 8px;
  flex-wrap: wrap;
}

.selfpb-legend {
  font-size: 12px;
  color: var(--sp-muted);
  letter-spacing: 0.02em;
}

/* Buttons & Inputs - Light Theme */
.selfpb-btn {
  height: 32px; padding: 0 12px;
  border-radius: 8px; border: 1px solid #d1d5db;
  background: #ffffff; color: #333;
  font-weight: 700; cursor: pointer;
  transition: transform 0.16s ease, filter 0.16s ease;
}
.selfpb-btn:hover { transform: translateY(-1px); background: #f9fafb; }
.selfpb-btn:active { transform: translateY(0); background: #f3f4f6; }
.selfpb-btn:disabled { opacity: 0.55; cursor: not-allowed; }

.selfpb-btn--primary {
  background: linear-gradient(180deg, var(--sp-accent-2), var(--sp-accent));
  border-color: #1e4fb0; color: #fff;
}

.selfpb-pill {
  padding: 4px 10px; border-radius: 999px;
  background: #f3f4f6; border: 1px solid #d1d5db;
  color: #333; font-weight: 700; cursor: pointer;
}
.selfpb-pill.active { background: #e0f2fe; border-color: #2b5fb0; color: #0c4a6e; }

.selfpb-time {
  font-variant-numeric: tabular-nums;
  font-family: monospace;
}

/* Range sliders adapted for light bg */
.selfpb-range {
  -webkit-appearance: none; appearance: none;
  height: 4px; background: #e5e7eb; border-radius: 999px;
  outline: none; width: 160px;
}
.selfpb-range::-webkit-slider-thumb {
  -webkit-appearance: none; appearance: none;
  width: 16px; height: 16px; border-radius: 999px;
  background: var(--sp-accent); border: 2px solid #fff;
  box-shadow: 0 1px 3px rgba(0,0,0,0.2);
  cursor: pointer;
}

@media (max-width: 560px) {
  .selfpb-panel { width: min(96vw, 520px); }
  .selfpb-row { gap: 6px; }
}
</file>

<file path="features/features/selfpb-peekaboo.css">
/* Self-Playback “Peekaboo” Panel (top-left) */

:root {
  --lux-sp-panel-w: 360px;
  --lux-sp-panel-max-w: min(92vw, 380px);
  --lux-sp-panel-max-h: min(520px, 70vh);

  --lux-sp-radius: 14px;
  --lux-sp-shadow: 0 10px 30px rgba(0, 0, 0, 0.15);
  --lux-sp-border: 1px solid rgba(0, 0, 0, 0.08);

  /* Tab visuals */
  --lux-sp-tab-h: 34px;
  --lux-sp-tab-protrude: 140px; 
  --lux-sp-tab-peek: 44px; /* The "Edge" that sticks out */

  --lux-sp-tab-bg: #2d6cdf;
  --lux-sp-tab-bg-hover: #2457b1;
  --lux-sp-tab-ink: #fff;
}

:root{
  --lux-drawer-dur: 440ms;
  --lux-tab-dur: 420ms;
  --lux-arrow-dur: 420ms;
  --lux-arrow-delay: 90ms;

  --lux-ease-drawer: cubic-bezier(0.18, 0.9, 0.2, 1);
  --lux-ease-pop: cubic-bezier(0.18, 1.25, 0.2, 1);
}

/* ───────────────── Panel ───────────────── */
.lux-sp-panel {
  position: fixed;
  inset: env(safe-area-inset-top, 0) auto auto env(safe-area-inset-left, 0);
  z-index: var(--z-drawer); /* Treaty Compliant */

  width: var(--lux-sp-panel-w);
  max-width: var(--lux-sp-panel-max-w);
  height: auto;
  max-height: var(--lux-sp-panel-max-h);

  /* LIGHT THEME BACKGROUND */
  background: #ffffff;
  color: #333333;
  
  border: var(--lux-sp-border);
  border-left: 0;
  border-top-right-radius: var(--lux-sp-radius);
  border-bottom-right-radius: var(--lux-sp-radius);
  box-shadow: var(--lux-sp-shadow);

  overflow: visible;

  /* Closed State: Tucked left, but leaving 'peek' pixels visible */
  transform: translate3d(calc(-100% + var(--lux-sp-tab-peek)), 0, 0);
  transition: transform var(--lux-drawer-dur) var(--lux-ease-drawer);
}

/* Open State */
.lux-sp-open .lux-sp-panel {
  transform: translate3d(0, 0, 0);
}

/* Body Wrapper */
.lux-sp-body {
  padding: calc(var(--lux-sp-tab-h) + 10px) 6px 6px 6px;
  box-sizing: border-box;
  
  /* FORCE HEIGHT: Matches open state (~280px) */
  min-height: 280px; 
}

/* === GHOST FILLER BOX (Light Mode) === */
.lux-sp-body:empty {
  display: block;
  margin: 4px;
  border-radius: 8px;
  
  /* Subtle grey pulse for light background */
  background: rgba(0, 0, 0, 0.03);
  border: 1px dashed rgba(0, 0, 0, 0.1);
  
  animation: spGhostPulse 2s infinite ease-in-out;
}

@keyframes spGhostPulse {
  0% { opacity: 0.4; }
  50% { opacity: 0.8; }
  100% { opacity: 0.4; }
}

/* Internal Host Scrolling */
.lux-sp-panel #selfpb-lite {
  position: static !important;
  height: auto !important;
  min-height: 0 !important;
  max-height: calc(var(--lux-sp-panel-max-h) - var(--lux-sp-tab-h) - 16px) !important;
  overflow: auto !important;
}

/* ───────────────── Tab ───────────────── */
.lux-sp-tab {
  position: absolute;
  top: 6px;
  left: 6px;
  width: calc(100% + var(--lux-sp-tab-protrude));
  height: var(--lux-sp-tab-h);

  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 10px;

  padding: 0 16px;
  border: 0;
  border-radius: 999px;
  background: var(--lux-sp-tab-bg);
  color: var(--lux-sp-tab-ink);
  font: 600 14px/1 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
  box-shadow: 0 6px 18px rgba(13, 17, 23, 0.15); /* Softer shadow for light theme */
  cursor: pointer;
  user-select: none;
  z-index: 2;
}

/* Keep label visible when the tab is “peeking” (panel closed) */
.lux-sp-tab {
  overflow: hidden; /* important for the inner slide */
}

.lux-sp-tab-inner{
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  width: 100%;
  white-space: nowrap;
  transition: transform var(--lux-tab-dur) var(--lux-ease-pop);
  will-change: transform;
  box-sizing: border-box;
  padding: 0 18px;            /* NEW: keeps icon/text away from hard edge */
}

/* OPEN => centered */
html.lux-sp-open .lux-sp-tab-inner { transform: translateX(0); }

/* CLOSED => shift content toward the visible side (right side of the peeking tab) */
html:not(.lux-sp-open) .lux-sp-tab-inner { transform: translateX(calc(44% - 22px)); }

.lux-sp-tab:hover {
  background: var(--lux-sp-tab-bg-hover);
}
.lux-sp-tab:focus-visible {
  outline: 2px solid #93c5fd;
  outline-offset: 2px;
}

.lux-sp-tab-label {
  pointer-events: none;
}
.lux-sp-tab-icon{
  display: inline-block;
  will-change: transform;
  transform-origin: 50% 50%;
}

@keyframes luxSPArrowOpen {
  0%   { transform: rotate(180deg); }
  60%  { transform: rotate(-40deg); }  /* tiny overshoot */
  100% { transform: rotate(0deg); }
}
@keyframes luxSPArrowClose {
  0%   { transform: rotate(0deg); }
  60%  { transform: rotate(220deg); }  /* tiny overshoot */
  100% { transform: rotate(180deg); }
}

/* Left-side drawer:
   CLOSED = ▶ (180deg), OPEN = ◀ (0deg) */
html.lux-sp-open .lux-sp-tab-icon{
  transform: rotate(0deg);
  animation: luxSPArrowOpen var(--lux-arrow-dur) var(--lux-ease-pop) both;
  animation-delay: var(--lux-arrow-delay);
}
html:not(.lux-sp-open) .lux-sp-tab-icon{
  transform: rotate(180deg);
  animation: luxSPArrowClose var(--lux-arrow-dur) var(--lux-ease-pop) both;
  animation-delay: var(--lux-arrow-delay);
}

@media (max-width: 560px) {
  :root {
    --lux-sp-panel-w: 92vw;
    --lux-sp-panel-max-w: 92vw;
    --lux-sp-panel-max-h: min(82vh, 640px);
    --lux-sp-tab-protrude: 88px;
  }
}

@media print {
  .lux-sp-panel, .lux-sp-tab { display: none !important; }
}

@media (prefers-reduced-motion: reduce){
  .lux-tts-panel, .lux-sp-panel,
  .lux-tts-tab-inner, .lux-sp-tab-inner{
    transition: none !important;
  }
  .lux-tts-tab-icon, .lux-sp-tab-icon{
    animation: none !important;
  }
}
</file>

<file path="features/features/selfpb/core.js">
// features/features/selfpb/core.js
// Core: audio engine, AB loop, rate persistence, reference handling, public API

if (window.LuxSelfPB?.__mounted) {
  console.warn("[self-pb] already mounted, aborting second mount");
  throw new Error("self-pb double mount");
}
window.LuxSelfPB = Object.assign(window.LuxSelfPB || {}, { __mounted: true });

const LS_RATE = "selfpb_rate_v1";
const clamp = (n, a, b) => Math.max(a, Math.min(b, n));
const fmt = (t) => {
  if (!isFinite(t) || t < 0) t = 0;
  const m = Math.floor(t / 60);
  const s = Math.floor(t % 60)
    .toString()
    .padStart(2, "0");
  return `${m}:${s}`;
};

function ensureLearnerAudioEl() {
  let audio = document.getElementById("playbackAudio");
  if (!audio) {
    audio = document.createElement("audio");
    audio.id = "playbackAudio";
    audio.hidden = true;
    document.body.appendChild(audio);
  }
  return audio;
}

export function initSelfPBCore() {
  // learner audio (controls the actual playback used across the app)
  const audio = ensureLearnerAudioEl();

  // reference audio (from TTS)
  const refAudio = new Audio();
  refAudio.preload = "auto";
  let refMeta = null;

  // state
  const st = {
    a: null,
    b: null,
    looping: false,
    playing: false,
    scrubbing: false, // UI toggles this while dragging
  };

  // init rate from storage
  const savedRate = Number(localStorage.getItem(LS_RATE) || "1") || 1;
  audio.playbackRate = clamp(savedRate, 0.5, 1.5);

  // AB loop enforcement on timeupdate
  function onTimeUpdate() {
    if (st.looping && st.a != null && st.b != null && st.b > st.a) {
      if (audio.currentTime >= st.b) {
        audio.currentTime = Math.max(st.a, st.a + 0.01);
        if (audio.paused) audio.play().catch(() => {});
      }
    }
  }
  audio.addEventListener("timeupdate", onTimeUpdate);

  // Public API (DOM-free)
  const api = {
    // UI calls this while dragging → prevents programmatic scrub from fighting slider
    _setScrubbingOn() {
      st.scrubbing = true;
    },
    _setScrubbingOff() {
      st.scrubbing = false;
    },
    getState() {
      return st;
    },
    getAudio() {
      return audio;
    },
    getRefAudio() {
      return refAudio;
    },
    getRefMeta() {
      return refMeta;
    },

    setAB(a, b) {
      st.a = a;
      st.b = b;
    },
    clearAB() {
      st.a = st.b = null;
      st.looping = false;
    },
    setRate(v) {
      audio.playbackRate = clamp(v, 0.5, 1.5);
      localStorage.setItem(LS_RATE, String(audio.playbackRate));
    },
    setRefRate(v) {
      refAudio.playbackRate = clamp(Number(v) || 1, 0.5, 1.5);
      if (window.LuxSelfPB_REF)
        window.LuxSelfPB_REF.playbackRate = refAudio.playbackRate;
    },
    setReference({ url, audioEl, meta } = {}) {
      try {
        if (audioEl instanceof HTMLAudioElement) {
          refAudio.srcObject = null;
          refAudio.src = audioEl.src || "";
          refAudio.playbackRate = audioEl.playbackRate || 1;
        } else if (typeof url === "string" && url) {
          refAudio.srcObject = null;
          refAudio.src = url;
        }
        refMeta = meta || null;
        window.LuxSelfPB_REF = {
          url: refAudio.src || null,
          meta: refMeta,
          playbackRate: refAudio.playbackRate || 1,
        };
      } catch (e) {
        console.warn("[selfpb] setReference failed:", e);
      }
    },
    
    // ✅ CRITICAL FIX: BREAK THE LOOP & FIX MEMORY LEAK
    async setLearnerArrayBuffer(arrBuf) {
      try {
        // 1. Cleanup old memory if we tracked it
        if (window.LuxSelfPB_LastUrl) {
            URL.revokeObjectURL(window.LuxSelfPB_LastUrl);
        }

        // 2. STOP THE LOOP:
        // We do NOT set audio.src here. The main recorder logic (recording.js/index.html) 
        // has already set the source. Setting it again causes the 'loadeddata' event 
        // to fire again, which calls this function again -> Infinite Loop.
        
        console.log("[selfpb] Learner buffer received (Loop guarded).");
        
        // We just ensure the audio is ready to play if needed, 
        // but we trust the existing src.
        if (!audio.src) {
             const blob = new Blob([arrBuf], { type: "audio/mpeg" });
             const url = URL.createObjectURL(blob);
             window.LuxSelfPB_LastUrl = url;
             audio.src = url;
             await audio.load?.();
        }
        
      } catch (e) {
        console.warn("[selfpb] setLearnerArrayBuffer failed:", e);
      }
    },
    
    async play() {
      try {
        await audio.play();
      } catch {}
      st.playing = !audio.paused;
    },
    pause() {
      try {
        audio.pause();
      } catch {}
      st.playing = false;
    },

    // helpers for UI
    fmt,
    clamp,
    persistRate(v) {
      localStorage.setItem(LS_RATE, String(clamp(v, 0.5, 1.5)));
    },
  };

  // expose API (back-compat)
  window.LuxSelfPB = Object.assign(window.LuxSelfPB || {}, api);

  return { api, audio, refAudio, st };
}
</file>

<file path="features/features/selfpb/dom.js">
// features/features/selfpb/dom.js
// ✅ VERBATIM extraction of buildUI() from features/features/selfpb/ui.GOLD
// Only change: export added at bottom

function buildUI() {
  const host = document.createElement("div");
  host.id = "selfpb-lite";

  host.innerHTML = `
    <div class="row" style="margin-bottom:6px; position:relative;">
      <span
        id="spb-toast"
        class="pill tiny"
        style="display:none; position:absolute; right:0; top:0; ...color:#fff; z-index:10; box-shadow: 0 2px 10px rgba(0,0,0,0.5);"
      ></span>

      <button id="spb-expand" class="spb-miniBtn" title="Expand Self Playback">
        Expand
      </button>

      <div class="spacer"></div>
      <span class="pill tiny" id="spb-ref">Ref: —</span>
      <span class="pill tiny" id="spb-time">0:00 / 0:00</span>
    </div>

    <div class="spb-body">

      <!-- wave -->
      <div id="spb-wavebox" class="spb-wavebox">
        <div id="spb-waveform-container">
          <div id="spb-wave-learner"></div>
        </div>
      </div>

      <!-- karaoke -->
      <div id="spb-karaokeWrap">
        <div class="spb-karaokeTitle">Words</div>

        <div id="spb-karaokeLaneWrap">
          <div id="spb-karaokeCursor"></div>
          <div id="spb-karaokeLane"></div>
        </div>

        <div id="spb-kCenterWrap">
          <div id="spb-kCenterTrack"></div>
        </div>
      </div>

      <!-- scrub -->
      <div class="row spb-row" style="margin-top:10px;">
        <input id="spb-scrub" class="spb-scrub" type="range" min="0" max="1000" value="0" />
      </div>

      <!-- controls -->
      <div class="row spb-row" style="margin-top:10px; justify-content:space-between;">
        <div class="row" style="gap:8px;">
          <button class="btn" id="spb-main" disabled>Play</button>
          <button class="btn gray" id="spb-back">-2s</button>
          <button class="btn gray" id="spb-fwd">+2s</button>
        </div>

        <div class="row" style="gap:8px;">
          <span class="mini-label">Rate</span>
          <input id="spb-rate" type="range" min="0.5" max="1.25" step="0.05" value="1" style="width:120px;" />
          <span class="mini-label" id="spb-rate-val">1.00×</span>
        </div>
      </div>

      <!-- loop -->
      <div class="row spb-row" id="spb-loop-row" style="margin-top:10px; justify-content:space-between;">
        <div class="row" style="gap:8px;">
          <button class="btn gray" id="spb-loop-action">Set Loop A</button>
          <span class="ghost-note" id="spb-loop-tip">Tip: highlight a word to loop</span>
        </div>

        <div class="row" style="gap:8px;">
          <span class="mini-label" id="spb-loop-slot"></span>
          <span class="mini-label" id="spb-ab-label">Loop: Off</span>
        </div>
      </div>

      <!-- ref wave -->
      <div id="spb-wave-ref" style="margin-top:10px;"></div>

      <!-- download + trash -->
      <div class="row spb-row" style="margin-top:10px; justify-content:flex-end; gap:8px;">
        <button class="btn ic" id="spb-dl" disabled title="Download latest recording">⬇</button>
        <button class="btn ic red" id="spb-trash" disabled title="Delete recording">🗑</button>
      </div>
    </div>
  `;

  document.body.appendChild(host);

  // ✅ Expanded floating window (create once)
  let float = document.getElementById("spb-float");
  if (!float) {
    float = document.createElement("div");
    float.id = "spb-float";
    float.innerHTML = `
      <div id="spb-floatCard">
        <div id="spb-floatTop">
          <div id="spb-floatTitle">Self Playback — Expanded</div>
          <button id="spb-floatClose" type="button">✕</button>
        </div>
        <div id="spb-floatMount"></div>
      </div>
    `;
    document.body.appendChild(float);
  }

  // expanded wiring
  const floatHead = float.querySelector("#spb-floatTop");
  const floatClose = float.querySelector("#spb-floatClose");
  const floatMount = float.querySelector("#spb-floatMount");

  const expandBtn = host.querySelector("#spb-expand");
  const body = host.querySelector(".spb-body");
  const bodyHome = body.parentElement;
  let bodyNext = body.nextSibling;

  const loopLabel = host.querySelector("#spb-ab-label");
  const loopRow = host.querySelector("#spb-loop-row");
  const loopSlot = host.querySelector("#spb-loop-slot");

  function openExpanded() {
    bodyNext = body.nextSibling; // ✅ re-capture in case DOM changes
    float.classList.add("is-open");
    floatMount.appendChild(body);

    // move Loop label into speed row slot (expanded only)
    if (loopSlot && loopLabel) loopSlot.appendChild(loopLabel);

    // show karaoke block in expanded only
    const kw = host.querySelector("#spb-karaokeWrap");
    if (kw) kw.style.display = "block";

    window.dispatchEvent(new CustomEvent("lux:selfpbExpandedOpen"));
  }

  function closeExpanded() {
    float.classList.remove("is-open");
    if (bodyNext) bodyHome.insertBefore(body, bodyNext);
    else bodyHome.appendChild(body);

    // move Loop label back where it lives in compact
    if (loopRow && loopLabel) loopRow.appendChild(loopLabel);

    const kw = host.querySelector("#spb-karaokeWrap");
    if (kw) kw.style.display = "none";
  }

  expandBtn.addEventListener("click", () => {
    if (float.classList.contains("is-open")) closeExpanded();
    else openExpanded();
  });

  floatClose?.addEventListener("click", closeExpanded);

  // ✅ Drag floating expanded window
  let dragOn = false;
  let dragOffX = 0;
  let dragOffY = 0;

  floatHead.addEventListener("pointerdown", (e) => {
    // prevent dragging when clicking the close button
    if (e.target && e.target.id === "spb-floatClose") return;

    dragOn = true;
    const r = float.getBoundingClientRect();

    // convert from centered transform layout -> absolute
    float.style.alignItems = "flex-start";
    float.style.justifyContent = "flex-start";
    float.style.padding = "0";
    float.style.background = "rgba(0,0,0,0.42)";

    // card becomes absolute
    const card = float.querySelector("#spb-floatCard");
    card.style.position = "absolute";
    card.style.left = `${r.left}px`;
    card.style.top = `${r.top}px`;

    dragOffX = e.clientX - r.left;
    dragOffY = e.clientY - r.top;

    float.setPointerCapture(e.pointerId);
  });

  float.addEventListener("pointermove", (e) => {
    if (!dragOn) return;
    const card = float.querySelector("#spb-floatCard");

    let x = e.clientX - dragOffX;
    let y = e.clientY - dragOffY;

    // clamp to viewport
    const vw = window.innerWidth;
    const vh = window.innerHeight;
    const cr = card.getBoundingClientRect();

    x = Math.max(0, Math.min(vw - cr.width, x));
    y = Math.max(0, Math.min(vh - cr.height, y));

    card.style.left = `${x}px`;
    card.style.top = `${y}px`;
  });

  float.addEventListener("pointerup", (e) => {
    dragOn = false;
    try { float.releasePointerCapture(e.pointerId); } catch(e) {}
  });

  return {
    host,
    toast: host.querySelector("#spb-toast"),
    mainBtn: host.querySelector("#spb-main"),
    dlBtn: host.querySelector("#spb-dl"),
    backBtn: host.querySelector("#spb-back"),
    fwdBtn: host.querySelector("#spb-fwd"),
    scrub: host.querySelector("#spb-scrub"),
    rate: host.querySelector("#spb-rate"),
    rateVal: host.querySelector("#spb-rate-val"),
    timeLab: host.querySelector("#spb-time"),
    loopAction: host.querySelector("#spb-loop-action"),
    loopTip: host.querySelector("#spb-loop-tip"),
    abLabel: host.querySelector("#spb-ab-label"),
    refLabel: host.querySelector("#spb-ref"),
    waveLearner: host.querySelector("#spb-wave-learner"),
    waveRef: host.querySelector("#spb-wave-ref"),
    karaokeWrap: host.querySelector("#spb-karaokeWrap"),
    karaokeLaneWrap: host.querySelector("#spb-karaokeLaneWrap"),
    karaokeLane: host.querySelector("#spb-karaokeLane"),
    karaokeCursor: host.querySelector("#spb-karaokeCursor"),
    kCenterWrap: host.querySelector("#spb-kCenterWrap"),
    kCenterTrack: host.querySelector("#spb-kCenterTrack"),
  };
}

export { buildUI };
</file>

<file path="features/features/selfpb/styles.js">
// features/features/selfpb/styles.js
// ✅ VERBATIM extraction of ensureStyles() from features/features/selfpb/ui.GOLD
// Only change: export added at bottom

function ensureStyles() {
  const STYLE_ID = "selfpb-lite-style";
  if (document.getElementById(STYLE_ID)) return;

  const s = document.createElement("style");
  s.id = STYLE_ID;

  s.textContent = `
    /* Light Theme + Layout Styles */

    #selfpb-lite{
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
      width: 100%;
      max-width: 700px;
      margin: 10px auto;
      padding: 12px;
      border-radius: 14px;
      background: rgba(255,255,255,0.92);
      border: 1px solid rgba(0,0,0,0.08);
      box-shadow: 0 8px 28px rgba(0,0,0,0.08);
    }

    #selfpb-lite .row{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }

    #selfpb-lite .col{
      display:flex;
      flex-direction:column;
      gap:8px;
      width:100%;
    }

    #selfpb-lite .pill{
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding:6px 10px;
      border-radius:999px;
      font-size:12px;
      line-height:1;
      background: rgba(0,0,0,0.06);
      color:#111;
    }

    #selfpb-lite .pill.tiny{
      font-size:11px;
      padding:5px 9px;
    }

    #selfpb-lite .btn{
      padding:6px 10px;
      border-radius:8px;
      border:0;
      background:#2d6cdf;
      color:#fff;
      cursor:pointer;
      transition:background 0.15s, transform 0.1s;
    }

    #selfpb-lite .btn:hover{filter:brightness(1.1);}
    #selfpb-lite .btn:active{transform:scale(0.96);}
    #selfpb-lite .btn[disabled]{opacity:.5;cursor:not-allowed}

    #selfpb-lite .btn.ic{
      width:34px;
      height:34px;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      border-radius:10px;
      padding:0;
      background: rgba(45,108,223,0.12);
      color:#2d6cdf;
    }

    #selfpb-lite .btn.ic:hover{
      background: rgba(45,108,223,0.18);
    }

    #selfpb-lite .btn.ic svg{
      width:18px;height:18px;
    }

    #selfpb-lite .btn.gray{
      background: rgba(0,0,0,0.08);
      color:#111;
    }

    #selfpb-lite .btn.gray:hover{
      background: rgba(0,0,0,0.11);
    }

    #selfpb-lite .btn.red{
      background:#ef4444;
    }

    #selfpb-lite .btn.red:hover{
      filter:brightness(1.08);
    }

    #selfpb-lite .wave-wrap{
      display:flex;
      flex-direction:column;
      gap:8px;
      padding:10px;
      border-radius:12px;
      background: rgba(0,0,0,0.03);
      border: 1px solid rgba(0,0,0,0.06);
    }

    #selfpb-lite .wave-title{
      font-size:12px;
      font-weight:600;
      opacity:0.85;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }

    #selfpb-lite .wave{
      width:100%;
      height:56px;
      border-radius:10px;
      background: rgba(255,255,255,0.85);
      border: 1px solid rgba(0,0,0,0.06);
      overflow:hidden;
      position:relative;
    }

    #selfpb-lite .wave canvas{
      width:100%;
      height:100%;
      display:block;
    }

    #selfpb-lite .timebar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      font-size:12px;
      opacity:0.9;
      margin-top:4px;
    }

    #selfpb-lite .scrub{
      width:100%;
      height:10px;
      appearance:none;
      background: rgba(0,0,0,0.08);
      border-radius:999px;
      outline:none;
      cursor:pointer;
    }

    #selfpb-lite .scrub::-webkit-slider-thumb{
      appearance:none;
      width:18px;height:18px;
      border-radius:50%;
      background:#2d6cdf;
      border: 2px solid rgba(255,255,255,0.9);
      box-shadow: 0 4px 12px rgba(45,108,223,0.3);
    }

    #selfpb-lite .mini-label{
      font-size:11px;
      opacity:0.7;
    }

    #selfpb-lite .section{
      margin-top:10px;
      padding-top:10px;
      border-top:1px solid rgba(0,0,0,0.06);
    }

    #selfpb-lite .split{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
    }

    #selfpb-lite .split > *{
      flex:1;
      min-width: 240px;
    }

    #selfpb-lite .ghost-note{
      font-size:11px;
      opacity:0.65;
    }

    /* Expanded overlay */
    #spb-expandedOverlay{
      position: fixed;
      inset: 0;
      display:none;
      align-items:center;
      justify-content:center;
      background: rgba(0,0,0,0.42);
      z-index: 9999;
      padding: 18px;
    }

    #spb-expandedOverlay.is-open{
      display:flex;
    }

    #spb-expandedCard{
      width: min(980px, 96vw);
      max-height: 92vh;
      overflow:auto;
      border-radius: 18px;
      background: rgba(255,255,255,0.96);
      border: 1px solid rgba(255,255,255,0.35);
      box-shadow: 0 24px 80px rgba(0,0,0,0.35);
      padding: 14px 14px 16px;
    }

    #spb-expandedCard .topRow{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom:10px;
    }

    #spb-expandedCard .topRow .title{
      font-size:13px;
      font-weight:700;
      opacity:0.85;
    }

    #spb-expandedCard .closeBtn{
      width:34px;
      height:34px;
      border-radius:12px;
      border:0;
      cursor:pointer;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      background: rgba(0,0,0,0.06);
    }

    #spb-expandedCard .closeBtn:hover{
      background: rgba(0,0,0,0.09);
    }

    /* Karaoke line (expanded only) */
    #spb-karaokeWrap{
      display:none;
      margin-top: 10px;
      padding: 10px;
      border-radius: 12px;
      background: rgba(0,0,0,0.03);
      border: 1px solid rgba(0,0,0,0.06);
    }

    #spb-expandedCard #spb-karaokeWrap{
      display:block;
    }

    #spb-karaokeWrap .spb-karaokeTitle{
      font-size: 12px;
      font-weight: 700;
      opacity: 0.8;
      margin-bottom: 6px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }

    #spb-karaoke{
      display:flex;
      flex-wrap:wrap;
      gap:6px;
      align-items:center;
    }

    .spb-kword{
      font-size: 12px;
      padding: 5px 8px;
      border-radius: 999px;
      background: rgba(0,0,0,0.06);
      border: 1px solid rgba(0,0,0,0.06);
      opacity: 0.85;
      transition: transform 0.12s, background 0.12s, opacity 0.12s;
      user-select:none;
    }

    .spb-kword.is-active{
      background: rgba(45,108,223,0.18);
      border-color: rgba(45,108,223,0.25);
      opacity: 1;
      transform: translateY(-1px);
    }

    /* Center karaoke line (expanded) */
    #spb-karaokeCenter{
      display:flex;
      flex-wrap:wrap;
      gap:6px;
      align-items:center;
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px solid rgba(0,0,0,0.06);
    }

    .spb-ckword{
      font-size: 12px;
      padding: 5px 8px;
      border-radius: 999px;
      background: rgba(0,0,0,0.06);
      border: 1px solid rgba(0,0,0,0.06);
      opacity: 0.85;
      transition: transform 0.12s, background 0.12s, opacity 0.12s;
      user-select:none;
    }

    .spb-ckword.is-active{
      background: rgba(45,108,223,0.18);
      border-color: rgba(45,108,223,0.25);
      opacity: 1;
      transform: translateY(-1px);
    }

    /* ✅ (from GOLD) show karaoke in expanded float too */
    #spb-float #spb-karaokeWrap{
      display:block;
    }
  `;

  document.head.appendChild(s);
}

export { ensureStyles };
</file>

<file path="features/features/selfpb/ui-GOLD.js">
// features/features/selfpb/ui.js
// FINAL PIVOT: Using WaveSurfer.js for reliable waveforms.

import { initSelfPBCore } from "./core.js";
import { initWaveSurfer } from "./waveform-logic.js";

function ensureStyles() {
  const STYLE_ID = "selfpb-lite-style";
  if (document.getElementById(STYLE_ID)) return;

  const s = document.createElement("style");
  s.id = STYLE_ID;

  s.textContent = `
    /* Light Theme + Layout Styles */

    /* ✅ OUTER bezel: always hugs inner width perfectly */
    #selfpb-lite{
      position: fixed;
      top: 12px;
      left: 12px;
      z-index: 9999;

      /* 🔒 lock inner width into a variable so outer can wrap it */
      --spbW: min(390px, calc(100vw - 48px));

      width: calc(var(--spbW) + 24px);  /* ✅ inner + bezel */
      max-width: calc(100vw - 24px);

      padding: 10px 14px 14px 10px;     /* bezel (extra right/bottom) */
      border-radius: 18px;

      /* ✅ make bezel visible */
      background: rgba(15,23,42,0.06);
      border: 1px solid rgba(15,23,42,0.10);
      box-shadow: 0 10px 26px rgba(0,0,0,0.22);

      box-sizing: border-box;
      overflow: visible; /* ✅ don’t clip the bezel */
    }

    #selfpb-lite *{ box-sizing:border-box; }

    /* ✅ INNER panel always matches spbW */
    #selfpb-lite .spb-body{
      width: var(--spbW);
      background: #fff;
      border-radius: 16px;
      padding: 12px;
      overflow: hidden;
    }

    #selfpb-lite .row{
      display:flex;
      align-items:center;
      gap:8px;
      min-width:0;
    }

    #selfpb-lite .scrubFull{
      width:100%;
      min-width:0;
    }

    #selfpb-lite .btn{
      padding:6px 10px;
      border-radius:8px;
      border:0;
      background:#2d6cdf;
      color:#fff;
      cursor:pointer;
      transition:background 0.15s, transform 0.1s;
    }

    #selfpb-lite .btn:hover{filter:brightness(1.1);}
    #selfpb-lite .btn:active{transform:scale(0.96);}
    #selfpb-lite .btn[disabled]{opacity:.5;cursor:not-allowed}

    #selfpb-lite .btn.icon{
      width:44px;
      padding:6px 0;
      display:grid;
      place-items:center;
    }

    #selfpb-lite .pill{border-radius:999px;padding:6px 10px}
    #selfpb-lite .meta{opacity:.85}

    :is(#selfpb-lite, #spb-float) input[type="range"]{accent-color:#2d6cdf}

    #selfpb-lite .ab{display:flex;gap:6px;position:relative;}
    #selfpb-lite .tiny{font-weight:700;opacity:.8}

    /* Layout Fixes */
    #selfpb-lite .spacer{flex:1}
    #spb-main { width: 110px; font-weight: 800; font-size: 1.05em; flex-shrink: 0; }
    #spb-loop-action { min-width: 100px; background: #e0e7ff; color: #3730a3; border: 1px solid #c7d2fe; }
    #spb-loop-action.active { background: #4338ca; color: #fff; border-color: #312e81; }

    /* Floating "Coach Mark" Bubble */
    .spb-bubble {
      position: absolute;
      top: -38px;
      left: 0;
      background: rgba(0,0,0,0.85);
      color: #fff;
      padding: 4px 8px;
      border-radius: 6px;
      font-size: 11px;
      white-space: nowrap;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.4s;
    }
    .spb-bubble.visible { opacity: 1; }
    .spb-bubble::after {
      content: '';
      position: absolute;
      bottom: -4px;
      left: 16px;
      border-left: 4px solid transparent;
      border-right: 4px solid transparent;
      border-top: 4px solid rgba(0,0,0,0.85);
    }

    /* ✅ In expanded mode, body fills floating card */
    #spb-float .spb-body{
      width: 100% !important;
    }

    /* ✅ Prevent waveform/canvas from forcing overflow */
    :is(#selfpb-lite, #spb-float) canvas,
    :is(#selfpb-lite, #spb-float) .spb-wave,
    :is(#selfpb-lite, #spb-float) #spb-wavebox{
      max-width: 100% !important;
    }

    :is(#selfpb-lite, #spb-float) .spb-wave{
      height:92px;
      border-radius:12px;
      background: rgba(15,23,42,0.04);
      border:1px solid rgba(15,23,42,0.10);
      overflow:hidden;
      display:flex;
      align-items:center;
      justify-content:center;
    }

    /* rows */
    :is(#selfpb-lite, #spb-float) .spb-row{
      display:flex;
      align-items:center;
      gap:10px;
      min-width:0;
      width:100%;
    }

    :is(#selfpb-lite, #spb-float) .spb-row + .spb-row{ margin-top:8px; }

    :is(#selfpb-lite, #spb-float) .spb-scrub{
      width:100%;
      min-width:0;
    }

    :is(#selfpb-lite, #spb-float) .spb-btn{
      border:0;
      border-radius:10px;
      padding:8px 12px;
      font-weight:800;
      cursor:pointer;
      background:#2f6fe4;
      color:#fff;
      box-shadow:0 6px 16px rgba(0,0,0,0.12);
      white-space:nowrap;
    }

    :is(#selfpb-lite, #spb-float) .spb-btn.secondary{
      background: rgba(15,23,42,0.08);
      color: rgba(15,23,42,0.85);
      box-shadow:none;
    }

    :is(#selfpb-lite, #spb-float) .spb-btn.icon{
      width:44px;
      display:grid;
      place-items:center;
      padding:8px 0;
    }

    /* ✅ Download arrow matches TTS (blue link-style) */
    #selfpb-lite #spb-dl{
      background: transparent !important;
      box-shadow: none !important;
      border: 0 !important;

      color: #0078d7 !important;   /* ✅ same as .tts-link */
      font-size: 1.8rem;
      line-height: 1;
      padding: 6px 10px;
    }

    #selfpb-lite #spb-dl:hover{
      filter: brightness(0.9);
    }

    /* ✅ Scrubber: looks like a real timeline */
    :is(#selfpb-lite, #spb-float) #spb-scrub{
      -webkit-appearance: none;
      appearance: none;
      height: 18px;
    }

    :is(#selfpb-lite, #spb-float) #spb-scrub::-webkit-slider-runnable-track{
      height: 10px;
      border-radius: 999px;
      background: rgba(15,23,42,0.14);
    }

    :is(#selfpb-lite, #spb-float) #spb-scrub::-webkit-slider-thumb{
      -webkit-appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: #2f6fe4;
      border: 2px solid #fff;
      margin-top: -4px;
      box-shadow: 0 6px 14px rgba(0,0,0,0.18);
    }

    /* ✅ Speed stays slimmer + quieter */
    :is(#selfpb-lite, #spb-float) #spb-rate::-webkit-slider-runnable-track{
      height: 6px;
      border-radius: 999px;
      background: rgba(15,23,42,0.10);
    }
    :is(#selfpb-lite, #spb-float) #spb-rate::-webkit-slider-thumb{
      -webkit-appearance:none;
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: rgba(15,23,42,0.60);
      margin-top: -4px;
    }

    /* bottom row: -2s ⬇ +2s */
    :is(#selfpb-lite, #spb-float) .spb-bottom{
      justify-content:space-between;
    }

    /* ✅ Expand button (header) */
    #selfpb-lite .spb-miniBtn{
      border: 0;
      border-radius: 999px;
      padding: 6px 10px;
      font-weight: 900;
      cursor: pointer;
      background: rgba(255,255,255,0.22);
      color: rgba(15,23,42,0.85);
      transition: transform .12s ease, filter .12s ease;
    }

    #selfpb-lite .spb-miniBtn:hover{
      transform: scale(1.10);  /* ✅ “big bulge” hover */
      filter: brightness(1.12);
    }

    /* ✅ Floating expanded window (non-modal) */
    #spb-float{
      position: fixed;
      z-index: 200000;
      display: none;

      width: min(920px, calc(100vw - 40px));
      max-height: min(720px, calc(100vh - 40px));

      left: 50%;
      top: 90px;
      transform: translateX(-50%);

      border-radius: 22px;
      background: rgba(255,255,255,0.96);
      border: 1px solid rgba(15,23,42,0.12);
      box-shadow: 0 18px 52px rgba(0,0,0,0.30);
      overflow: hidden;
    }

    #spb-float.is-open{ display:block; }

    #spb-floatHead{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding: 10px 12px;
      font-weight: 900;
      cursor: grab;            /* ✅ draggable */
      user-select: none;
      background: rgba(15,23,42,0.04);
    }

    #spb-floatHead:active{ cursor: grabbing; }

    #spb-floatMount{
      padding: 12px;
    }

    /* ✅ bigger waveform in expanded mode */
    #spb-float #spb-wavebox{
      height: 240px;
    }

    /* ✅ expanded mode: speed slider not absurdly wide */
    #spb-float #spb-rate{
      max-width: 320px;
    }

    /* ============================================================
       ✅ Expanded-only Karaoke Timeline
       ============================================================ */

    #spb-karaokeWrap{
      display:none; /* ✅ hidden in small drawer */
      margin-top: 10px;
    }

    #spb-karaokeWrap .spb-karaokeTitle{
      font-weight: 900;
      font-size: 12px;
      opacity: .70;
      margin: 2px 0 8px;
    }

    /* ============================================================
       ✅ Center Karaoke Strip (Expanded-only)
       ============================================================ */

    #spb-kCenterWrap{
      position: relative;
      height: 46px;
      border-radius: 14px;
      background: rgba(15,23,42,0.04);
      border: 1px solid rgba(15,23,42,0.10);
      overflow: hidden;
      margin-bottom: 10px;
    }

    /* soft fade edges */
    #spb-kCenterWrap::before,
    #spb-kCenterWrap::after{
      content:"";
      position:absolute;
      top:0; bottom:0;
      width: 48px;
      pointer-events:none;
      z-index: 3;
    }
    #spb-kCenterWrap::before{
      left:0;
      background: linear-gradient(90deg, rgba(255,255,255,0.96), rgba(255,255,255,0));
    }
    #spb-kCenterWrap::after{
      right:0;
      background: linear-gradient(270deg, rgba(255,255,255,0.96), rgba(255,255,255,0));
    }

    /* track slides under the fades */
    #spb-kCenterTrack{
      position: absolute;
      left: 0;
      top: 0;
      height: 100%;

      display: flex;
      align-items: center;
      gap: 8px;

      padding: 0 56px; /* room so the centered word can sit under fades */
      will-change: transform;
      transition: transform 260ms ease;
    }

    /* words in strip */
    #spb-kCenterTrack .spbKCWord{
      --p: 0;
      display: inline-flex;
      align-items: center;
      justify-content: center;

      height: 28px;
      padding: 0 12px;
      border-radius: 999px;
      border: 1px solid rgba(15,23,42,0.12);

      font-weight: 900;
      font-size: 12px;
      color: rgba(15,23,42,0.86);

      background:
        linear-gradient(
          90deg,
          rgba(47,111,228,0.22) calc(var(--p) * 100%),
          rgba(255,255,255,0.78) 0
        );

      cursor: pointer;
      transition: transform .10s ease, filter .12s ease, opacity .12s ease;
    }

    #spb-kCenterTrack .spbKCWord:hover{
      transform: scale(1.04);
      filter: brightness(1.04);
    }

    /* Past/future fading */
    #spb-kCenterTrack .spbKCWord.is-past{ opacity: .48; }
    #spb-kCenterTrack .spbKCWord.is-future{ opacity: .72; }

    /* Active pops */
    #spb-kCenterTrack .spbKCWord.is-active{
      opacity: 1;
      transform: scale(1.08);
      border-color: rgba(47,111,228,0.40);
      box-shadow: 0 12px 22px rgba(47,111,228,0.14);
    }

    /* Low accuracy */
    #spb-kCenterTrack .spbKCWord.is-bad{
      border-color: rgba(220,38,38,0.35);
      box-shadow: 0 12px 22px rgba(220,38,38,0.14);
      background:
        linear-gradient(
          90deg,
          rgba(220,38,38,0.18) calc(var(--p) * 100%),
          rgba(255,255,255,0.78) 0
        );
    }

    /* ✅ lane wrapper (timeline) */
    #spb-karaokeLaneWrap{
      position: relative;
      border-radius: 14px;
      background: rgba(15,23,42,0.04);
      border: 1px solid rgba(15,23,42,0.10);
      height: 76px;          /* JS can expand this if we need multiple rows */
      overflow: hidden;
      cursor: pointer;
    }

    /* subtle center “timeline rail” */
    #spb-karaokeLaneWrap::before{
      content:"";
      position:absolute;
      left:10px; right:10px;
      top: 38px;
      height: 2px;
      border-radius: 999px;
      background: rgba(15,23,42,0.10);
    }

    /* holds absolute-positioned words */
    #spb-karaokeLane{
      position:absolute;
      inset: 8px 8px 8px 8px;
    }

    /* playback cursor */
    #spb-karaokeCursor{
      position:absolute;
      top: 8px;
      bottom: 8px;
      width: 2px;
      left: 0%;
      transform: translateX(-1px);
      background: rgba(47,111,228,0.55);
      border-radius: 999px;
      pointer-events: none;
    }

    /* each word pill */
    #spb-karaokeLane .spbKWord{
      --p: 0;
      position:absolute;
      height: 24px;
      padding: 0 10px;
      border-radius: 999px;

      border: 1px solid rgba(15,23,42,0.12);
      background:
        linear-gradient(
          90deg,
          rgba(47,111,228,0.22) calc(var(--p) * 100%),
          rgba(255,255,255,0.72) 0
        );

      font-weight: 900;
      font-size: 12px;
      color: rgba(15,23,42,0.86);

      display:flex;
      align-items:center;
      justify-content:center;

      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;

      cursor: pointer;
      transition: transform .08s ease, filter .12s ease;
    }

    #spb-karaokeLane .spbKWord:hover{
      transform: scale(1.03);
      filter: brightness(1.04);
    }

    #spb-karaokeLane .spbKWord.is-active{
      border-color: rgba(47,111,228,0.40);
      box-shadow: 0 10px 18px rgba(47,111,228,0.14);
    }

    /* ✅ error glow if word accuracy is low */
    #spb-karaokeLane .spbKWord.is-bad{
      border-color: rgba(220,38,38,0.35);
      box-shadow: 0 10px 20px rgba(220,38,38,0.14);
      background:
        linear-gradient(
          90deg,
          rgba(220,38,38,0.18) calc(var(--p) * 100%),
          rgba(255,255,255,0.72) 0
        );
    }

    /* ✅ great words get a soft “good glow” */
    #spb-karaokeLane .spbKWord.is-great{
      border-color: rgba(47,111,228,0.30);
      box-shadow: 0 10px 20px rgba(47,111,228,0.12);
    }

    /* ✅ show karaoke ONLY inside Expanded containers */
    #spb-modalCard #spb-karaokeWrap,
    #spb-float #spb-karaokeWrap{
      display:block;
    }
  `;

  document.head.appendChild(s);
}

function buildUI() {
  const host = document.createElement("div");
  host.id = "selfpb-lite";

  host.innerHTML = `
    <div class="row" style="margin-bottom:6px; position:relative;">
      <span
        id="spb-toast"
        class="pill tiny"
        style="display:none; position:absolute; right:0; top:0; background:#ef4444; border-color:#b91c1c; color:#fff; z-index:10; box-shadow: 0 2px 10px rgba(0,0,0,0.5);"
      ></span>

      <button id="spb-expand" class="spb-miniBtn" title="Expand Self Playback">
        Expand
      </button>

      <div class="spacer"></div>
      <span class="pill tiny" id="spb-ref">Ref: —</span>
      <span class="pill tiny" id="spb-time">0:00 / 0:00</span>
    </div>

    <div class="spb-body">

      <!-- ✅ Wave box (top) -->
      <div class="spb-wave" id="spb-wavebox">
        <div id="spb-waveform-container" style="width:100%; height:100%; display:flex; flex-direction:column;">
          <div id="spb-wave-learner" style="height: 50%; width: 100%;"></div>
          <div id="spb-wave-ref" style="height: 50%; width: 100%; border-top: 1px solid #eee;"></div>
        </div>
      </div>

      <!-- ✅ Expanded-only Karaoke Timeline -->
      <div id="spb-karaokeWrap">
        <div class="spb-karaokeTitle">Word Sync</div>

        <!-- ✅ CENTER karaoke strip -->
        <div id="spb-kCenterWrap" title="Karaoke strip • Click a word to seek">
          <div id="spb-kCenterTrack"></div>
        </div>

        <!-- ✅ Timeline lane -->
        <div id="spb-karaokeLaneWrap" title="Click a word to seek • Click the lane to jump">
          <div id="spb-karaokeLane"></div>
          <div id="spb-karaokeCursor"></div>
        </div>
      </div>

      <!-- ✅ Scrubber row -->
      <div class="spb-row">
        <input id="spb-scrub" class="spb-scrub" type="range" min="0" max="1000" step="1" value="0" title="Seek">
      </div>

      <!-- ✅ Speed row -->
      <div class="spb-row">
        <div style="min-width:54px; font-weight:800; opacity:.75;">Speed</div>
        <input id="spb-rate" type="range" min="0.5" max="1.5" step="0.05" value="1" style="flex:1; min-width:0;">
        <div id="spb-rate-val" style="min-width:54px; text-align:right; font-weight:900;">1.00×</div>
        <div id="spb-loop-slot" style="min-width:110px; text-align:right; font-weight:900; opacity:.75;"></div>
      </div>

      <!-- ✅ Loop status text -->
      <div class="spb-row" id="spb-loop-row">
        <div id="spb-ab-label" style="font-weight:800; opacity:.75;">Loop: Off</div>
      </div>

      <!-- ✅ Play + Set Loop row -->
      <div class="spb-row">
        <button class="spb-btn" id="spb-main" style="flex:1; min-width:0;">▶ Play</button>
        <div class="ab" style="flex:1; min-width:0; display:flex; justify-content:flex-end; position:relative;">
          <div id="spb-loop-tip" class="spb-bubble">Tap <b>A</b> then <b>B</b> to loop.</div>
          <button class="spb-btn" id="spb-loop-action" style="flex:1; min-width:0;">⟳ Set Loop A</button>
        </div>
      </div>

      <!-- ✅ Bottommost row: -2s  ⬇  +2s -->
      <div class="spb-row spb-bottom">
        <button class="spb-btn" id="spb-back">−2s</button>
        <button class="spb-btn secondary icon" id="spb-dl" type="button" disabled title="Record something first">⬇</button>
        <button class="spb-btn" id="spb-fwd">+2s</button>
      </div>

    </div>
  `;

  document.body.appendChild(host);

  // ✅ Expanded floating window (create once)
  let float = document.getElementById("spb-float");
  if (!float) {
    float = document.createElement("div");
    float.id = "spb-float";
    float.innerHTML = `
      <div id="spb-floatHead">
        <div>Self Playback (Expanded)</div>
        <button id="spb-floatClose" class="spb-btn secondary icon" title="Close">✕</button>
      </div>
      <div id="spb-floatMount"></div>
    `;
    document.body.appendChild(float);
  }

  const floatHead = float.querySelector("#spb-floatHead");
  const floatClose = float.querySelector("#spb-floatClose");
  const floatMount = float.querySelector("#spb-floatMount");

  const expandBtn = host.querySelector("#spb-expand");
  const body = host.querySelector(".spb-body");
  const bodyHome = body.parentElement;
  let bodyNext = body.nextSibling;

  const loopLabel = host.querySelector("#spb-ab-label");
  const loopRow = host.querySelector("#spb-loop-row");
  const loopSlot = host.querySelector("#spb-loop-slot");

  function openExpanded() {
    bodyNext = body.nextSibling; // ✅ re-capture in case DOM changes
    float.classList.add("is-open");
    floatMount.appendChild(body);

    // move Loop label into speed row slot (expanded only)
    if (loopSlot && loopLabel) loopSlot.appendChild(loopLabel);
    if (loopRow) loopRow.style.display = "none";

    // ✅ Karaoke refresh hook
    try {
      window.dispatchEvent(new CustomEvent("lux:selfpbExpandedOpen"));
    } catch {}
  }

  function closeExpanded() {
    float.classList.remove("is-open");
    bodyHome.insertBefore(body, bodyNext || null);

    // put Loop label back into its normal row
    if (loopRow && loopLabel) loopRow.appendChild(loopLabel);
    if (loopRow) loopRow.style.display = "";
  }

  expandBtn?.addEventListener("click", openExpanded);
  floatClose?.addEventListener("click", closeExpanded);

  // ✅ Drag floating expanded window
  let dragOn = false;
  let dragOffX = 0;
  let dragOffY = 0;

  floatHead.addEventListener("pointerdown", (e) => {
    // prevent dragging when clicking the close button
    if (e.target && e.target.id === "spb-floatClose") return;

    dragOn = true;
    const r = float.getBoundingClientRect();

    // convert from centered transform layout -> absolute px positioning
    float.style.transform = "none";
    float.style.left = r.left + "px";
    float.style.top = r.top + "px";

    dragOffX = e.clientX - r.left;
    dragOffY = e.clientY - r.top;

    floatHead.setPointerCapture(e.pointerId);
  });

  floatHead.addEventListener("pointermove", (e) => {
    if (!dragOn) return;
    float.style.left = e.clientX - dragOffX + "px";
    float.style.top = e.clientY - dragOffY + "px";
  });

  floatHead.addEventListener("pointerup", () => {
    dragOn = false;
  });

  return {
    host,
    toast: host.querySelector("#spb-toast"),
    mainBtn: host.querySelector("#spb-main"),
    dlBtn: host.querySelector("#spb-dl"),
    backBtn: host.querySelector("#spb-back"),
    fwdBtn: host.querySelector("#spb-fwd"),
    scrub: host.querySelector("#spb-scrub"),
    rate: host.querySelector("#spb-rate"),
    rateVal: host.querySelector("#spb-rate-val"),
    timeLab: host.querySelector("#spb-time"),
    loopAction: host.querySelector("#spb-loop-action"),
    loopTip: host.querySelector("#spb-loop-tip"),
    abLabel: host.querySelector("#spb-ab-label"),
    refLabel: host.querySelector("#spb-ref"),
    // Containers
    waveLearner: host.querySelector("#spb-wave-learner"),
    waveRef: host.querySelector("#spb-wave-ref"),
    karaokeWrap: host.querySelector("#spb-karaokeWrap"),
    karaokeLaneWrap: host.querySelector("#spb-karaokeLaneWrap"),
    karaokeLane: host.querySelector("#spb-karaokeLane"),
    karaokeCursor: host.querySelector("#spb-karaokeCursor"),
    kCenterWrap: host.querySelector("#spb-kCenterWrap"),
    kCenterTrack: host.querySelector("#spb-kCenterTrack"),
  };
}

export function mountSelfPlaybackLite() {
  const { api, audio, refAudio, st } = initSelfPBCore();

  ensureStyles();
  const ui = buildUI();

  // Initialize WaveSurfer
  initWaveSurfer({
    learnerContainer: ui.waveLearner,
    refContainer: ui.waveRef,
    masterAudio: audio,
  });

  // ✅ Download Latest Recording button wiring
  const dlBtn = ui.dlBtn;
  let _lastBlob = null;
  let _lastMeta = null;

  function extFromBlob(blob) {
    const t = blob?.type || "";
    if (t.includes("wav")) return "wav";
    if (t.includes("webm")) return "webm";
    if (t.includes("ogg")) return "ogg";
    return "audio";
  }

  function downloadBlob(blob, meta) {
    if (!blob) return;

    const mode = (meta?.mode || "normal").toLowerCase();
    const ts = new Date(meta?.ts || Date.now())
      .toISOString()
      .replaceAll(":", "-")
      .replaceAll(".", "-");

    const ext = extFromBlob(blob);
    const name = `lux-recording_${mode}_${ts}.${ext}`;

    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = name;
    document.body.appendChild(a);
    a.click();
    a.remove();

    setTimeout(() => URL.revokeObjectURL(url), 1500);
  }

  function setLatest(blob, meta) {
    _lastBlob = blob || null;
    _lastMeta = meta || null;

    if (dlBtn) {
      dlBtn.disabled = !_lastBlob;
      dlBtn.title = _lastBlob
        ? "Download your latest recording"
        : "Record something first";
    }
  }

  if (dlBtn) {
    dlBtn.addEventListener("click", () => {
      if (!_lastBlob) return;
      downloadBlob(_lastBlob, _lastMeta);
    });
  }

  // Pull from global if it exists already
  if (window.LuxLastRecordingBlob) {
    setLatest(window.LuxLastRecordingBlob, window.LuxLastRecordingMeta || null);
  }

  // Listen for new recordings
  window.addEventListener("lux:lastRecording", (e) => {
    setLatest(e?.detail?.blob, e?.detail?.meta || null);
  });

  // --- Logic helpers ---
  const showToast = (msg, duration = 2000) => {
    ui.toast.textContent = msg;
    ui.toast.style.display = "inline-block";
    ui.host.animate(
      [
        { transform: "translateX(0)" },
        { transform: "translateX(-4px)" },
        { transform: "translateX(4px)" },
        { transform: "translateX(0)" },
      ],
      { duration: 200 }
    );
    setTimeout(() => {
      ui.toast.style.display = "none";
    }, duration);
  };

  const showLoopHint = () => {
    if (localStorage.getItem("spb-hint-seen") !== "true") {
      ui.loopTip.classList.add("visible");
      setTimeout(() => {
        ui.loopTip.classList.remove("visible");
        localStorage.setItem("spb-hint-seen", "true");
      }, 4000);
    }
  };

  const syncButtons = () => {
    ui.mainBtn.textContent = st.playing ? "⏸ Pause" : "▶ Play";

    if (st.a == null) {
      ui.loopAction.textContent = "⟳ Set Loop A";
      ui.loopAction.classList.remove("active");
      ui.abLabel.textContent = "Loop: Off";
    } else if (st.b == null) {
      ui.loopAction.textContent = "⟳ Set Loop B";
      ui.loopAction.classList.add("active");
      ui.abLabel.textContent = `A: ${api.fmt(st.a)} …`;
    } else {
      ui.loopAction.textContent = "× Clear Loop";
      ui.loopAction.classList.remove("active");
      ui.abLabel.textContent = `A: ${api.fmt(st.a)}  B: ${api.fmt(st.b)}`;
    }
  };

  const syncTime = () => {
    ui.timeLab.textContent = `${api.fmt(audio.currentTime || 0)} / ${api.fmt(
      audio.duration || 0
    )}`;
  };

  const syncScrub = () => {
    if (!st.scrubbing) {
      const dur = audio.duration || 0;
      const p = dur ? Math.floor((audio.currentTime / dur) * 1000) : 0;
      ui.scrub.value = String(api.clamp(p, 0, 1000));
    }
  };

  /* ============================================================
     ✅ Karaoke Timeline (Expanded-only)
     - words are positioned across time
     - fill + active highlight during playback
     - click word = seek
     - click lane = jump to time
     ============================================================ */

  let kWords = [];
  let kEls = [];
  let kDur = 0;
  let kLinesUsed = 1;

  let kCenterEls = [];
  let _centerActiveIdx = -1;

  const isExpandedOpen = () => {
    const shade = document.getElementById("spb-modalShade");
    if (shade?.classList?.contains("is-open")) return true;

    const float = document.getElementById("spb-float");
    if (float?.classList?.contains("is-open")) return true;

    return false;
  };

  const clamp01 = (v) => Math.max(0, Math.min(1, v));

  function getKaraokeDuration(words) {
    const ad = audio.duration || 0;
    if (ad > 0) return ad;
    const last = words?.[words.length - 1];
    return last?.end || 0;
  }

  function seekTo(sec) {
    if (!isFinite(sec)) return;
    const dur = audio.duration || kDur || 0;
    if (!dur) return;

    audio.currentTime = api.clamp(sec, 0, dur);
    syncTime();
    syncScrub();
  }

  function renderKaraokeCenter(words) {
    if (!ui.kCenterTrack) return;

    ui.kCenterTrack.innerHTML = "";
    kCenterEls = [];

    for (let i = 0; i < words.length; i++) {
      const w = words[i];

      const el = document.createElement("span");
      el.className = "spbKCWord";
      el.textContent = w.word;

      if (typeof w.acc === "number" && w.acc < 60) el.classList.add("is-bad");

      el.style.setProperty("--p", "0");

      el.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        seekTo((w.start || 0) + 0.001);
      });

      ui.kCenterTrack.appendChild(el);
      kCenterEls.push(el);
    }

    // center at current time initially
    _centerActiveIdx = -1;
    updateKaraokeCenterAt(audio.currentTime || 0);
  }

  function centerToWord(idx) {
    if (!ui.kCenterWrap || !ui.kCenterTrack) return;
    const el = kCenterEls[idx];
    if (!el) return;

    const wrapW = ui.kCenterWrap.clientWidth;
    const trackW = ui.kCenterTrack.scrollWidth;

    if (trackW <= wrapW) {
      // center whole track if short
      const mid = (wrapW - trackW) / 2;
      ui.kCenterTrack.style.transform = `translateX(${mid}px)`;
      return;
    }

    const wordCenter = el.offsetLeft + el.offsetWidth / 2;
    let target = wrapW / 2 - wordCenter;

    const min = wrapW - trackW; // most negative
    const max = 0;

    if (target < min) target = min;
    if (target > max) target = max;

    ui.kCenterTrack.style.transform = `translateX(${target}px)`;
  }

  function updateKaraokeCenterAt(t) {
    if (!kWords.length || !kCenterEls.length) return;

    let activeIdx = -1;

    for (let i = 0; i < kWords.length; i++) {
      const w = kWords[i];
      const el = kCenterEls[i];
      if (!el) continue;

      const span = Math.max(0.001, w.end - w.start);
      const p = clamp01((t - w.start) / span);
      el.style.setProperty("--p", String(p));

      if (t >= w.start && t < w.end) activeIdx = i;
    }

    for (let i = 0; i < kCenterEls.length; i++) {
      const el = kCenterEls[i];
      el.classList.toggle("is-active", i === activeIdx);
      el.classList.toggle("is-past", activeIdx !== -1 && i < activeIdx);
      el.classList.toggle("is-future", activeIdx !== -1 && i > activeIdx);
    }

    // smooth auto-center only when active word changes
    if (activeIdx !== -1 && activeIdx !== _centerActiveIdx) {
      _centerActiveIdx = activeIdx;
      centerToWord(activeIdx);
    }
  }

  function renderKaraoke(words) {
    if (!ui.karaokeLane || !ui.karaokeLaneWrap) return;

    ui.karaokeLane.innerHTML = "";
    kEls = [];

    kWords = Array.isArray(words) ? words : [];
    kDur = getKaraokeDuration(kWords);

    for (let i = 0; i < kWords.length; i++) {
      const w = kWords[i];

      const el = document.createElement("button");
      el.type = "button";
      el.className = "spbKWord";
      el.textContent = w.word;
      el.title = `${w.word} • ${w.start.toFixed(2)}s → ${w.end.toFixed(2)}s`;

      if (typeof w.acc === "number") {
        if (w.acc < 60) el.classList.add("is-bad");
        if (w.acc >= 90) el.classList.add("is-great");
      }

      el.style.setProperty("--p", "0");

      el.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();

        // keep play state; just move time
        seekTo((w.start || 0) + 0.001);
      });

      ui.karaokeLane.appendChild(el);
      kEls.push(el);
    }

    layoutKaraoke();
    updateKaraokeAt(audio.currentTime || 0);
    renderKaraokeCenter(kWords);
  }

  function layoutKaraoke() {
    if (!ui.karaokeLaneWrap || !ui.karaokeLane) return;
    if (!kWords.length || !kEls.length) return;

    const wrap = ui.karaokeLaneWrap;
    const lane = ui.karaokeLane;

    const W = wrap.clientWidth - 16; // inset padding
    if (W <= 10) return;

    const dur = kDur || audio.duration || 0;
    if (!dur) return;

    const ROW_H = 26;
    const GAP = 8;
    const MAX_LINES = 3;

    const lineEnds = new Array(MAX_LINES).fill(0);
    let maxLine = 0;

    for (let i = 0; i < kWords.length; i++) {
      const w = kWords[i];
      const el = kEls[i];
      if (!el) continue;

      const startP = clamp01(w.start / dur);
      const endP = clamp01(w.end / dur);

      let x = startP * W;
      let ww = Math.max(28, (endP - startP) * W); // min width

      // pick a line that doesn't overlap
      let line = 0;
      while (line < MAX_LINES && x < (lineEnds[line] + GAP)) line++;
      if (line >= MAX_LINES) line = MAX_LINES - 1;

      lineEnds[line] = x + ww;
      maxLine = Math.max(maxLine, line);

      el.style.left = `${8 + x}px`;
      el.style.top = `${8 + line * ROW_H}px`;
      el.style.width = `${ww}px`;
    }

    kLinesUsed = maxLine + 1;
    wrap.style.height = `${Math.max(76, 16 + kLinesUsed * ROW_H)}px`;
  }

  function updateKaraokeAt(t) {
    if (!ui.karaokeCursor || !kWords.length || !kEls.length) return;

    const dur = kDur || audio.duration || 0;
    if (!dur) return;

    // cursor
    const pct = clamp01(t / dur) * 100;
    ui.karaokeCursor.style.left = `${pct}%`;

    // word fill + active
    let active = -1;

    for (let i = 0; i < kWords.length; i++) {
      const w = kWords[i];
      const el = kEls[i];
      if (!el) continue;

      const span = Math.max(0.001, w.end - w.start);
      const p = clamp01((t - w.start) / span);
      el.style.setProperty("--p", String(p));

      if (t >= w.start && t < w.end) active = i;
    }

    for (let i = 0; i < kEls.length; i++) {
      kEls[i].classList.toggle("is-active", i === active);
    }
  }

  // click lane (empty space) to jump
  ui.karaokeLaneWrap?.addEventListener("click", (e) => {
    if (!isExpandedOpen()) return;
    const dur = kDur || audio.duration || 0;
    if (!dur) return;

    const r = ui.karaokeLaneWrap.getBoundingClientRect();
    const p = clamp01((e.clientX - r.left) / Math.max(1, r.width));
    seekTo(p * dur);
  });

  // refresh on expanded open
  window.addEventListener("lux:selfpbExpandedOpen", () => {
    const words = window.LuxLastWordTimings || [];
    renderKaraoke(words);
  });

  // refresh when a new assessment comes in (even if expanded is already open)
  window.addEventListener("lux:lastAssessment", (e) => {
    const words = e?.detail?.timings || window.LuxLastWordTimings || [];
    if (isExpandedOpen()) renderKaraoke(words);
  });

  // keep layout stable on resize
  window.addEventListener("resize", () => {
    if (!isExpandedOpen()) return;
    layoutKaraoke();

    if (isExpandedOpen() && _centerActiveIdx !== -1) centerToWord(_centerActiveIdx);
  });

  const syncRateUI = () => {
    ui.rateVal.textContent = `${Number(audio.playbackRate).toFixed(2)}×`;
    ui.rate.value = String(audio.playbackRate || 1);
  };

  const syncRefUI = () => {
    const ready = !!refAudio.src;
    const r = refAudio.playbackRate || 1;
    const d = isFinite(refAudio.duration) ? api.fmt(refAudio.duration) : "—:—";
    const meta = api.getRefMeta();
    const v = meta && (meta.voice || meta.style) ? ` ${meta.voice || ""}` : "";
    ui.refLabel.textContent = ready ? `Ref: ${r.toFixed(2)}× · ${d}${v}` : "Ref: —";
  };

  const handlePlayAction = async (isRestart = false) => {
    if (!audio.currentSrc && !audio.src) {
      showToast("No recording yet!");
      return;
    }
    if (audio.duration === 0 || isNaN(audio.duration)) {
      showToast("Audio empty/loading...");
      return;
    }

    try {
      if (isRestart) {
        audio.currentTime = st.looping && st.a != null ? st.a : 0;
        if (!st.playing) await api.play();
      } else {
        if (st.playing) {
          api.pause();
        } else {
          if (st.looping && st.a != null && st.b != null && st.b > st.a) {
            if (audio.currentTime < st.a || audio.currentTime > st.b)
              audio.currentTime = st.a;
          }
          await api.play();
        }
      }
    } catch (err) {
      console.warn("[selfpb] Play failed", err);
      showToast("Playback failed");
    } finally {
      syncButtons();
    }
  };

  const handleLoopClick = () => {
    if (!audio.duration) {
      showToast("No audio to loop!");
      return;
    }

    if (st.a == null) {
      st.a = audio.currentTime || 0;
      st.looping = false;
      showLoopHint();
    } else if (st.b == null) {
      st.b = audio.currentTime || 0;
      if (st.b < st.a) {
        const t = st.a;
        st.a = st.b;
        st.b = t;
      }
      st.looping = true;
      audio.currentTime = st.a;
      if (!st.playing) api.play();
    } else {
      api.clearAB();
    }

    syncButtons();
  };

  ui.mainBtn.addEventListener("click", (e) => {
    if (e.detail !== 2) handlePlayAction(false);
  });

  ui.mainBtn.addEventListener("dblclick", (e) => {
    e.preventDefault();
    handlePlayAction(true);
  });

  // 2.0 seconds skip
  ui.backBtn.addEventListener("click", () => {
    audio.currentTime = api.clamp(
      (audio.currentTime || 0) - 2.0,
      0,
      audio.duration || 0
    );
    syncTime();
    syncScrub();
  });

  ui.fwdBtn.addEventListener("click", () => {
    audio.currentTime = api.clamp(
      (audio.currentTime || 0) + 2.0,
      0,
      audio.duration || 0
    );
    syncTime();
    syncScrub();
  });

  // ✅ If user grabs scrubber while playing -> PAUSE (pro behavior)
  ui.scrub.addEventListener("pointerdown", () => {
    if (!audio.paused) {
      audio.pause();
    }
  });

  ui.scrub.addEventListener("input", () => {
    api._setScrubbingOn();
    const p = Number(ui.scrub.value) / 1000;
    audio.currentTime = api.clamp(p * (audio.duration || 0), 0, audio.duration || 0);
    syncTime();

    if (isExpandedOpen()) updateKaraokeAt(audio.currentTime || 0);
    if (isExpandedOpen()) updateKaraokeCenterAt(audio.currentTime || 0);
  });

  ui.scrub.addEventListener("change", () => api._setScrubbingOff());

  ui.rate.addEventListener("input", () => {
    const v = api.clamp(Number(ui.rate.value) || 1, 0.5, 1.5);
    api.setRate(v);
    syncRateUI();
  });

  ui.loopAction.addEventListener("click", handleLoopClick);

  audio.addEventListener("timeupdate", () => {
    syncTime();
    syncScrub();
    if (isExpandedOpen()) updateKaraokeAt(audio.currentTime || 0);
    if (isExpandedOpen()) updateKaraokeCenterAt(audio.currentTime || 0);
  });
  audio.addEventListener("play", () => {
    st.playing = true;
    syncButtons();
  });
  audio.addEventListener("pause", () => {
    st.playing = false;
    syncButtons();
  });
  audio.addEventListener("loadedmetadata", () => {
    syncTime();
    syncScrub();
  });
  audio.addEventListener("ratechange", syncRateUI);
  audio.addEventListener("ended", () => {
    st.playing = false;
    syncButtons();
  });

  refAudio.addEventListener("loadedmetadata", syncRefUI);
  refAudio.addEventListener("ratechange", syncRefUI);

  // Shortcuts logic (unchanged)
  window.addEventListener(
    "keydown",
    (e) => {
      if (
        e.target.tagName === "INPUT" ||
        e.target.tagName === "TEXTAREA" ||
        e.target.isContentEditable
      )
        return;

      if (e.code === "Space") {
        e.preventDefault();
        ui.mainBtn.click();
      } else if (e.key === ",") {
        e.preventDefault();
        ui.backBtn.click();
      } else if (e.key === ".") {
        e.preventDefault();
        ui.fwdBtn.click();
      } else if (e.key === "[") {
        e.preventDefault();
        api.setRate(api.clamp((audio.playbackRate || 1) - 0.05, 0.5, 1.5));
        syncRateUI();
      } else if (e.key === "]") {
        e.preventDefault();
        api.setRate(api.clamp((audio.playbackRate || 1) + 0.05, 0.5, 1.5));
        syncRateUI();
      } else if (e.key.toLowerCase() === "l") {
        e.preventDefault();
        ui.loopAction.click();
      }
    },
    { passive: false }
  );

  initialSync();
  window.LuxSelfPB = Object.assign(window.LuxSelfPB || {}, { el: ui.host });
  console.info("[self-pb] WaveSurfer UI Mounted");

  function initialSync() {
    syncTime();
    syncScrub();
    syncButtons();
    syncRefUI();
  }
}

export { mountSelfPlaybackLite as default };
</file>

<file path="features/features/selfpb/waveform-logic.js">
// features/features/selfpb/waveform-logic.js
// WRAPPER: Uses WaveSurfer.js to guarantee "Mountain" waveforms.

let wsLearner = null;
let wsRef = null;
let mainAudioEl = null;

export function initWaveSurfer({ learnerContainer, refContainer, masterAudio }) {
    if (!window.WaveSurfer) {
        console.warn("[Waveform] WaveSurfer.js not loaded. Check index.html.");
        return;
    }

    mainAudioEl = masterAudio;

    // 1. Learner Instance (Blue)
    wsLearner = WaveSurfer.create({
        container: learnerContainer,
        waveColor: '#2d6cdf',
        progressColor: '#ef4444',
        cursorColor: '#ef4444', // Red cursor
        cursorWidth: 2,
        height: 50,
        barWidth: 3,
        barGap: 1,
        barRadius: 3,
        normalize: true, 
        interact: false, 
        fillParent: true
    });

    // 2. Reference Instance (Gray) -> NOW WITH CURSOR
    wsRef = WaveSurfer.create({
        container: refContainer,
        waveColor: '#9ca3af',
        progressColor: '#4b5563',
        cursorColor: '#ef4444', // ADDED: Red cursor (matches learner)
        cursorWidth: 2,         // ADDED: Visible width
        height: 50,
        barWidth: 3,
        barGap: 1,
        barRadius: 3,
        normalize: true,
        interact: false,
        fillParent: true
    });

    // 3. Sync Visualizer to Audio Element
    if (mainAudioEl) {
        mainAudioEl.addEventListener('timeupdate', () => {
            const dur = mainAudioEl.duration;
            if (dur > 0) {
                const progress = mainAudioEl.currentTime / dur;
                if (wsLearner) wsLearner.seekTo(progress);
                if (wsRef) wsRef.seekTo(progress);
            }
        });
    }
    
    console.log("[Waveform] WaveSurfer initialized.");
}

// Pass the raw Blob directly to WaveSurfer
export function loadLearnerBlob(blob) {
    if (wsLearner && blob) {
        console.log("[Waveform] Loading Learner Blob...");
        wsLearner.loadBlob(blob);
    }
}

// Pass the raw Blob directly to WaveSurfer
export function loadReferenceBlob(blob) {
     if (wsRef && blob) {
        console.log("[Waveform] Loading Reference Blob...");
        wsRef.loadBlob(blob);
    }
}
</file>

<file path="features/features/tts.css">
/* Container */
#tts-controls {
  display: flex;
}
#tts-wrap {
  margin-left: auto;
  width: 340px;
  max-width: 95vw;
}

/* Card */
.tts-box {
  border: 1px solid #e5e7eb;
  border-radius: 14px;
  padding: 12px;
  background: #fff;
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.04);
  width: 100%;
}

.tts-compact {
  display: flex !important;
  flex-direction: column !important;
  align-items: center !important;
  gap: 12px !important;
}

.tts-compact > * {
  width: 100%;
  display: flex !important;
  justify-content: center !important;
}

/* Head / note */
.tts-title {
  font-weight: 700;
}
.tts-head {
  width: 100%;
  display: flex;
  flex-direction: column;
  gap: 4px;
}
.tts-note {
  font-size: 0.9rem;
  color: #374151;
  min-height: 1em;
}
.tts-note--warn {
  color: #b45309;
}

/* Inputs */
.tts-voice select,
.tts-style-grid select,
.tts-style-grid input[type="number"] {
  padding: 6px 8px;
  border: 1px solid #d1d5db;
  border-radius: 8px;
  background: #fff;
  font: inherit;
}

.tts-speed {
  gap: 6px;
  align-items: center;
}
#tts-speed {
  width: 100%;
  cursor: pointer;
}
#tts-speed-out {
  min-width: 3.5ch;
  text-align: right;
}

/* Style row */
.tts-style-row {
  width: 100%;
}
.tts-style-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px;
}
.tts-style-grid label {
  display: flex;
  flex-direction: column;
  font-size: 0.95rem;
  gap: 4px;
}

/* Main button */
.tts-btn {
  padding: 10px 14px;
  border-radius: 10px;
  border: 1px solid #d1d5db;
  background: #0078d7;
  color: #fff;
  cursor: pointer;
  transition: filter 0.15s, transform 0.12s, box-shadow 0.15s;
  font: inherit;
}
.tts-btn:hover {
  filter: brightness(0.92);
}
.tts-btn:active {
  transform: translateY(1px);
}
.tts-btn--primary {
  font-weight: 700;
}

/* Pitch slider — placed under main button */
.tts-pitch {
  width: 100%;
  align-items: center;
  gap: 8px;
  margin-top: 8px; /* space below main button */
  margin-bottom: 8px; /* space above skip buttons */
}
#tts-pitch {
  flex: 1;
  cursor: pointer;
}
#tts-pitch-out {
  width: 2.5ch;
  text-align: right;
}

/* Skip buttons row */
#tts-main {
  margin-bottom: 0;
}
.tts-skip {
  gap: 12px;
  display: flex;
  justify-content: center;
}
.tts-btn--sm {
  padding: 7px 12px;
  font-size: 0.95rem;
  border-radius: 9px;
}

/* Download link */
.tts-link {
  text-decoration: none;
  font-size: 1.8rem;
  line-height: 1;
  color: #0078d7;
}
.tts-link:hover {
  filter: brightness(0.9);
}

/* Misc legacy */
.tts-row {
  display: flex;
  gap: 8px;
  align-items: center;
  flex-wrap: wrap;
}
.tts-controls {
  margin-top: 8px;
}
.tts-text {
  width: 100%;
  min-height: 64px;
  padding: 10px 12px;
  border: 1px solid #d1d5db;
  border-radius: 10px;
  font-size: 15px;
  resize: vertical;
}

/* Focus states */
.tts-btn:focus-visible,
.tts-voice select:focus-visible,
.tts-style-grid select:focus-visible,
.tts-style-grid input[type="number"]:focus-visible,
#tts-speed:focus-visible,
#tts-pitch:focus-visible,
.tts-link:focus-visible {
  outline: 2px solid #2563eb;
  outline-offset: 2px;
}

/* Reduced motion */
@media (prefers-reduced-motion: reduce) {
  .tts-btn {
    transition: none;
  }
}

/* Responsive */
@media (max-width: 420px) {
  .tts-style-grid {
    grid-template-columns: 1fr;
  }
  #tts-wrap {
    width: 100%;
  }
}

/* Dark mode */
@media (prefers-color-scheme: dark) {
  .tts-box {
    background: #0b0f14;
    border-color: #1f2937;
    box-shadow: none;
  }
  .tts-voice select,
  .tts-style-grid select,
  .tts-style-grid input[type="number"],
  .tts-text {
    background: #111827;
    color: #e5e7eb;
    border-color: #374151;
  }
  .tts-btn {
    background: #0ea5e9;
    border-color: #0284c7;
  }
  .tts-link {
    color: #38bdf8;
  }
}
/* Hide the host until the panel adopts it to avoid any flash */
#tts-controls[data-luxHidden="1"] {
  display: none !important;
}

/* Once #tts-controls is inside the panel, kill any fixed positioning */
.lux-tts-panel #tts-controls {
  position: static !important;
  inset: auto !important;
  top: auto !important;
  right: auto !important;
  left: auto !important;
  bottom: auto !important;
  float: none !important;
  width: 100% !important;
  margin: 0 !important;
}
</file>

<file path="features/features/tts/player-core.js">
// features/features/tts/player-core.js
// Core: networking, constants, voice caps (no DOM writes)
export const TTS_URL = "https://luxury-language-api.vercel.app/api/tts";

export const VOICES = [
  { id: "en-US-AriaNeural", label: "US — Aria" },
  { id: "en-US-AvaNeural", label: "US — Ava" },
  { id: "en-US-JennyNeural", label: "US — Jenny" },
  { id: "en-US-GuyNeural", label: "US — Guy" },
  { id: "en-US-DavisNeural", label: "US — Davis" },
  { id: "en-US-SaraNeural", label: "US — Sara" },
  { id: "en-US-NancyNeural", label: "US — Nancy" },
  { id: "en-US-MichelleNeural", label: "US — Michelle" },
  { id: "en-US-ChristopherNeural", label: "US — Christopher" },
  { id: "en-US-TonyNeural", label: "US — Tony" },
  { id: "en-US-JennyMultilingualNeural", label: "US — Jenny (Multilingual)" },
  { id: "en-US-EmmaMultilingualNeural", label: "US — Emma (Multilingual)" },
];

export const DEFAULT_SPEED = 1.0;
export const DEFAULT_PITCH_ST = 0;

// ---- Voice capabilities (US-only) ----
export async function getVoiceCaps() {
  try {
    const res = await fetch(`${TTS_URL}?voices=1`);
    if (!res.ok) return {};
    const data = await res.json();
    const out = {};
    for (const v of data.voices || []) {
      if (!String(v.ShortName).startsWith("en-US-")) continue;
      out[v.ShortName] = {
        styles: Array.isArray(v.StyleList) ? v.StyleList : [],
      };
    }
    return out;
  } catch {
    return {};
  }
}

// ---- TTS synthesis (returns Blob with _meta) ----
export async function synthesize(payload) {
  const res = await fetch(TTS_URL, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(payload),
  });
  const hdr = (k) => res.headers.get(k) || "";
  const meta = {
    styleUsed: hdr("X-Style-Used"),
    styleRequested: hdr("X-Style-Requested"),
    fallback: hdr("X-Style-Fallback"),
    message: hdr("X-Style-Message"),
    region: hdr("X-Azure-Region"),
  };
  if (!res.ok) {
    let detail = "";
    try {
      detail = await res.text();
    } catch {}
    const err = new Error(`TTS ${res.status}: ${detail || "synthesis failed"}`);
    err.meta = meta;
    throw err;
  }
  const blob = await res.blob();
  blob._meta = meta;
  return blob;
}
</file>

<file path="features/features/tts/player-dom.js">
// features/features/tts/player-dom.js
// Pure DOM: HTML templates and element selection helpers.

import { VOICES, DEFAULT_SPEED, DEFAULT_PITCH_ST } from "./player-core.js";

// Helper: Scoped query selector
export const $ = (root, sel) => root.querySelector(sel);

// Helper: Get text from input or selection
export function getCurrentText() {
  const el =
    document.querySelector("#referenceText") ||
    document.querySelector("#free-input") ||
    document.querySelector("#reference-text") ||
    document.querySelector("textarea");
  const typed = el?.value?.trim();
  const sel = window.getSelection()?.toString()?.trim();
  return (typed || sel || "").trim();
}

export function populateStyles(styleSel, caps, voiceId) {
  if (!styleSel) return;
  const styles = caps?.[voiceId]?.styles || [];
  const keep = styleSel.value;
  styleSel.innerHTML =
    `<option value="">(neutral)</option>` +
    styles.map((s) => `<option value="${s}">${s}</option>`).join("");
  if (keep && styles.includes(keep)) styleSel.value = keep;
}

export function renderControls(mount) {
  const voiceOptions = VOICES.map(
    (v) => `<option value="${v.id}">${v.label}</option>`
  ).join("");

  mount.innerHTML = `
      <div id="tts-wrap">
        <div class="tts-box tts-compact" style="padding: 10px 12px;">
          <div class="tts-head">
            <div id="tts-note" class="tts-note" aria-live="polite" style="text-align:center; min-height:0;"></div>
          </div>
  
          <label class="tts-voice" style="width:100%; display:flex !important; flex-direction:column !important; align-items:center !important; margin-bottom:4px;">
            <span style="font-weight:700; margin-bottom:2px; font-size:1.05em; color:#333;">Voice</span>
            <select id="tts-voice" style="width:98%; padding:4px; margin:0 auto; display:block;">${voiceOptions}</select>
          </label>
  
          <label class="tts-speed" style="margin-bottom:4px; width:98%;">
            <span style="font-size:0.9em; font-weight:600; color:#444;">Speed</span>
            <input id="tts-speed" type="range" min="0.7" max="1.3" step="0.05" value="${DEFAULT_SPEED}">
            <span id="tts-speed-out" style="font-size:0.9em;">${DEFAULT_SPEED.toFixed(2)}×</span>
          </label>
  
          <label class="tts-style-label" style="width:100%; display:flex !important; flex-direction:column !important; align-items:center !important; margin: 2px 0 6px 0;">
             <span style="font-weight:600; margin-bottom:2px; font-size:0.95em;">Speaking Style</span>
             <select id="tts-style" style="width:98%; padding:4px;"><option value="">(neutral)</option></select>
          </label>

          <div class="tts-mixed-row" style="width:98%; display:flex !important; justify-content:space-between !important; align-items:end; gap:8px; margin-bottom:8px;">
             
             <label class="tts-pitch-col" style="flex:1; display:flex; flex-direction:column; gap:2px;">
                <div style="display:flex; justify-content:space-between; font-size:0.85rem; font-weight:600; color:#444;">
                   <span>Pitch</span>
                   <span id="tts-pitch-out" style="color:#0078d7;">${DEFAULT_PITCH_ST}</span>
                </div>
                <input id="tts-pitch" type="range" min="-12" max="12" step="1" value="${DEFAULT_PITCH_ST}" style="width:100%; cursor:pointer;">
             </label>

             <label class="tts-degree-col" style="width:70px; display:flex; flex-direction:column; gap:2px;">
                <span style="font-size:0.85rem; font-weight:600; color:#444; text-align:center;">Degree</span>
                <input id="tts-styledegree" type="number" min="0.1" max="2.5" step="0.1" value="2.5" style="width:100%; padding:3px; text-align:center; border:1px solid #ccc; border-radius:6px;">
             </label>

          </div>
  
          <button id="tts-main" class="tts-btn tts-btn--primary"
            title="Click: play/pause • Double-click: restart & play" style="width:98%; margin-bottom:8px; padding: 8px;">🔊 Generate & Play</button>
  
          <div class="tts-skip" style="display:flex; justify-content:center; gap:10px; align-items:center;">
            <button id="tts-back" class="tts-btn tts-btn--sm" title="Back 2 seconds">↺ 2s</button>
            
            <a id="tts-download" class="tts-link" href="#" download="lux_tts.mp3" title="Download audio" style="font-size:1.4rem; line-height:1; text-decoration:none;">⬇️</a>
            
            <button id="tts-fwd"  class="tts-btn tts-btn--sm" title="Forward 2 seconds">↻ 2s</button>
          </div>
  
        </div>
      </div>
    `;

  // Apply layout styles immediately
  const box = mount.querySelector(".tts-compact");
  if (box)
    Object.assign(box.style, {
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
    });
}
</file>

<file path="features/features/tts/player-ui.js">
// features/features/tts/player-ui.js
// Logic: Event wiring, audio state management, and API orchestration.
// UPDATED: simplified Waveform handoff (passes Blob directly to WaveSurfer).

import {
  VOICES,
  DEFAULT_SPEED,
  getVoiceCaps,
  synthesize,
} from "./player-core.js";

import {
  $,
  getCurrentText,
  renderControls,
  populateStyles,
} from "./player-dom.js";

// NEW IMPORT: simplified blob loader
import { loadReferenceBlob } from "../selfpb/waveform-logic.js";

const isPlaying = (audio) =>
  !audio.paused && !audio.ended && audio.currentTime > 0;

/* --- ALWAYS-MOVES PATCH: progress render loop --- */
function wireTtsProgress(audioEl, fillEl) {
  if (!audioEl || !fillEl) return () => {};

  let raf = 0;

  const clamp01 = (n) => Math.max(0, Math.min(1, n));

  function paint(pct) {
    // Width-based bar fill (matches most simple progress-fill CSS)
    fillEl.style.width = `${clamp01(pct) * 100}%`;
  }

  function render() {
    const dur = audioEl.duration || 0;
    const t = audioEl.currentTime || 0;
    const pct = dur > 0 ? t / dur : 0;
    paint(pct);
    raf = requestAnimationFrame(render);
  }

  function start() {
    cancelAnimationFrame(raf);
    raf = requestAnimationFrame(render);
  }

  function stop() {
    cancelAnimationFrame(raf);
    raf = 0;
  }

  // Keep it “always moves while playing” via RAF
  audioEl.addEventListener("play", start);
  audioEl.addEventListener("pause", stop);
  audioEl.addEventListener("ended", () => {
    stop();
    paint(1);
  });

  // Also update on timeupdate as a fallback
  audioEl.addEventListener("timeupdate", () => {
    const dur = audioEl.duration || 0;
    const t = audioEl.currentTime || 0;
    const pct = dur > 0 ? t / dur : 0;
    paint(pct);
  });

  // Initial state
  paint(0);

  // Return a tiny cleanup function in case you ever need it later
  return () => stop();
}

export async function mountTTSPlayer(hostEl) {
  const host = hostEl || document.getElementById("tts-controls");
  if (!host) return;

  // --- NUCLEAR FIX START (Visibility Guards) ---
  const guard = document.getElementById("lux-tts-guard-style");
  if (guard) guard.remove();

  host.dataset.luxHidden = "0";
  host.removeAttribute("data-luxHidden");
  host.style.display = "flex";
  host.style.visibility = "visible";
  host.style.opacity = "1";
  // --- NUCLEAR FIX END ---

  // 1. Render the HTML Template
  renderControls(host);

  // 2. Select Elements
  const voiceSel = $(host, "#tts-voice");
  const speedEl = $(host, "#tts-speed");
  const speedOut = $(host, "#tts-speed-out");
  const mainBtn = $(host, "#tts-main");
  const backBtn = $(host, "#tts-back");
  const fwdBtn = $(host, "#tts-fwd");
  const dl = $(host, "#tts-download");
  const note = $(host, "#tts-note");
  const pitchEl = $(host, "#tts-pitch");
  const pitchOut = $(host, "#tts-pitch-out");
  const styleSel = $(host, "#tts-style");
  const degreeEl = $(host, "#tts-styledegree");

  // Progress fill (safe: only wires if found)
  const progressFill =
    host.querySelector("#tts-progress-fill") ||
    host.querySelector(".tts-progress-fill") ||
    host.querySelector(".tts-progress__fill") ||
    host.querySelector("[data-tts-progress-fill]");

  // 3. Initialize Audio
  const audio = new Audio();
  audio.preload = "auto";
  audio.playbackRate = DEFAULT_SPEED;

  // Expose audio for other panels (like Self Playback sync)
  window.luxTTS = Object.assign(window.luxTTS || {}, { audioEl: audio });

  // Wire progress (always moves while playing)
  // (No-op if progressFill not found)
  const stopProgress = wireTtsProgress(audio, progressFill);

  // 4. Load Capabilities (Async)
  let caps = await getVoiceCaps();
  populateStyles(styleSel, caps, voiceSel.value);

  voiceSel.addEventListener("change", () =>
    populateStyles(styleSel, caps, voiceSel.value)
  );

  // 5. Wire Inputs
  const updateSpeedOut = () => {
    const v = Number(speedEl.value) || 1;
    speedOut.textContent = v.toFixed(2) + "×";
    audio.playbackRate = v;
    if (window.LuxSelfPB?.setRefRate) window.LuxSelfPB.setRefRate(v);
  };

  const updatePitchOut = () => {
    const p = Number(pitchEl.value) || 0;
    pitchOut.textContent = String(p);
  };

  updateSpeedOut();
  updatePitchOut();

  speedEl.addEventListener("input", updateSpeedOut);
  pitchEl.addEventListener("input", updatePitchOut);

  // 6. Audio Controls (UPDATED to 2 seconds)
  backBtn.addEventListener("click", () => {
    audio.currentTime = Math.max(0, audio.currentTime - 2);
  });

  fwdBtn.addEventListener("click", () => {
    audio.currentTime = Math.min(audio.duration || Infinity, audio.currentTime + 2);
  });

  // 7. Playback Logic
  function setMainLabel(playing) {
    mainBtn.textContent = playing
      ? "⏸️ Pause (dbl-click = Restart)"
      : "🔊 Generate & Play";
  }

  function uiNote(msg, tone = "info") {
    if (!note) return;
    note.textContent = msg || "";
    note.className = `tts-note ${tone === "warn" ? "tts-note--warn" : ""}`;
  }

  let blobUrl = null;
  let lastKey = null;
  let clickPending = false;
  let dblTriggered = false;

  async function ensureAudioReadyAndPlay() {
    const text = getCurrentText();
    if (!text) return alert("Type or select some text first.");

    const voice = voiceSel?.value || VOICES[0].id;
    const speedMult = Number(speedEl.value) || 1;
    const ratePct = Math.round((speedMult - 1) * 100);
    const style = styleSel?.value || "";
    const styledegree = parseFloat(degreeEl?.value || "1");
    const pitchSt = Number(pitchEl.value) || 0;

    const key = `${voice}|${text}|style:${style}|deg:${styledegree}|rate:${ratePct}|pitch:${pitchSt}`;

    // Reuse existing blob if params match
    if (key === lastKey && audio.src) {
      if (window.LuxSelfPB?.setReference) {
        window.LuxSelfPB.setReference({
          audioEl: audio,
          meta: { voice, style, styledegree, rate: speedMult, ratePct, pitchSt },
        });
      }
      try {
        await audio.play();
        setMainLabel(true);
      } catch {}
      return;
    }

    // Generate New
    try {
      const blob = await synthesize({
        text,
        voice,
        ratePct,
        pitchSt,
        style,
        styledegree,
      });

      if (blob._meta) {
        const { styleUsed, styleRequested, fallback, message } = blob._meta;
        if (message) uiNote(message, fallback ? "warn" : "info");
        else if (fallback)
          uiNote(`Style '${styleRequested}' unsupported. Playing neutral.`, "warn");
        else if (styleUsed && styleUsed !== "neutral")
          uiNote(`Playing ${voice} in '${styleUsed}'.`);
        else uiNote("");
      }

      // Reset progress UI on new audio (optional but nice)
      if (progressFill) progressFill.style.width = "0%";

      if (blobUrl) URL.revokeObjectURL(blobUrl);
      blobUrl = URL.createObjectURL(blob);
      audio.src = blobUrl;
      audio.playbackRate = speedMult;
      lastKey = key;

      if (dl) {
        dl.href = blobUrl;
        dl.download = "lux_tts.mp3";
      }

      // --- WAVEFORM HANDOFF (Simplified) ---
      if (blob) {
        loadReferenceBlob(blob);
      }
      // ------------------------------------

      // Sync with Self Playback
      if (window.LuxSelfPB?.setReference) {
        window.LuxSelfPB.setReference({
          audioEl: audio,
          meta: { voice, style, styledegree, rate: speedMult, ratePct, pitchSt },
        });
      }

      await audio.play();
      setMainLabel(true);
    } catch (e) {
      console.error(e);
      uiNote(e.meta?.message || "Synthesis failed.", "warn");
      alert(e.message || "Text-to-speech failed");
    }
  }

  // Double-click to Restart
  mainBtn.addEventListener("dblclick", async (e) => {
    e.preventDefault();
    dblTriggered = true;
    audio.currentTime = 0;
    if (audio.src) {
      try {
        await audio.play();
        setMainLabel(true);
      } catch {}
    } else {
      await ensureAudioReadyAndPlay();
    }
  });

  // Single-click to Toggle
  mainBtn.addEventListener("click", async (e) => {
    e.preventDefault();
    if (clickPending) return;
    clickPending = true;

    setTimeout(async () => {
      if (!dblTriggered) {
        if (!audio.src || audio.ended) await ensureAudioReadyAndPlay();
        else if (isPlaying(audio)) {
          audio.pause();
          setMainLabel(false);
        } else {
          try {
            await audio.play();
            setMainLabel(true);
          } catch {}
        }
      }
      clickPending = false;
      dblTriggered = false;
    }, 230);
  });

  audio.addEventListener("ended", () => setMainLabel(false));

  // If Lux ever remounts the player, stop any old RAF loop (defensive)
  // (Right now mount only happens once, but this keeps it safe)
  window.luxTTS = Object.assign(window.luxTTS || {}, { stopProgress });

  (window.luxTTS?.nudge || (() => {}))();
  console.info("[tts-player] azure controls mounted");
}
</file>

<file path="features/features/tts/tts-overlay.css">
/* features/features/tts/tts-overlay.css */
/* The "Rock Solid" Positioning Layer. */
/* REWRITTEN: Right-side Drawer with Left-Protruding Header Tab */

:root {
  --lux-tts-panel-w: 360px;
  --lux-tts-panel-max-w: min(92vw, 380px);
  --lux-tts-panel-max-h: min(520px, 70vh);
  
  --lux-tts-radius: 14px;
  
  /* Tab visuals */
  --lux-tts-tab-h: 34px;
  --lux-tts-tab-protrude: 140px; /* How far it sticks out to the LEFT */
  --lux-tts-tab-peek: 44px;      /* How much of the TAB is visible when closed */
  --lux-tts-box-peek: 8px;       /* How much of the BOX EDGE is visible when closed */
  
  --lux-tts-tab-bg: #2d6cdf;
  --lux-tts-tab-bg-hover: #2457b1;
  --lux-tts-tab-ink: #fff;
}

/* ==========================================================================
   PANEL CONTAINER (Right Side)
   ========================================================================== */
html body .lux-tts-panel {
  position: fixed !important;
  
  /* Anchor Top-Right */
  top: 80px !important; 
  right: 0 !important; /* Pinned to the right edge */
  left: auto !important;
  
  /* Dimensions */
  width: var(--lux-tts-panel-w) !important;
  max-width: var(--lux-tts-panel-max-w) !important;
  height: auto !important;
  
  /* Theme */
  background: #fff !important;
  color: #111 !important;
  
  /* Borders (Rounded Left corners) */
  border: 1px solid rgba(0, 0, 0, 0.06) !important;
  border-right: 0 !important;
  border-top-left-radius: var(--lux-tts-radius) !important;
  border-bottom-left-radius: var(--lux-tts-radius) !important;
  border-top-right-radius: 0 !important;
  border-bottom-right-radius: 0 !important;
  
  /* Depth */
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.18) !important;
  
  /* IMPORTANT: Allow the tab to hang outside (to the left) */
  overflow: visible !important;
  
  /* CLOSED STATE: Slide Right, leaving just the tab peek + box sliver visible */
  /* Calculation: Move 100% right, then pull back by (Tab Peek + Box Peek) */
  transform: translate3d(calc(100% - var(--lux-tts-tab-peek) - var(--lux-tts-box-peek)), 0, 0) !important;
  
  transition: transform 0.28s cubic-bezier(0.2, 0.8, 0.2, 1) !important;
  
  z-index: var(--z-drawer) !important; /* Treaty Compliant */
  display: block !important;
}

/* OPEN STATE: Slide back to 0 (Fully visible) */
html.lux-tts-open body .lux-tts-panel {
  transform: translate3d(0, 0, 0) !important;
}

/* ==========================================================================
   THE TAB (Full-width header that protrudes Left)
   ========================================================================== */
.lux-tts-tab {
  position: absolute !important;
  top: 6px !important;
  
  /* Stretch Strategy: Pin Right side inside the box, Pin Left side OUTSIDE the box */
  right: 6px !important;
  left: calc(var(--lux-tts-tab-protrude) * -1) !important; 
  width: auto !important; /* Let left/right define width */
  
  height: var(--lux-tts-tab-h) !important;
  
  /* Layout */
  display: inline-flex !important;
  align-items: center !important;
  justify-content: center !important;
  gap: 10px !important;
  
  /* Theme */
  background: var(--lux-tts-tab-bg) !important;
  color: var(--lux-tts-tab-ink) !important;
  border: none !important;
  border-radius: 999px !important;
  
  /* Typography */
  font: 600 14px/1 system-ui, -apple-system, sans-serif !important;
  letter-spacing: 0 !important;
  
  /* Interaction */
  cursor: pointer !important;
  user-select: none !important;
  box-shadow: 0 6px 18px rgba(13, 17, 23, 0.35) !important;
  z-index: 2 !important; /* Above panel content */
  
  padding: 0 16px !important;
  
  /* FIXED: Added 'transform 0.18s ease' here so the !important doesn't kill the movement */
  transition: transform 0.18s ease, background 0.2s ease, padding 0.2s ease, filter 0.18s ease !important;
}

.lux-tts-tab:hover {
  background: var(--lux-tts-tab-bg-hover) !important;
  filter: none !important;
}

/* Icon Rotation */
.lux-tts-tab-icon {
  display: inline-block !important;
  font-size: 14px !important;
  transition: transform 0.25s ease !important;
}

/* Flip arrow when open (Left arrow becomes Right arrow) */
html.lux-tts-open .lux-tts-tab-icon {
  transform: rotate(180deg) !important;
}

/* ==========================================================================
   PANEL BODY (No Scrollbars, Full Visibility)
   ========================================================================== */
.lux-tts-panel #tts-controls {
  /* Push content down so it doesn't overlap the header tab */
  padding: calc(var(--lux-tts-tab-h) + 14px) 16px 16px !important;
  
  /* Allow natural height, NO internal scrolling */
  height: auto !important;
  max-height: none !important;
  overflow: visible !important;
  box-sizing: border-box !important;
}

/* Hide any accidental scrollbars just in case */
.lux-tts-panel #tts-controls::-webkit-scrollbar {
  display: none !important;
}

/* ==========================================================================
   MOBILE TWEAKS
   ========================================================================== */
@media (max-width: 480px) {
  html body .lux-tts-panel {
     width: 90vw !important;
  }
  :root {
    --lux-tts-tab-protrude: 88px; /* Shorter tongue on mobile */
  }
}
</file>

<file path="features/interactions/boot.js">
// ui/interactions/boot.js
// Central, safe boot for UI interactions.
// - Idempotent
// - Uses dynamic imports with fallbacks so CSB path quirks don't break the app.
// UPDATED: Added correct export names (setupYGHover, initPhonemeAudio) to fix console warnings.

let interactionsBooted = false;

async function loadFirst(paths, label) {
  for (const p of paths) {
    try {
      const mod = await import(p);
      console.log(`[LUX] interactions: loaded ${label} (${p})`);
      return mod;
    } catch (e) {
      // swallow and try next
    }
  }
  console.warn(`[LUX] interactions: failed to load ${label}`, paths);
  return null;
}

function callFirstFunction(mod, names, label) {
  if (!mod) return;
  for (const name of names) {
    const fn = mod?.[name];
    if (typeof fn === "function") {
      try {
        fn();
        console.log(`[LUX] ${label} booted via ${name}()`);
      } catch (e) {
        console.warn(`[LUX] ${label} failed in ${name}()`, e);
      }
      return;
    }
  }
  console.log(`[LUX] ${label}: no known init export found`, names);
}

export function bootInteractions() {
  if (interactionsBooted) return;
  interactionsBooted = true;

  // fire-and-forget async boot so callers don't need await
  (async () => {
    // Core hover + chips
    const PhHover = await loadFirst(
      ["./ph-hover.js", "./ph-hover/index.js"],
      "ph-hover"
    );

    // Only load the real phoneme chips module
    const PhChips = await loadFirst(["./ph-chips.js"], "ph-chips");

    // Header interactions
    const YgHover = await loadFirst(["./yg-hover.js"], "yg-hover");
    const PhAudio = await loadFirst(["./ph-audio.js"], "ph-audio");

    // Hover boot (stable)
    callFirstFunction(
      PhHover,
      ["setupPhonemeHover", "bootPhonemeHover", "initPhonemeHover", "default"],
      "phoneme-hover"
    );

    // Chips hydration + click/tooltip wiring
    callFirstFunction(
      PhChips,
      [
        "initPhonemeChipBehavior",
        "setupPhonemeChips",
        "hydratePhonemeChips",
        "initPhonemeChips",
        "bootPhonemeChips",
        "wirePhonemeChips",
        "default",
      ],
      "phoneme-chips"
    );

    // Word header pill hover / YouGlish explainer
    callFirstFunction(
      YgHover,
      [
        "setupYGHover", // <--- FIXED: Added Uppercase YG (Primary export)
        "setupYgHover",
        "bootYgHover",
        "initYgHover",
        "wireYgHover",
        "default",
      ],
      "yg-hover"
    );

    // Phoneme header pill hover/click audio/video explainer
    callFirstFunction(
      PhAudio,
      [
        "initPhonemeAudio", // <--- FIXED: Added correct export name
        "setupPhonemeHeaderAudio",
        "initPhonemeHeaderAudio",
        "bootPhonemeHeaderAudio",
        "wirePhonemeHeaderAudio",
        "initPhAudio",
        "default",
      ],
      "ph-audio"
    );

    console.log("[LUX] interactions booted");
  })();
}

// Legacy global (harmless)
globalThis.bootInteractions = globalThis.bootInteractions || bootInteractions;
</file>

<file path="features/interactions/helpers.js">
// ui/interactions/helpers.js
export function showClickHint(targetEl, msg) {
  if (!targetEl) return;
  const r = targetEl.getBoundingClientRect();
  const hint = document.createElement("div");
  hint.className = "hint-bubble";
  hint.textContent = msg || "Click";
  hint.style.left = r.left + r.width / 2 + "px";
  hint.style.top = r.top - 34 + "px";
  document.body.appendChild(hint);
  setTimeout(() => hint.remove(), 1400);
}

// placeholder kept for compatibility (no-op)
export function keepTooltipInView() {
  /* noop placeholder */
}
</file>

<file path="features/interactions/index.js">
// ui/interactions/index.js
import { safePlay, playWithGesture, prepareVideo } from "./utils.js";
// Removed: installLegendCueStyles
import { initScoreErrorCollapse } from "./score-collapse.js";
import { initProsodyLegendToggle } from "./legend-toggle.js";
import { setupYGHover } from "./yg-hover.js";
import { setupPhonemeHover } from "./ph-hover.js";
import { initPhonemeAudio } from "./ph-audio.js";
import { initPhonemeChipBehavior } from "./ph-chips.js";
import { animateMetricTips } from "./tips.js";
import { showClickHint, keepTooltipInView } from "./helpers.js";
import { bootInteractions } from "./boot.js";

// Re-attach legacy globals
globalThis.initScoreErrorCollapse =
  globalThis.initScoreErrorCollapse || initScoreErrorCollapse;
globalThis.initProsodyLegendToggle =
  globalThis.initProsodyLegendToggle || initProsodyLegendToggle;
globalThis.animateMetricTips =
  globalThis.animateMetricTips || animateMetricTips;
globalThis.setupYGHover = globalThis.setupYGHover || setupYGHover;

globalThis.setupPhonemeHover = setupPhonemeHover;

globalThis.initPhonemeAudio = globalThis.initPhonemeAudio || initPhonemeAudio;
globalThis.initPhonemeChipBehavior =
  globalThis.initPhonemeChipBehavior || initPhonemeChipBehavior;
globalThis.showClickHint = globalThis.showClickHint || showClickHint;
globalThis.keepTooltipInView =
  globalThis.keepTooltipInView || keepTooltipInView;

// Utils
globalThis.safePlay = globalThis.safePlay || safePlay;
globalThis.playWithGesture = globalThis.playWithGesture || playWithGesture;
globalThis.prepareVideo = globalThis.prepareVideo || prepareVideo;

// Auto-boot same as old file did
bootInteractions();

// Named exports
export {
  safePlay,
  playWithGesture,
  prepareVideo,
  // Removed: installLegendCueStyles
  initScoreErrorCollapse,
  initProsodyLegendToggle,
  setupYGHover,
  setupPhonemeHover,
  initPhonemeAudio,
  initPhonemeChipBehavior,
  animateMetricTips,
  showClickHint,
  keepTooltipInView,
  bootInteractions,
};
</file>

<file path="features/interactions/legend-toggle.js">
// ui/interactions/legend-toggle.js
// CLEANED: Removed dynamic CSS injection (now handled by lux-results.css)

export function initProsodyLegendToggle() {
  // Removed: installLegendCueStyles();

  const tip = document.getElementById("prosodyLegendToggle");
  const legend = document.getElementById("prosodyLegend");
  const wrap =
    (legend && legend.closest(".results-flex")) ||
    document.querySelector(".results-flex");

  if (!tip || !legend || !wrap) return;

  if (!legend._legendReady) {
    legend.classList.remove("hidden");
    legend.setAttribute("aria-hidden", "true");
    wrap.classList.remove("legend-open");
    legend._legendReady = 1;
  }

  let peek = document.getElementById("legendPeek");
  if (!peek) {
    peek = document.createElement("div");
    peek.id = "legendPeek";
    wrap.appendChild(peek);
  }

  function positionPeek() {
    if (!peek) return;
    const wrapRect = wrap.getBoundingClientRect();
    const table =
      wrap.querySelector("table.score-table") || wrap.querySelector("table");
    if (!table) return;

    const tableRect = table.getBoundingClientRect();
    const wordTh = table.querySelector("#wordHeader");
    let top = 44;
    if (wordTh) {
      const wh = wordTh.getBoundingClientRect();
      top = Math.max(0, wh.top - wrapRect.top + wh.height / 2 - 20);
    }
    const left = Math.max(
      0,
      tableRect.left - wrapRect.left - (peek.offsetWidth || 12) + 2
    );
    peek.style.left = left + "px";
    peek.style.top = top + "px";
  }

  const showPeek = () => {
    positionPeek();
    wrap.classList.add("show-peek");
  };
  const hidePeek = () => wrap.classList.remove("show-peek");

  if (!tip._legendBound) {
    const toggle = (e) => {
      e.preventDefault();
      const open = !wrap.classList.contains("legend-open");
      wrap.classList.toggle("legend-open", open);
      legend.setAttribute("aria-hidden", String(!open));
      if (open) {
        tip.classList.remove("cue-legend");
        try {
          localStorage.setItem("seenProsodyLegendCue", "1");
        } catch (_) {}
        hidePeek();
      } else {
        positionPeek();
        showPeek();
        setTimeout(hidePeek, 800);
      }
    };

    tip.addEventListener("pointerenter", showPeek);
    tip.addEventListener("mouseenter", showPeek);
    tip.addEventListener("focusin", showPeek);

    tip.addEventListener("pointerleave", hidePeek);
    tip.addEventListener("mouseleave", hidePeek);
    tip.addEventListener("focusout", hidePeek);

    tip.addEventListener("click", toggle);
    tip.addEventListener("keydown", (e) => {
      if (e.key === "Enter" || e.key === " ") toggle(e);
    });

    tip._legendBound = 1;
  }

  if (!peek._legendBound) {
    peek.addEventListener("click", () => tip.click());
    peek._legendBound = 1;
  }

  try {
    if (!localStorage.getItem("seenProsodyLegendCue"))
      tip.classList.add("cue-legend");
  } catch (_) {}

  positionPeek();
  window.addEventListener("resize", positionPeek, { passive: true });
}
</file>

<file path="features/interactions/ph-audio.js">
// ui/interactions/ph-audio.js
export function initPhonemeAudio() {
  const btn = document.getElementById("phonemeAudioBtn");
  const pill = document.querySelector("#phonemeHeader .phoneme-chip");
  const vid = document.getElementById("phDemo");
  const tip = document.getElementById("phUnmuteTip");
  if (!vid) return;

  function toggle(e) {
    e.stopPropagation();
    vid.muted = !vid.muted;
    if (vid.paused) vid.play().catch(() => {});
    if (pill) pill.classList.toggle("is-playing", !vid.muted);
    if (tip) {
      tip.textContent = vid.muted ? "Muted" : "Audio on";
      tip.style.display = "block";
      setTimeout(() => {
        tip.style.display = "none";
      }, 1500);
    }
  }
  if (btn && !btn._phA) {
    btn.addEventListener("click", toggle);
    btn._phA = 1;
  }
  if (pill && !pill._phA) {
    pill.addEventListener("click", toggle);
    pill._phA = 1;
  }
}
</file>

<file path="features/interactions/ph-chips.js">
// features/interactions/ph-chips.js
// THE LIBRARIAN: Scans "dumb" chips, looks up data, and stamps attributes.
// Does NOT create DOM elements.

import { norm } from "../../src/data/phonemes/core.js";
import { getPhonemeAssetByIPA } from "../../src/data/phonemes/assets.js";
import { phonemeDetailsByIPA, articulatorPlacement } from "../../src/data/phonemes/details.js";

// Standard set to validate against
const KNOWN_PHONES = new Set([
  "p","b","t","d","k","g","m","n","f","v","s","z","h","l","ɹ","r","w","j","ŋ",
  "θ","ð","ʃ","ʒ","tʃ","dʒ","ɾ","ʔ","ʍ",
  "i","ɪ","e","ɛ","æ","ɑ","ɔ","o","ʊ","u","ʌ","ə","ɚ","ɝ",
  "eɪ","aɪ","ɔɪ","aʊ","oʊ",
  "iy","ih","eh","ae","aa","ao","ah","ax","axr","er","uw","uh","ey","ay","aw","ow","oy",
  "th","dh","sh","zh","ch","jh","dx","ng","hh","wh","q","y"
]);

export async function initPhonemeChipBehavior(containerSelector = "#prettyResult") {
  const root = document.querySelector(containerSelector);
  if (!root) return;

  // Find all chips that haven't been hydrated yet
  // We look for .phoneme-chip (generated by rows.js)
  const chips = [...root.querySelectorAll(".phoneme-chip:not([data-hydrated])")];
  
  if (!chips.length) return;

  for (const chip of chips) {
    // 1. Get IPA (Prefer attribute, fallback to text)
    const rawIpa = chip.getAttribute("data-ipa") || chip.textContent.trim().split(" ")[0];
    const key = norm(rawIpa); // Normalize (ax -> ə, etc)

    // 2. Mark processed
    chip.setAttribute("data-hydrated", "true");
    // Ensure the normalized key is set for the Hover module
    chip.setAttribute("data-ipa", key); 

    // 3. Lookup Data (The "Digging" part)
    // Priority: Specific Coaching Detail > General Articulation > Asset Label
    const detail = phonemeDetailsByIPA[key];
    const placement = articulatorPlacement[key];
    const asset = getPhonemeAssetByIPA(key);

    let tipPlain = "";
    let tipTech = "";
    let tipMistake = "";
    let displayIPA = "";
    let words = [];

    if (detail) {
      tipPlain = detail.tip || "";
      tipTech = detail.tech || "";          // (future field)
      tipMistake = detail.mistake || "";    // already present in many entries
      displayIPA = detail.ipa || "";

      // (future) examples array support — you can choose "words" or "examples" in details.js
      const arr = detail.words || detail.examples;
      if (Array.isArray(arr)) words = arr;
    } else if (placement) {
      // Fallback: keep today’s behavior, but treat it as “Plain”
      tipPlain = `${placement.label}. ${placement.tip}`;
      displayIPA = `/${key}/ (as in '${placement.example}')`;

      // Immediate benefit: at least 1 example shows right now
      if (placement.example) words = [placement.example];
    }

    // 4) Stamp Attributes (The Hover module reads these)
    // Legacy field (kept for safety): data-tip-text
    if (tipPlain) {
      chip.setAttribute("data-tip-plain", tipPlain);
      chip.setAttribute("data-tip-text", tipPlain); // backward-compatible
    }
    if (tipTech) chip.setAttribute("data-tip-tech", tipTech);
    if (tipMistake) chip.setAttribute("data-tip-mistake", tipMistake);

    if (words.length) {
      chip.setAttribute("data-tip-words", JSON.stringify(words.filter(Boolean).slice(0, 3)));
    }

    if (displayIPA) chip.setAttribute("data-display-ipa", displayIPA);
    
    if (asset?.video) {
        chip.setAttribute("data-video-src", asset.video);
        if (asset.poster) chip.setAttribute("data-poster-src", asset.poster);
    }
    if (asset?.videoFront) {
      chip.setAttribute("data-video-front-src", asset.videoFront);
    }
  }
  
  // Console log to confirm we cleaned up the "Old" ones
  // console.log(`[LUX] Hydrated ${chips.length} phoneme chips.`);
}
</file>

<file path="features/interactions/ph-hover.js">
// features/interactions/ph-hover.js
export { setupPhonemeHover } from "./ph-hover/index.js";
</file>

<file path="features/interactions/ph-hover/chip-events.js">
// features/interactions/ph-hover/chip-events.js
// Row chip event wiring:
// - hover in/out shows tooltip (unless pinned)
// - capture-phase click "trap door" pins tooltip (mobile-friendly)
// - CRITICAL: never swallow header pill clicks (#phonemeTitle)

export function installChipEvents(state, { showTooltip, handleChipClick, scheduleHide, bindOutsideCloseOnce }) {
  const root = document.body;

  // Hover in: show tooltip for row chips
  root.addEventListener("mouseover", (e) => {
    if (state.tooltipPinned) return;

    const chip = e.target.closest(".phoneme-chip[data-hydrated]");
    if (!chip) return;
    if (chip.id === "phonemeTitle") return;

    if (state.hideTimeout) clearTimeout(state.hideTimeout);

    showTooltip?.(chip, { pinned: false });
  });

  // Hover out: hide tooltip (but DON'T hide if moving into tooltip itself)
  root.addEventListener("mouseout", (e) => {
    if (state.tooltipPinned) return;

    const chip = e.target.closest(".phoneme-chip[data-hydrated]");
    if (!chip) return;
    if (chip.id === "phonemeTitle") return;

    const to = e.relatedTarget;

    // If moving into tooltip, don't hide
    const tip = state.globalTooltip;
    if (to && tip && (to === tip || tip.contains(to))) return;

    scheduleHide?.(state);
  });

  // === CRITICAL: Capture-phase click handler ("trap door") ===
  // Never swallow header pill clicks.
  // Row chip click pins the tooltip and NEVER autoplays.
  root.addEventListener(
    "click",
    (e) => {
      const chip = e.target.closest(".phoneme-chip[data-hydrated]");
      if (!chip) return;

      // Let header pill clicks pass through (ph-audio.js and/or header preview click)
      if (chip.id === "phonemeTitle") return;

      // We handle row-chip clicks -> pin tooltip
      e.preventDefault();
      e.stopPropagation();

      // Toggle behavior: clicking the same chip while pinned closes it
      if (state.tooltipPinned && state.currentChip === chip) {
        state.hideTooltip?.();
        return;
      }

      if (state.hideTimeout) clearTimeout(state.hideTimeout);

      handleChipClick?.(chip);
    },
    { capture: true }
  );

  // Ensure outside-close exists (once)
  bindOutsideCloseOnce?.(state, state.hideTooltip);
}
</file>

<file path="features/interactions/ph-hover/header-preview.js">
// features/interactions/ph-hover/header-preview.js
// Header phoneme preview behavior (pill hover -> preview box)
// Keeps headerAudioOn state stable across open/close.

import { safePlay } from "../utils.js";

export function installHeaderPreview(state) {
  const preview = document.getElementById("phPreview");
  const demoVid = document.getElementById("phDemo");
  const phHeader = document.getElementById("phonemeHeader");
  const pill = phHeader?.querySelector(".phoneme-chip");
  const tip = document.getElementById("phUnmuteTip");

  if (!preview || !demoVid || !phHeader || !pill) return;

  if (pill._hoverBound) return;
  pill._hoverBound = true;

  function positionPreview() {
    const rect = phHeader.getBoundingClientRect();

    let left = rect.left - 560 - 10;
    if (left < 10) left = 10;

    let top = rect.top;
    if (top + 390 > window.innerHeight) top = window.innerHeight - 390 - 10;

    preview.style.left = left + "px";
    preview.style.top = top + "px";
  }

  function showPreview() {
    if (preview.style.display === "block") return;

    preview.style.display = "block";
    positionPreview();

    // IMPORTANT: do NOT force-mute on hover.
    // Respect current headerAudioOn state.
    demoVid.muted = !state.headerAudioOn;
    demoVid.volume = 1.0;

    // Start/restart muted or unmuted based on state.
    safePlay(demoVid, demoVid.getAttribute("src"), {
      muted: demoVid.muted,
      restart: true,
    });

    pill.classList.toggle("is-playing", state.headerAudioOn);

    if (tip) tip.style.display = "none";
  }

  function hidePreview() {
    preview.style.display = "none";
    demoVid.pause();
    demoVid.currentTime = 0;

    // IMPORTANT: do NOT force demoVid.muted=true here;
    // leaving state intact makes click-toggle feel consistent.
    pill.classList.remove("is-playing");

    if (tip) tip.style.display = "none";
  }

  // Hover behavior: pill <-> preview bridge
  pill.addEventListener("mouseover", showPreview);

  pill.addEventListener("mouseout", (e) => {
    const to = e.relatedTarget;
    if (to && (to === preview || preview.contains(to))) return;
    hidePreview();
  });

  preview.addEventListener("mouseout", (e) => {
    const to = e.relatedTarget;
    if (to && (to === pill || pill.contains(to))) return;
    hidePreview();
  });
}
</file>

<file path="features/interactions/ph-hover/index.js">
// features/interactions/ph-hover/index.js
// Public entrypoint for the phoneme hover system.
// Holds shared state + wires DOM/events/rendering together.
//
// Golden rule: this file coordinates the system, but delegates actual work
// to small modules.

import { ensureGlobalTooltip } from "./dom.js";
import { installChipEvents } from "./chip-events.js";
import { installHeaderPreview } from "./header-preview.js";
import { showTooltip } from "./tooltip-render.js";
import { initTooltipTextCarousel } from "./tooltip-carousel.js";
import { initTooltipVideoControls } from "./tooltip-video.js";
import { openVideoFocusModal } from "./tooltip-modal.js";
import { scheduleHide, bindOutsideCloseOnce } from "./dom.js";

// Shared singleton state
const state = {
  globalTooltip: null,
  tooltipContent: null, // inner container so we don't wipe styles
  currentChip: null,
  hideTimeout: null,
  isInitialized: false,

  // Header preview state (persist across hover show/hide)
  headerAudioOn: false,

  // Pinned tooltip (mobile tap behavior / desktop click pin)
  tooltipPinned: false,
  outsideCloseBound: false,

  // filled after init so chip-events can call it safely
  hideTooltip: null,
};

export function setupPhonemeHover() {
  if (state.isInitialized) {
    console.warn("[LUX] Phoneme Hover System already active. Skipping re-init.");
    return;
  }

  // Create tooltip DOM + CSS once
  ensureGlobalTooltip(state, {
    scheduleHide: () => scheduleHide(state, () => hideTooltip(state)),
  });

  // Provide hideTooltip onto shared state for other modules
  state.hideTooltip = hideTooltip;

  // Row chips wiring (hover + capture click trap door)
  installChipEvents(state, {
    showTooltip: (chip, opts) =>
      showTooltip(state, chip, opts, {
        initTooltipTextCarousel,
        initTooltipVideoControls,
        openVideoFocusModal,
        hideTooltip,
      }),

    handleChipClick,
    scheduleHide: () => scheduleHide(state, () => hideTooltip(state)),
    bindOutsideCloseOnce,
  });

  // Header preview wiring (pill hover preview)
  installHeaderPreview(state);

  state.isInitialized = true;
  console.log("[LUX] Phoneme Hover System Active (Robust Mode)");
}

/* ====================== Core Actions ====================== */

function handleChipClick(chip) {
  // Click pins open (mobile-friendly). Nothing autoplays.
  showTooltip(state, chip, { pinned: true }, {
    initTooltipTextCarousel,
    initTooltipVideoControls,
    openVideoFocusModal,
    hideTooltip,
  });

  chip.classList.add("lux-playing-lock");
}

function hideTooltip(s = state) {
  s.tooltipPinned = false;

  if (s.globalTooltip) {
    s.globalTooltip.style.opacity = "0";
    s.globalTooltip.style.visibility = "hidden";

    const vids = [...s.globalTooltip.querySelectorAll("video")];
    for (const v of vids) {
      try {
        v.pause();
      } catch (_) {}
      try {
        v.currentTime = 0;
      } catch (_) {}
    }
  }

  if (s.currentChip) s.currentChip.classList.remove("lux-playing-lock");
  s.currentChip = null;
}
</file>

<file path="features/interactions/ph-hover/tooltip-carousel.js">
// features/interactions/ph-hover/tooltip-carousel.js
// Tooltip panel carousel: Plain / Technical / Common mix-ups

export function initTooltipTextCarousel(globalTooltipEl, panels) {
  const title = globalTooltipEl?.querySelector("#lux-ph-modeTitle");
  const prev = globalTooltipEl?.querySelector("#lux-ph-panel-prev");
  const next = globalTooltipEl?.querySelector("#lux-ph-panel-next");
  const panelText = globalTooltipEl?.querySelector("#lux-ph-panelText");

  if (!title || !prev || !next || !panelText) return;

  const max = panels.length;
  let idx = 0;

  function render() {
    title.textContent = panels[idx]?.title || "";

    const has = (panels[idx]?.text || "").trim().length > 0;
    const t = has ? panels[idx].text : panels[idx].empty;

    panelText.textContent = t;
    panelText.classList.toggle("is-empty", !has);

    const disabled = max <= 1;
    prev.disabled = disabled;
    next.disabled = disabled;
  }

  function step(delta) {
    if (max <= 1) return;
    idx = (idx + delta + max) % max;
    render();
  }

  prev.onclick = (e) => {
    e.preventDefault();
    e.stopPropagation();
    step(-1);
  };

  next.onclick = (e) => {
    e.preventDefault();
    e.stopPropagation();
    step(1);
  };

  render();
}
</file>

<file path="features/interactions/ph-hover/tooltip-modal.js">
// features/interactions/ph-hover/tooltip-modal.js
// Video Focus Modal (expand/shrink) + its controls
// Mirrors the tooltip-video system, but scoped to the modal DOM.

export function initModalVideoControls(back) {
  const sideVid = back?.querySelector('video[data-vid="side"]');
  const frontVid = back?.querySelector('video[data-vid="front"]');

  const tileSide = back?.querySelector('.lux-ph-vidTile[data-vid="side"]');
  const tileFront = back?.querySelector('.lux-ph-vidTile[data-vid="front"]');

  const btnSide = back?.querySelector("#lux-ph-m-side");
  const btnFront = back?.querySelector("#lux-ph-m-front");
  const btnBoth = back?.querySelector("#lux-ph-m-both");
  const btnStop = back?.querySelector("#lux-ph-m-stop");
  const btnShrink = back?.querySelector("#lux-ph-m-shrink");
  const btnSound = back?.querySelector("#lux-ph-m-sound");
  const btnLoop = back?.querySelector("#lux-ph-m-loop");
  const speedSel = back?.querySelector("#lux-ph-m-speed");

  if (!sideVid && !frontVid) return;

  // Default sound ON
  let soundOn = true;

  // Default loop OFF
  let loopOn = false;

  function applySound() {
    const txt = soundOn ? "🔊" : "🔇";
    if (btnSound) {
      btnSound.textContent = txt;
      btnSound.setAttribute("data-sound", soundOn ? "1" : "0");
    }
    for (const v of [sideVid, frontVid]) {
      if (!v) continue;
      v.muted = !soundOn;
      v.volume = 1.0;
    }
  }

  function applyLoop() {
    for (const v of [sideVid, frontVid]) {
      if (!v) continue;
      v.loop = loopOn;
    }
    if (btnLoop) {
      btnLoop.textContent = loopOn ? "Repeat On" : "Repeat Off";
      btnLoop.setAttribute("data-loop", loopOn ? "1" : "0");
    }
  }

  function applySpeed() {
    const rate = parseFloat(speedSel?.value || "1");
    for (const v of [sideVid, frontVid]) {
      if (!v) continue;
      v.playbackRate = rate;
    }
  }

  async function gesturePlay(v, { restart = true } = {}) {
    if (!v) return;
    try {
      if (restart) v.currentTime = 0;
    } catch (_) {}

    v.muted = soundOn ? false : true;
    v.volume = 1.0;

    try {
      await v.play();
    } catch (_) {
      try {
        v.muted = true;
        await v.play();
      } catch (_) {}
    }
  }

  function stopAll() {
    for (const v of [sideVid, frontVid]) {
      if (!v) continue;
      try {
        v.pause();
      } catch (_) {}
      try {
        v.currentTime = 0;
      } catch (_) {}
    }
  }

  function bindTile(v, tile) {
    if (!v || !tile) return;

    const syncClass = () => {
      tile.classList.toggle("is-playing", !v.paused);
    };

    v.addEventListener("play", syncClass);
    v.addEventListener("pause", syncClass);
    v.addEventListener("ended", syncClass);
    syncClass();

    tile.addEventListener("click", async (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (v.paused) await gesturePlay(v, { restart: false });
      else v.pause();
    });
  }

  bindTile(sideVid, tileSide);
  bindTile(frontVid, tileFront);

  btnSound?.addEventListener("click", (e) => {
    e.preventDefault();
    e.stopPropagation();
    soundOn = !soundOn;
    applySound();
  });

  btnLoop?.addEventListener("click", (e) => {
    e.preventDefault();
    e.stopPropagation();
    loopOn = !loopOn;
    applyLoop();
  });

  speedSel?.addEventListener("change", applySpeed);

  btnSide?.addEventListener("click", async (e) => {
    e.preventDefault();
    e.stopPropagation();
    await gesturePlay(sideVid, { restart: true });
  });

  btnFront?.addEventListener("click", async (e) => {
    e.preventDefault();
    e.stopPropagation();
    await gesturePlay(frontVid, { restart: true });
  });

  btnBoth?.addEventListener("click", async (e) => {
    e.preventDefault();
    e.stopPropagation();

    try {
      if (sideVid) sideVid.currentTime = 0;
    } catch (_) {}
    try {
      if (frontVid) frontVid.currentTime = 0;
    } catch (_) {}

    applySound();
    applySpeed();

    await Promise.all([
      sideVid ? gesturePlay(sideVid, { restart: false }) : Promise.resolve(),
      frontVid ? gesturePlay(frontVid, { restart: false }) : Promise.resolve(),
    ]);
  });

  btnStop?.addEventListener("click", (e) => {
    e.preventDefault();
    e.stopPropagation();
    stopAll();
  });

  btnShrink?.addEventListener("click", (e) => {
    e.preventDefault();
    e.stopPropagation();
    // Modal close is handled by openVideoFocusModal() close()
    back?.remove();
  });

  // Apply initial states
  applySound();
  applyLoop();
  applySpeed();
}

export function openVideoFocusModal({ sideSrc, frontSrc }) {
  // kill existing
  const existing = document.querySelector("#lux-ph-vidModalBack");
  if (existing) existing.remove();

  const back = document.createElement("div");
  back.id = "lux-ph-vidModalBack";
  back.className = "lux-ph-modalBack";

  // Only render buttons that actually apply
  const hasSide = !!sideSrc;
  const hasFront = !!frontSrc;
  const hasBoth = hasSide && hasFront;

  back.innerHTML = `
    <div class="lux-ph-modalCard" role="dialog" aria-modal="true">
      <div class="lux-ph-modalTop">
        <div class="lux-ph-modalTitle">Video Focus</div>

        <div class="lux-ph-vidBtns">
          ${hasSide ? `<button id="lux-ph-m-side" class="lux-ph-miniBtn" type="button">Side</button>` : ``}
          ${hasFront ? `<button id="lux-ph-m-front" class="lux-ph-miniBtn" type="button">Front</button>` : ``}
          ${hasBoth ? `<button id="lux-ph-m-both" class="lux-ph-miniBtn is-primary" type="button">Both</button>` : ``}
          <button id="lux-ph-m-stop" class="lux-ph-miniBtn" type="button">Stop</button>
          <button id="lux-ph-m-shrink" class="lux-ph-miniBtn" type="button">Shrink</button>
          <button id="lux-ph-m-loop" class="lux-ph-miniBtn" type="button" data-loop="0">Repeat Off</button>

          <select id="lux-ph-m-speed" class="lux-ph-speed">
            <option value="0.4">0.4×</option>
            <option value="0.5">0.5×</option>
            <option value="0.6">0.6×</option>
            <option value="0.7">0.7×</option>
            <option value="0.8">0.8×</option>
            <option value="0.9">0.9×</option>
            <option value="1" selected>1×</option>
            <option value="1.1">1.1×</option>
            <option value="1.25">1.25×</option>
            <option value="1.4">1.4×</option>
            <option value="1.6">1.6×</option>
          </select>

          <button id="lux-ph-m-sound" class="lux-ph-miniBtn" type="button" data-sound="1">🔊</button>
        </div>
      </div>

      <div class="lux-ph-modalGrid">
        ${
          sideSrc
            ? `
          <div class="lux-ph-vidTile" data-vid="side">
            <video data-vid="side" src="${sideSrc}" playsinline preload="metadata"></video>
            <div class="lux-ph-vidOverlay" aria-hidden="true"><span>▶</span></div>
            <div class="lux-ph-vidLabel">Side</div>
          </div>`
            : ``
        }

        ${
          frontSrc
            ? `
          <div class="lux-ph-vidTile" data-vid="front">
            <video data-vid="front" src="${frontSrc}" playsinline preload="metadata"></video>
            <div class="lux-ph-vidOverlay" aria-hidden="true"><span>▶</span></div>
            <div class="lux-ph-vidLabel">Front</div>
          </div>`
            : ``
        }
      </div>
    </div>
  `;

  document.body.appendChild(back);

  const card = back.querySelector(".lux-ph-modalCard");
  if (!card) return;

  function close() {
    // pause everything inside modal
    back.querySelectorAll("video").forEach((v) => {
      try {
        v.pause();
      } catch (_) {}
    });
    back.remove();
  }

  // Shrink closes instantly
  back.querySelector("#lux-ph-m-shrink")?.addEventListener("click", (e) => {
    e.preventDefault();
    e.stopPropagation();
    close();
  });

  // Click backdrop closes instantly
  back.addEventListener("click", (e) => {
    if (e.target === back) close();
  });

  // Prevent inside clicks from closing backdrop
  card.addEventListener("click", (e) => {
    e.stopPropagation();
  });

  // Wire modal controls (mirrors tooltip logic)
  initModalVideoControls(back);

  // Click tile toggles play/pause (kept — mirrors tooltip feel)
  back.querySelectorAll(".lux-ph-vidTile").forEach((tile) => {
    const v = tile.querySelector("video");
    tile.addEventListener("click", async (e) => {
      e.preventDefault();
      e.stopPropagation();
      try {
        if (!v) return;
        if (v.paused) {
          v.muted = false;
          v.volume = 1.0;
          await v.play();
          tile.classList.add("is-playing");
        } else {
          v.pause();
          tile.classList.remove("is-playing");
        }
      } catch (_) {}
    });
  });
}
</file>

<file path="features/interactions/ph-hover/tooltip-render.js">
// features/interactions/ph-hover/tooltip-render.js
// Renders tooltip HTML + positions it.
// Delegates carousel/video logic to other modules via callbacks.

import { escapeHTML } from "./utils.js";

export function showTooltip(state, chip, { pinned = false } = {}, hooks = {}) {
  const { initTooltipTextCarousel, initTooltipVideoControls, hideTooltip, openVideoFocusModal } = hooks;

  if (!state.globalTooltip || !state.tooltipContent) return;

  // If same chip is already showing, do nothing
  if (state.currentChip === chip && state.globalTooltip.style.visibility === "visible") {
    state.tooltipPinned = !!pinned || state.tooltipPinned;
    return;
  }

  state.currentChip = chip;
  state.tooltipPinned = !!pinned;

  const ipa = chip.getAttribute("data-ipa") || "?";

  const tipPlain =
    chip.getAttribute("data-tip-plain") ||
    chip.getAttribute("data-tip-text") ||
    "";

  const tipTech = chip.getAttribute("data-tip-tech") || "";
  const tipMistake = chip.getAttribute("data-tip-mistake") || "";

  const vidSrc = chip.getAttribute("data-video-src") || chip.dataset.videoSrc;
  const vidFrontSrc =
    chip.getAttribute("data-video-front-src") || chip.dataset.videoFrontSrc;

  const displayLabel = chip.getAttribute("data-display-ipa") || "";

  // Examples (optional)
  let words = [];
  const wordsRaw = chip.getAttribute("data-tip-words") || "";
  if (wordsRaw) {
    try {
      const parsed = JSON.parse(wordsRaw);
      if (Array.isArray(parsed)) words = parsed.filter(Boolean).slice(0, 3);
    } catch (_) {}
  }

  const panels = [
    {
      title: "Plain",
      text: tipPlain,
      empty: `No details available for /${ipa}/ yet.`,
    },
    {
      title: "Technical",
      text: tipTech,
      empty: "Technical note coming soon.",
    },
    {
      title: "Common mix-ups",
      text: tipMistake,
      empty: "No common mistakes recorded yet.",
    },
  ];

  // Topbar examples string
  const examplesStr = words.length
    ? `(${words.map(escapeHTML).join(", ")})`
    : displayLabel
    ? escapeHTML(displayLabel)
    : "";

  let html = `
    <div class="lux-ph-topbar">
      <div class="lux-ph-ipaBlock">
        <span class="lux-ph-ipa">/${escapeHTML(ipa)}/</span>
        ${
          examplesStr
            ? `<span class="lux-ph-examples">${examplesStr}</span>`
            : ``
        }
      </div>

      <div class="lux-ph-modeNav">
        <button id="lux-ph-panel-prev" class="lux-ph-nav-btn" type="button" aria-label="Previous panel">‹</button>
        <div id="lux-ph-modeTitle" class="lux-ph-modeTitle"></div>
        <button id="lux-ph-panel-next" class="lux-ph-nav-btn" type="button" aria-label="Next panel">›</button>
      </div>

      <button id="lux-ph-close" class="lux-ph-closeBtn" type="button" aria-label="Close">✕</button>
    </div>

    <!-- SINGLE panel text element (no duplicates anywhere else) -->
    <div id="lux-ph-panelText" class="lux-ph-panelText"></div>
  `;

  html += `
    ${
      vidSrc || vidFrontSrc
        ? `
  <div class="lux-ph-vidBox">
    <div class="lux-ph-vidControls">
      <div class="lux-ph-vidBtns">
        ${
          vidSrc
            ? `<button id="lux-ph-play-side" class="lux-ph-miniBtn" type="button">Side</button>`
            : ``
        }
        ${
          vidFrontSrc
            ? `<button id="lux-ph-play-front" class="lux-ph-miniBtn" type="button">Front</button>`
            : ``
        }
        ${
          vidSrc && vidFrontSrc
            ? `<button id="lux-ph-play-both" class="lux-ph-miniBtn" type="button">Both</button>`
            : ``
        }
        <button id="lux-ph-stop" class="lux-ph-miniBtn" type="button">Stop</button>

        <button id="lux-ph-expand" class="lux-ph-miniBtn is-primary" type="button">Expand</button>

        <button id="lux-ph-loop" class="lux-ph-miniBtn" type="button" data-loop="0">Repeat Off</button>

        <select id="lux-ph-speed" class="lux-ph-speed">
          <option value="0.4">0.4×</option>
          <option value="0.5">0.5×</option>
          <option value="0.6">0.6×</option>
          <option value="0.7">0.7×</option>
          <option value="0.8">0.8×</option>
          <option value="0.9">0.9×</option>
          <option value="1" selected>1×</option>
          <option value="1.1">1.1×</option>
          <option value="1.25">1.25×</option>
          <option value="1.4">1.4×</option>
          <option value="1.6">1.6×</option>
        </select>
      </div>

      <button id="lux-ph-sound" class="lux-ph-miniBtn" type="button" data-sound="1" aria-label="Toggle sound">
        🔊
      </button>
    </div>

    <div class="lux-ph-vidGrid" data-cols="${vidFrontSrc ? 2 : 1}">
      ${
        vidSrc
          ? `
      <div class="lux-ph-vidTile" data-vid="side">
        <video id="lux-global-video-side"
          data-vid="side"
          src="${vidSrc}"
          playsinline
          preload="metadata">
        </video>
        <div class="lux-ph-vidOverlay" aria-hidden="true"><span>▶</span></div>
        <div class="lux-ph-vidLabel">Side</div>
      </div>`
          : ``
      }

      ${
        vidFrontSrc
          ? `
      <div class="lux-ph-vidTile" data-vid="front">
        <video id="lux-global-video-front"
          data-vid="front"
          src="${vidFrontSrc}"
          playsinline
          preload="metadata">
        </video>
        <div class="lux-ph-vidOverlay" aria-hidden="true"><span>▶</span></div>
        <div class="lux-ph-vidLabel">Front</div>
      </div>`
          : ``
      }
    </div>
  </div>
`
        : ``
    }
  `;

  state.tooltipContent.innerHTML = html;

  // Wire carousel + video controls now that DOM exists
  initTooltipTextCarousel?.(state.globalTooltip, panels);
  initTooltipVideoControls?.(state.globalTooltip, {
    openVideoFocusModal,
  });

  // Close button
  const closeBtn = state.globalTooltip.querySelector("#lux-ph-close");
  if (closeBtn) {
    closeBtn.onclick = (e) => {
      e.preventDefault();
      e.stopPropagation();
      hideTooltip?.(state);
    };
  }

  // ---- Position (zero gap + clamp) ----
  const tip = state.globalTooltip;

  tip.style.visibility = "hidden";
  tip.style.opacity = "0";
  tip.style.top = `0px`;
  tip.style.left = `0px`;

  // Force layout pass so we can measure
  const rect = chip.getBoundingClientRect();
  const tipRect = tip.getBoundingClientRect();
  const tipW = tipRect.width || Math.min(560, window.innerWidth - 20);
  const tipH = tipRect.height || 320;

  const winH = window.innerHeight;

  let top = rect.bottom;
  let left = rect.left + rect.width / 2 - tipW / 2;

  if (top + tipH > winH - 10) top = rect.top - tipH;

  if (left < 10) left = 10;
  if (left + tipW > window.innerWidth - 10) left = window.innerWidth - tipW - 10;

  tip.style.top = `${Math.max(10, top)}px`;
  tip.style.left = `${left}px`;
  tip.style.visibility = "visible";
  tip.style.opacity = "1";
}
</file>

<file path="features/interactions/ph-hover/utils.js">
// features/interactions/ph-hover/utils.js
// Tiny pure helpers for the phoneme hover tooltip system.

export function escapeHTML(str) {
  return String(str).replace(/[&<>'"]/g, (tag) =>
    ({
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      "'": "&#39;",
      '"': "&quot;",
    }[tag])
  );
}
</file>

<file path="features/interactions/tips.js">
// ui/interactions/tips.js
export function animateMetricTips() {
  [
    "Accuracy",
    "Fluency",
    "Completeness",
    "Pronunciation",
    "Phonemes",
    "Prosody",
    "ProsodyBars",
  ].forEach((key, idx) => {
    const el = document.querySelector("#prettyResult .tip-" + key);
    if (!el) return;
    el.classList.remove("hidden");
    void el.offsetWidth;
    el.classList.add("hidden");
    setTimeout(() => {
      el.classList.remove("hidden");
      el.classList.add("pop-in");
      setTimeout(() => el.classList.remove("pop-in"), 1200);
    }, 800 + idx * 350);
  });
}
</file>

<file path="features/interactions/utils.js">
// ui/interactions/utils.js
export function safePlay(node, src, opts) {
  const f = window.safePlayVideo;
  if (typeof f === "function") return f(node, src, opts || {});
  try {
    if (src && node.src !== src) node.src = src;
    if (opts && "muted" in opts) node.muted = !!opts.muted;
    if (opts && opts.restart) {
      try {
        node.currentTime = 0;
      } catch (_) {}
    }
    return node.play?.().catch?.(() => {});
  } catch (_) {}
}

export function playWithGesture(
  vid,
  { restart = true, wantSound = true } = {}
) {
  if (!vid) return;
  try {
    vid.loop = false;
  } catch (_) {}
  if (restart) {
    try {
      vid.currentTime = 0;
    } catch (_) {}
  }
  vid.muted = !wantSound;
  return vid.play().catch(() => {
    vid.muted = true;
    return vid
      .play()
      .then(() => {
        if (wantSound)
          setTimeout(() => {
            try {
              vid.muted = false;
            } catch (_) {}
          }, 50);
      })
      .catch(() => {
        try {
          vid.pause();
        } catch (_) {}
      });
  });
}

export function prepareVideo(v) {
  if (!v) return;
  v.setAttribute("preload", "metadata");
  v.setAttribute("playsinline", "");
  v.playsInline = true;
  v.controls = false;
  v.loop = false;
  v.muted = true;
}
</file>

<file path="features/interactions/yg-hover.js">
// ui/interactions/yg-hover.js
import { safePlay } from "./utils.js";

export function setupYGHover() {
  const preview = document.getElementById("ygPreview");
  const demoVid = document.getElementById("ygDemo");
  const unmuteUI = document.getElementById("unmuteTip");
  const wordHdr = document.getElementById("wordHeader");
  const wordPill = wordHdr && wordHdr.querySelector(".word-chip");
  if (!preview || !demoVid || !wordHdr || !wordPill) return;
  if (wordPill._ygBound) return;
  wordPill._ygBound = true;

  function showPreview() {
    const rect = wordPill.getBoundingClientRect();
    preview.style.left = rect.right + 10 + "px";
    preview.style.top = rect.top + "px";
    preview.style.display = "block";
    safePlay(demoVid, demoVid.getAttribute("src"), {
      muted: true,
      restart: true,
    });
  }
  function hidePreview() {
    preview.style.display = "none";
    demoVid.pause();
    demoVid.currentTime = 0;
    demoVid.muted = true;
    if (unmuteUI) unmuteUI.style.display = "none";
    wordPill.classList.remove("is-playing");
  }
  function maybeHideFromPill(e) {
    const to = e.relatedTarget;
    if (to && (to === preview || preview.contains(to))) return;
    hidePreview();
  }
  function maybeHideFromPreview(e) {
    const to = e.relatedTarget;
    if (to && (to === wordPill || wordPill.contains(to))) return;
    hidePreview();
  }

  wordPill.addEventListener("mouseover", showPreview);
  wordPill.addEventListener("mouseout", maybeHideFromPill);
  preview.addEventListener("mouseout", maybeHideFromPreview);

  wordPill.addEventListener("click", (e) => {
    e.stopPropagation();
    demoVid.muted = !demoVid.muted;
    if (demoVid.paused) demoVid.play().catch(() => {});
    if (unmuteUI) {
      unmuteUI.textContent = demoVid.muted ? "Muted" : "Audio on";
      unmuteUI.style.display = "block";
      setTimeout(() => {
        unmuteUI.style.display = "none";
      }, 1500);
    }
    wordPill.classList.toggle("is-playing", !demoVid.muted);
  });
}
</file>

<file path="features/next-activity/next-activity.js">
// features/next-activity/next-activity.js
// Tiny glue: pick targets from rollups + store/consume a Next Activity plan.

import { norm } from "../../src/data/phonemes/core.js";

const KEY = "lux.nextActivity.v1";

export function saveNextActivityPlan(plan) {
  try {
    localStorage.setItem(KEY, JSON.stringify(plan));
  } catch (_) {}
}

export function consumeNextActivityPlan() {
  try {
    const raw = localStorage.getItem(KEY);
    if (!raw) return null;
    localStorage.removeItem(KEY);
    const plan = JSON.parse(raw);
    return plan && typeof plan === "object" ? plan : null;
  } catch (_) {
    try {
      localStorage.removeItem(KEY);
    } catch (_) {}
    return null;
  }
}

function uniq(arr) {
  const out = [];
  const seen = new Set();
  for (const x of arr || []) {
    const k = String(x || "").trim().toLowerCase();
    if (!k) continue;
    if (seen.has(k)) continue;
    seen.add(k);
    out.push(String(x).trim());
  }
  return out;
}

export function getPlanTargetWords(plan) {
  return uniq((plan?.targets?.words || []).map((w) => w?.word || w).filter(Boolean));
}

export function buildNextActivityPlanFromModel(model, opts = {}) {
  const trouble = model?.trouble || {};
  const ph = (trouble.phonemesAll || [])[0] || null;
  const words = (trouble.wordsAll || []).slice(0, opts.maxWords || 6);

  if (!ph && !words.length) return null;

  const now = Date.now();

  return {
    plan_version: "v1",
    kind: "ai_conversation",
    created_ts: now,
    source: opts.source || "unknown", // "session" | "global"
    confidence: opts.confidence || null,
    targets: {
      phoneme: ph ? pickPh(ph) : null,
      words: words.map(pickWord),
    },
  };
}

function pickPh(p) {
  return {
    // IMPORTANT: rollups may provide Azure codes (th/dh/ch/jh/iy/ax/etc).
    // Normalize to canonical IPA so overlays + testers stay consistent.
    ipa: norm(String(p.ipa || p.phoneme || p.id || "")),
    avg: num(p.avg),
    count: num(p.count),
    days: num(p.days),
    priority: num(p.priority),
  };
}

function pickWord(w) {
  return {
    word: String(w.word || ""),
    avg: num(w.avg),
    count: num(w.count),
    days: num(w.days),
    priority: num(w.priority),
  };
}

function num(x) {
  const n = Number(x);
  return Number.isFinite(n) ? n : null;
}

/**
 * Returns a prompt overlay string appended to scenario.desc.
 * The backend doesn't need to change: it already sees scenario.title/desc.
 */
export function buildConvoTargetOverlay(plan) {
  if (!plan || plan.kind !== "ai_conversation") return "";

  const ph = plan?.targets?.phoneme?.ipa ? norm(plan.targets.phoneme.ipa) : "";
  const topWords = getPlanTargetWords(plan).slice(0, 8);

  // Small hinting layer (optional, but helps precision for common IPA)
  function phonemeHint(ipa) {
    const k = String(ipa || "").trim();
    const map = {
      "ð": "voiced TH (this, that, mother)",
      "θ": "voiceless TH (think, three, bath)",
      "ɹ": "R (red, right, around)",
      "r": "R (red, right, around)",
      "ʃ": "SH (she, wish, fresh)",

      // Affricates: handle both glyph styles
      "tʃ": "CH (chair, teacher, lunch)",
      "ʧ": "CH (chair, teacher, lunch)",
      "dʒ": "J (job, orange, giant)",
      "ʤ": "J (job, orange, giant)",

      "ŋ": "NG (sing, going, long)",
    };
    return map[k] || "";
  }
  const phHint = ph ? phonemeHint(ph) : "";

  const lines = [
    "LUX_NEXT_PRACTICE (do NOT mention this label to the learner):",
    ph ? `Primary sound focus (IPA): ${ph}` : "",
    phHint ? `Plain-English cue: ${phHint}` : "",
    topWords.length ? `Word bank (use naturally, repeat often): ${topWords.join(", ")}` : "",
    "",
    "Coach rules:",
    "- Keep it a natural, friendly conversation.",
    "- Keep learner replies 1–2 sentences.",
    ph
      ? `- Increase density of the primary sound by favoring simple common words that contain ${ph}.`
      : "",
    "- Each turn: output JSON with keys: assistant (string) and suggested_replies (array).",
    "- suggested_replies MUST be EXACTLY 3 short options (1–2 sentences each).",
    "- CRITICAL: Each suggested reply MUST include at least ONE word from the word bank (if provided).",
    "- Prefer 2+ word-bank words per suggested reply when it still sounds natural.",
    "- Also include word-bank words in the assistant message when it fits naturally.",
    "- Marking (do NOT explain to the learner):",
    topWords.length ? "- Wrap WORD-BANK words exactly like {~word~}." : "",
    topWords.length
      ? "- IMPORTANT: Only use {~ ~} for words that appear in the word bank list above. Do NOT invent new {~ ~} words."
      : "",
    ph
      ? "- Wrap words that CONTAIN the focus sound (chosen specifically for phoneme practice) exactly like {^word^}."
      : "",
    ph
      ? "- Minimum quota: include at least 2 {^ ^} words in the assistant message each turn, and at least 1 {^ ^} word in EACH suggested reply."
      : "",
    ph
      ? "- Quality rule: ONLY mark {^ ^} if the word truly contains the focus sound. If unsure, choose a different word."
      : "",
    ph ? "- After drafting, verify every {^ ^} word truly contains the focus sound; if not, replace it." : "",
    ph && topWords.length
      ? "- If a word-bank word ALSO contains the focus sound, prefer marking it as {^word^} (this creates a double-hit in Lux)."
      : "",
    "- Do NOT explain these rules.",
    "- If the learner responds without using any word-bank words, gently retry with a suggested reply that includes one specific word-bank word, then move on.",
  ];

  // Extra help for /t/ — keep targets unambiguous and easy to mark correctly
  const ipa = String(ph || "").trim();
  if (ipa === "t" || ipa === "/t/") {
    lines.push(
      "",
      "Extra rules for /t/:",
      "- Prefer CLEAR /t/ words where the /t/ is easy to hear (especially word-initial /t/).",
      "- Safe /t/ words to use + mark often: {^time^}, {^take^}, {^today^}, {^talk^}, {^team^}, {^teacher^}, {^student^}, {^test^}, {^topic^}, {^tired^}, {^ticket^}.",
      "- If you are unsure a word really has a clear /t/, choose a different word."
    );
  }

  return lines.filter(Boolean).join("\n");
}
</file>

<file path="features/onboarding/lux-onboarding.js">
// features/onboarding/lux-onboarding.js
// Premium 4-card onboarding deck (do > explain)

const SEEN_KEY = "LUX_ONBOARD_V1_SEEN";

const STEPS = [
  {
    key: "welcome",
    stepLabel: "Welcome",
    title: "Welcome to Lux",
    bodyHtml: `
      <div>Master your pronunciation with 60-second sprints. Your progress saves automatically.</div>
    `,
    primary: { label: "Start setup" },
    secondary: { label: "Skip tour", kind: "link" },
  },
  {
    key: "mic",
    stepLabel: "Mic",
    title: "Enable your mic",
    bodyHtml: `
      <div>Tap below, then select <b>Allow</b> when your browser asks.</div>
      <div class="lux-onb-tip">
        <span class="lux-onb-tip-dot">i</span>
        <span><b>Tip:</b> quiet room + <b>good mic</b> = best scores</span>
      </div>
      <div class="lux-onb-meter" aria-label="Mic level meter"><span></span></div>
      <div id="luxOnbMicMsg" style="margin-top:10px; font-size:14px; color: rgba(31,41,55,0.62);"></div>
    `,
    primary: { label: "Allow microphone access", action: "requestMic" },
    secondary: { label: "Skip tour", kind: "link" },
  },
  {
    key: "try",
    stepLabel: "Try",
    title: "Your first recording",
    bodyHtml: `
      <div>Pick a short phrase and hit <b>Record</b>. We’ll analyze your speech and show results.</div>
    `,
    primary: { label: "● Try a sample phrase", action: "samplePhrase" }, // red-circle muscle memory
    secondary: { label: "Browse all lessons", action: "browseLessons", kind: "link" },
  },
  {
    key: "finish",
    stepLabel: "Finish",
    title: "See your growth",
    bodyHtml: `
      <div>After each session, you’ll get:</div>
      <ul class="lux-onb-bullets">
        <li><b>Scores</b>: Accuracy, Fluency, and Prosody</li>
        <li><b>Visuals</b>: mouth-shape videos for your trouble sounds</li>
      </ul>
    `,
    primary: { label: "Start practicing", action: "startPracticing" },
    secondary: { label: "Generate my next practice", action: "generateNext", kind: "link" },
  },
];

export function maybeShowOnboarding() {
  // Force open via ?onboard=1
  const params = new URLSearchParams(location.search);
  const force = params.get("onboard") === "1";

  if (!force && localStorage.getItem(SEEN_KEY) === "1") return;
  showOnboarding();
}

function showOnboarding() {
  const state = {
    i: 0,
    mic: { ready: false, stream: null, audioCtx: null, raf: null, analyser: null },
  };

  const overlay = document.createElement("div");
  overlay.className = "lux-onb-overlay";
  overlay.setAttribute("role", "dialog");
  overlay.setAttribute("aria-modal", "true");

  const card = document.createElement("div");
  card.className = "lux-onb-card";
  card.innerHTML = `
    <div class="lux-onb-accent"></div>

    <div class="lux-onb-header">
      <h2 class="lux-onb-title" id="luxOnbTitle"></h2>
      <button class="lux-onb-skip" id="luxOnbSkip" type="button">Skip</button>
    </div>

    <div class="lux-onb-body" id="luxOnbBody"></div>

    <div class="lux-onb-stepper" id="luxOnbStepper"></div>

    <div class="lux-onb-footer">
      <div class="lux-onb-left">
        <button class="lux-onb-btn" id="luxOnbPrev" type="button">Prev</button>
      </div>
      <div class="lux-onb-right">
        <button class="lux-onb-btn lux-onb-btn-link" id="luxOnbSecondary" type="button"></button>
        <button class="lux-onb-btn lux-onb-btn-primary" id="luxOnbPrimary" type="button"></button>
        <button class="lux-onb-btn" id="luxOnbDone" type="button" style="display:none;">Done</button>
      </div>
    </div>
  `;
  overlay.appendChild(card);
  document.body.appendChild(overlay);

  const $ = (sel) => card.querySelector(sel);

  const elTitle = $("#luxOnbTitle");
  const elBody = $("#luxOnbBody");
  const elStepper = $("#luxOnbStepper");
  const btnPrev = $("#luxOnbPrev");
  const btnPrimary = $("#luxOnbPrimary");
  const btnSecondary = $("#luxOnbSecondary");
  const btnDone = $("#luxOnbDone");
  const btnSkip = $("#luxOnbSkip");

  function close(markSeen = true) {
    stopMic(state);
    if (markSeen) localStorage.setItem(SEEN_KEY, "1");
    overlay.remove();
  }

  // Close on ESC
  function onKey(e) {
    if (e.key === "Escape") {
      e.preventDefault();
      close(true);
    }
  }
  document.addEventListener("keydown", onKey, { capture: true });

  // Click outside closes (optional)
  overlay.addEventListener("click", (e) => {
    if (e.target === overlay) close(true);
  });

  btnSkip.addEventListener("click", () => close(true));
  btnDone.addEventListener("click", () => close(true));

  btnPrev.addEventListener("click", () => {
    state.i = Math.max(0, state.i - 1);
    render();
  });

  btnSecondary.addEventListener("click", async () => {
    const step = STEPS[state.i];
    if (!step.secondary) return;

    if (step.secondary.action) await runAction(step.secondary.action);
    else close(true); // "Skip tour"
  });

  btnPrimary.addEventListener("click", async () => {
    const step = STEPS[state.i];

    // SPECIAL CASE:
    // Mic step primary is "requestMic" initially, but once ready it should act like Next.
    if (step.key === "mic" && state.mic.ready) {
      if (state.i < STEPS.length - 1) {
        state.i++;
        render();
      } else {
        close(true);
      }
      return;
    }

    if (step.primary?.action) {
      await runAction(step.primary.action);
      return;
    }

    // default primary = Next
    if (state.i < STEPS.length - 1) {
      state.i++;
      render();
    } else {
      close(true);
    }
  });

  async function runAction(action) {
    switch (action) {
      case "requestMic":
        await requestMic(state, card);
        // Re-render so the primary button becomes "Next" when mic is ready
        render();
        break;

      case "samplePhrase":
        trySamplePhrase();
        // After doing the action, advance
        state.i = Math.min(STEPS.length - 1, state.i + 1);
        render();
        break;

      case "browseLessons":
        close(true);
        tryBrowseLessons();
        break;

      case "startPracticing":
        close(true);
        tryStartPracticing();
        break;

      case "generateNext":
        close(true);
        tryGenerateNextPractice();
        break;

      default:
        // no-op
        break;
    }
  }

  function render() {
    const step = STEPS[state.i];
    elTitle.textContent = step.title;
    elBody.innerHTML = step.bodyHtml;

    // Stepper
    elStepper.innerHTML = STEPS.map((s, idx) => {
      const active = idx === state.i ? " is-active" : "";
      return `
        <div class="lux-onb-step${active}">
          <div class="lux-onb-dot"></div>
          <div class="lux-onb-label">${escapeHtml(s.stepLabel)}</div>
        </div>
      `;
    }).join("");

    // Buttons
    btnPrev.disabled = state.i === 0;

    const isLast = state.i === STEPS.length - 1;
    btnDone.style.display = isLast ? "inline-flex" : "none";

    // Secondary
    if (step.secondary) {
      btnSecondary.style.display = "inline-flex";
      btnSecondary.textContent = step.secondary.label;
      btnSecondary.className = step.secondary.kind === "link"
        ? "lux-onb-btn lux-onb-btn-link"
        : "lux-onb-btn";
    } else {
      btnSecondary.style.display = "none";
    }

    // Primary
    btnPrimary.textContent = step.primary?.label || (isLast ? "Done" : "Next");
    btnPrimary.classList.toggle("is-success", false);
    btnPrimary.disabled = false;

    // If mic is ready on mic step, allow Next
    if (step.key === "mic" && state.mic.ready) {
      btnPrimary.textContent = "Next";
      btnPrimary.disabled = false;
      btnPrimary.classList.remove("is-success");
      const msg = card.querySelector("#luxOnbMicMsg");
      if (msg) msg.textContent = "Mic ready ✓ Try speaking — you should see the meter move.";
    }

    // Always keep skip in top-right
    btnSkip.style.display = "inline-flex";

    // If we left mic step, stop the meter but keep permission (stream)
    if (step.key !== "mic") {
      stopMeterOnly(state);
    } else {
      // If we’re on mic step and already have analyser, resume meter
      resumeMeterIfPossible(state, card);
    }
  }

  render();

  // Clean up key handler on close
  const origClose = close;
  function closeWrapped(markSeen = true) {
    document.removeEventListener("keydown", onKey, { capture: true });
    origClose(markSeen);
  }

  // Rebind close to wrapped
  close = closeWrapped; // eslint-disable-line no-func-assign
}

/* ---------------- Actions ---------------- */

async function requestMic(state, card) {
  const stepPrimary = card.querySelector("#luxOnbPrimary");
  const msg = card.querySelector("#luxOnbMicMsg");

  try {
    stepPrimary.disabled = true;
    stepPrimary.textContent = "Requesting…";

    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    state.mic.stream = stream;
    state.mic.ready = true;

    if (msg) msg.textContent = "Mic ready ✓ Try speaking — you should see the meter move.";

    // Build analyser + start meter
    setupAnalyser(state);
    resumeMeterIfPossible(state, card);

    // Keep it clickable (render() will convert to "Next" on success)
    stepPrimary.classList.add("is-success");
    stepPrimary.disabled = false;
  } catch (err) {
    state.mic.ready = false;

    if (msg) {
      msg.textContent =
        "Mic blocked. Click the 🔒 icon in your browser bar to reset permissions.";
    }

    // Restore button so they can try again
    stepPrimary.disabled = false;
    stepPrimary.textContent = "Allow microphone access";
    stepPrimary.classList.remove("is-success");
  }
}

function setupAnalyser(state) {
  if (!state.mic.stream) return;

  // Reuse if already built
  if (state.mic.audioCtx && state.mic.analyser) return;

  const AudioCtx = window.AudioContext || window.webkitAudioContext;
  if (!AudioCtx) return;

  const audioCtx = new AudioCtx();
  const source = audioCtx.createMediaStreamSource(state.mic.stream);
  const analyser = audioCtx.createAnalyser();
  analyser.fftSize = 512;
  source.connect(analyser);

  state.mic.audioCtx = audioCtx;
  state.mic.analyser = analyser;
}

function resumeMeterIfPossible(state, card) {
  const span = card.querySelector(".lux-onb-meter > span");
  if (!span || !state.mic.analyser) return;

  // Stop any prior loop
  stopMeterOnly(state);

  const analyser = state.mic.analyser;
  const data = new Uint8Array(analyser.frequencyBinCount);

  function tick() {
    analyser.getByteTimeDomainData(data);

    // crude energy estimate (0..1)
    let sum = 0;
    for (let i = 0; i < data.length; i++) {
      const v = (data[i] - 128) / 128;
      sum += v * v;
    }
    const rms = Math.sqrt(sum / data.length);

    // map to scaleX (keep ghosty, never fully flat)
    const scale = Math.min(1, Math.max(0.10, rms * 3.2));
    span.style.transform = `scaleX(${scale.toFixed(3)})`;

    state.mic.raf = requestAnimationFrame(tick);
  }

  state.mic.raf = requestAnimationFrame(tick);
}

function stopMeterOnly(state) {
  if (state.mic.raf) cancelAnimationFrame(state.mic.raf);
  state.mic.raf = null;
}

function stopMic(state) {
  stopMeterOnly(state);

  if (state.mic.audioCtx) {
    try { state.mic.audioCtx.close(); } catch (_) {}
  }
  state.mic.audioCtx = null;
  state.mic.analyser = null;

  if (state.mic.stream) {
    try { state.mic.stream.getTracks().forEach((t) => t.stop()); } catch (_) {}
  }
  state.mic.stream = null;
  state.mic.ready = false;
}

function trySamplePhrase() {
  const sample = "The quick brown fox jumps over the lazy dog.";

  // Try: textarea with your placeholder text
  const ta = Array.from(document.querySelectorAll("textarea"))
    .find((t) => (t.getAttribute("placeholder") || "").toLowerCase().includes("paste or type"));

  if (ta) {
    ta.focus();
    ta.value = sample;
    ta.dispatchEvent(new Event("input", { bubbles: true }));
    return;
  }

  // Fallback: copy to clipboard
  try { navigator.clipboard.writeText(sample); } catch (_) {}
}

function tryBrowseLessons() {
  // If you have a “Browse” button/link, click it.
  // Add a data attribute on your real button (recommended): data-lux-browse-lessons
  document.querySelector("[data-lux-browse-lessons]")?.click();
}

function tryStartPracticing() {
  // Focus your Record button if present
  const btn =
    document.querySelector("[data-lux-record]") ||
    Array.from(document.querySelectorAll("button")).find((b) =>
      (b.textContent || "").trim().toLowerCase() === "record"
    );

  btn?.focus?.();
}

function tryGenerateNextPractice() {
  // Your app already has this button — easiest is tag it with data-lux-generate-next
  document.querySelector("[data-lux-generate-next]")?.click();
}

function escapeHtml(s) {
  return String(s).replace(/[&<>"']/g, (c) => ({
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;",
  }[c]));
}
</file>

<file path="features/passages/dom.js">
// features/passages/dom.js
// Pure DOM manipulation for passage navigation and inputs.
// CLEANED: Balloon logic moved to features/balloon/

import { qs, setText, setVisible } from "../../app-core/lux-utils.js";

const ui = {
  get select() { return qs("#passageSelect"); },
  get input() { return qs("#referenceText"); },
  get suggested() { return qs("#suggestedSentence"); },
  get progress() { return qs("#partProgress"); },
  get label() { return qs("#passageLabel"); },
  get nextBtn() { return qs("#nextPartBtn"); },
  get nextMsg() { return qs("#nextPartMsg"); },
  get summaryBtn() { return qs("#showSummaryBtn"); },
  get tip() { return qs("#partsInfoTip"); },
  get tipText() { return qs("#partsInfoTip .tooltiptext"); },
  get pretty() { return qs("#prettyResult"); },
  get status() { return qs("#status"); },
  get aiBox() { return qs("#aiFeedback"); },
  get showMore() { return qs("#showMoreBtn"); },
};

/* --- Read --- */

export function getSelectValue() {
  return ui.select?.value || "";
}

export function getInputValue() {
  return ui.input?.value || "";
}

export function isSelectCustom() {
  const val = ui.select?.value || "";
  const label = ui.select?.selectedOptions?.[0]?.textContent || "";
  return val === "custom" || /write.*own/i.test(label);
}

/* --- Write --- */

export function ensureCustomOptionInDOM() {
  const sel = ui.select;
  if (!sel) return;
  
  if (!sel.querySelector('option[value="custom"]')) {
    const opt = document.createElement("option");
    opt.value = "custom";
    opt.textContent = "✍️ Write your own…";
    sel.insertBefore(opt, sel.firstChild);
  }
}

export function forceSelectCustom() {
  if (ui.select) ui.select.value = "custom";
}

export function renderInfoTip({ visible, textHTML }) {
  const t = ui.tip;
  if (!t) return;
  
  if (!visible) {
    t.classList.add("hidden");
  } else {
    t.classList.remove("hidden");
    if (ui.tipText) ui.tipText.innerHTML = textHTML;
  }
}

export function renderPartState({ 
  text, 
  progressText, 
  labelText, 
  showLabel, 
  preserveInput 
}) {
  if (ui.suggested) ui.suggested.textContent = text; 
  if (ui.input && !preserveInput) ui.input.value = text;
  if (ui.progress) ui.progress.textContent = progressText;
  
  if (ui.label) {
    setVisible(ui.label, showLabel);
    setText(ui.label, labelText);
  }
}

export function updateNavVisibility({ showNext, enableNext, nextMsgText, nextMsgColor, showSummary, customMode }) {
  if (ui.nextBtn) {
    setVisible(ui.nextBtn, showNext);
    ui.nextBtn.disabled = !enableNext;
    
    if (customMode) {
        ui.nextBtn.textContent = "➕ Add Another Section";
        ui.nextBtn.style.backgroundColor = "#0f766e"; // Teal
    } else {
        ui.nextBtn.textContent = "Next Part"; 
        ui.nextBtn.style.backgroundColor = ""; 
    }
  }

  if (ui.nextMsg) {
    setText(ui.nextMsg, nextMsgText);
    setVisible(ui.nextMsg, !!nextMsgText);
    if (nextMsgColor) ui.nextMsg.style.color = nextMsgColor;
    if (nextMsgText) {
        ui.nextMsg.style.display = "inline-block";
        ui.nextMsg.style.marginLeft = "10px";
    }
  }

  if (ui.summaryBtn) {
    if (showSummary !== undefined) {
        setVisible(ui.summaryBtn, showSummary);
        ui.summaryBtn.disabled = !showSummary;
        
        if (customMode) {
            ui.summaryBtn.textContent = "Finish & View Summary";
        } else {
            ui.summaryBtn.textContent = "Show Summary";
        }
    }
  }
}

export function clearResultsUI() {
  if (ui.pretty) ui.pretty.innerHTML = "";
  if (ui.status) ui.status.textContent = "Not recording";
  if (ui.aiBox) {
    ui.aiBox.style.display = "none";
    ui.aiBox.innerHTML = "";
  }
  setVisible(ui.showMore, false);
}

/* --- Events --- */

export function wireSelectEvents({ onChange, onClick }) {
  if (ui.select) {
    ui.select.addEventListener("change", (e) => onChange(e.target.value));
    ui.select.addEventListener("click", onClick);
  }
}

export function wireInputEvents({ onInput }) {
  if (ui.input) {
    ui.input.addEventListener("input", (e) => onInput(e.target.value));
  }
}

export function wireNextBtnEvent(onNext) {
  if (ui.nextBtn) {
    ui.nextBtn.addEventListener("click", onNext);
  }
}
</file>

<file path="features/passages/index.js">
// features/passages/index.js
// Controller: Manages passage state and orchestrates DOM updates.
// UPDATED: Universal Balloon Support + Confetti Pop on Summary.

import { passages } from "../../src/data/index.js"; 
import {
  setCustom,
  setPassageKey,
  setPartIdx,
  setParts,
  currentParts,
  currentPartIdx,
  currentPassageKey,
  isCustom,
} from "../../app-core/state.js"; 
import * as DOM from "./dom.js"; 
import { updateBalloon, popBalloon } from "../balloon/index.js";

/* ---------------- Logic / Helpers ---------------- */

const TIPS = {
  curated: `These built-in texts were designed to cover most English sounds. 
Practicing them gives a balanced baseline and helps reveal strengths & weaknesses.`,
  custom: `Type anything you want to practice. We’ll score words & phonemes and add prosody feedback. 
Tip: shorter sentences (≈10–15 s) give the clearest results.`
};

const MAX_CUSTOM_PARTS = 15;

export function ensureCustomOption() {
  DOM.ensureCustomOptionInDOM();
  if (isCustom) {
    DOM.forceSelectCustom();
  }
}

export function isCustomMode() {
  if (typeof isCustom === "boolean") return isCustom;
  return DOM.isSelectCustom();
}

export function updatePartsInfoTip() {
  const hasText = !!DOM.getInputValue().trim();
  const hasSelection = !!DOM.getSelectValue();
  const custom = isCustomMode();

  DOM.renderInfoTip({
    visible: hasText || hasSelection,
    textHTML: custom ? TIPS.custom : TIPS.curated
  });
}

export function togglePartNav(enabled) {
  const total = Array.isArray(currentParts) ? currentParts.length : 0;
  const isMulti = enabled && total > 1;

  if (!isMulti && !isCustom) {
    DOM.updateNavVisibility({ 
      showNext: false, 
      enableNext: false, 
      nextMsgText: "",
      showSummary: true
    });
    return;
  }

  const atLast = currentPartIdx >= total - 1;

  DOM.updateNavVisibility({
    showNext: !atLast,
    enableNext: !atLast,
    nextMsgText: !atLast ? "Record to continue." : "",
    nextMsgColor: "#666",
    showSummary: false
  });
}

/* ---------------- Core Actions ---------------- */

export function showCurrentPart({ preserveExistingInput = false } = {}) {
  const total = Array.isArray(currentParts) ? currentParts.length : 0;

  if (isCustom) {
    const txt = currentParts?.[currentPartIdx] ?? "";
    
    DOM.renderPartState({
      text: txt,
      progressText: `Custom Part ${currentPartIdx + 1}`,
      labelText: "Your text:",
      showLabel: true,
      preserveInput: preserveExistingInput
    });
    
    // Custom: Fill based on count vs MAX (15)
    updateBalloon(currentParts.length, MAX_CUSTOM_PARTS);
    
    togglePartNav(false);
  } else {
    const text = currentParts[currentPartIdx];
    const name = passages[currentPassageKey]?.name || "Passage";
    
    DOM.renderPartState({
      text: text,
      progressText: `Part ${currentPartIdx + 1} of ${total}`,
      labelText: `${name}:`,
      showLabel: currentPartIdx === 0,
      preserveInput: false
    });
    
    // Curated: Fill based on current index vs Total Parts
    // We add 1 to index so it starts partially full (Part 1 of 12)
    updateBalloon(currentPartIdx, total);
    
    togglePartNav(total > 1);
  }
}

export function setPassage(key, { clearInputForCustom = false } = {}) {
  setCustom(key === "custom");
  setPassageKey(key);
  setPartIdx(0);

  if (isCustom) {
    const nextText = clearInputForCustom ? "" : DOM.getInputValue();
    setParts([nextText]);
    showCurrentPart({ preserveExistingInput: !clearInputForCustom });
  } else {
    const p = passages[key]?.parts || [];
    setParts(p);
    showCurrentPart();
  }

  DOM.clearResultsUI();
}

export function goToNextPart() {
  if (isCustom) {
      if (currentParts.length >= MAX_CUSTOM_PARTS) {
          alert(`Memory Full! You have reached the limit of ${MAX_CUSTOM_PARTS} recordings. Please view your summary now.`);
          return;
      }
      
      const newParts = [...currentParts, ""];
      setParts(newParts);
      setPartIdx(currentPartIdx + 1);
      
      showCurrentPart({ preserveExistingInput: false });
      DOM.clearResultsUI();
      
      const input = document.querySelector("#referenceText");
      if(input) input.focus();
      return;
  }

  if (currentPartIdx < currentParts.length - 1) {
    setPartIdx(currentPartIdx + 1);
    showCurrentPart();
    DOM.clearResultsUI();
  }
}

export function markPartCompleted() {
  const total = Array.isArray(currentParts) ? currentParts.length : 0;

  if (isCustom) {
      const isFull = currentParts.length >= MAX_CUSTOM_PARTS;
      DOM.updateNavVisibility({
          showNext: !isFull, 
          enableNext: !isFull,
          nextMsgText: isFull ? "Memory Full (Limit 15)" : "",
          nextMsgColor: isFull ? "#ef4444" : "",
          showSummary: true,
          customMode: true 
      });
      // Custom: update count
      updateBalloon(currentParts.length, MAX_CUSTOM_PARTS);
      return;
  }

  if (total <= 1) return;

  const atLast = currentPartIdx >= total - 1;

  if (!atLast) {
    DOM.updateNavVisibility({
      showNext: true,
      enableNext: true,
      nextMsgText: "Finished: Ready for your next one?",
      nextMsgColor: "#15803d",
      showSummary: false
    });
    // Curated: Update progress (current part finished)
    updateBalloon(currentPartIdx + 1, total);
  } else {
    DOM.updateNavVisibility({
      showNext: false,
      enableNext: false,
      nextMsgText: "",
      showSummary: true
    });
    // Curated: Full!
    updateBalloon(total, total);
  }
}

/* ---------------- Wiring ---------------- */

export function wirePassageSelect() {
  DOM.wireSelectEvents({
    onChange: (val) => {
      setPassage(val, { clearInputForCustom: val === "custom" });
      updatePartsInfoTip();
    },
    onClick: () => {
      const el = document.querySelector("#suggestedSentence");
      const empty = !el?.textContent?.trim();
      if (empty && !isCustom) showCurrentPart();
    }
  });

  DOM.wireInputEvents({
    onInput: (val) => {
      if (!isCustom) {
        DOM.forceSelectCustom();
        setPassage("custom", { clearInputForCustom: false });
      }
      
      const updatedParts = [...currentParts];
      updatedParts[currentPartIdx] = val;
      setParts(updatedParts);
      
      DOM.renderPartState({ 
        text: "", 
        progressText: `Custom Part ${currentPartIdx + 1}`, 
        labelText: "Your text:", 
        showLabel: true,
        preserveInput: true 
      });
      updatePartsInfoTip();
    }
  });
  
  // GLOBAL POP HANDLER (For both modes)
  const summaryBtn = document.getElementById('showSummaryBtn');
  if (summaryBtn) {
      summaryBtn.addEventListener('click', () => {
          popBalloon();
      });
  }
}

export function wireNextBtn() {
  DOM.wireNextBtnEvent(goToNextPart);
  const total = Array.isArray(currentParts) ? currentParts.length : 0;
  togglePartNav(total > 1);
  updatePartsInfoTip();
}
</file>

<file path="features/progress/attempt-detail-modal.js">
// features/progress/attempt-detail-modal.js
// Orchestrator: builds session model + composes modal sections.
// Session "Attempt Details" modal (micro-report) used by Progress History drill-in.

import { computeRollups } from "./rollups.js";
import { fmtDateTime, titleFromPassageKey } from "./attempt-detail/format.js";
import { attemptMetric } from "./attempt-detail/metrics.js";
import { pillKV, chipRowWords, chipRowPhonemes } from "./attempt-detail/chips.js";
import { computeConfidence, buildNextActions, buildFocusWordsFallbackHtml } from "./attempt-detail/derive.js";
import { buildAttemptsListSection } from "./attempt-detail/attempts-section.js";
import { buildAiCoachMemorySection } from "./attempt-detail/ai-coach-section.js";
import { createAttemptDetailModalShell } from "./attempt-detail/modal-shell.js";
import { wireAttemptDetailChipExplainers } from "./attempt-detail/chip-explainers.js";
import { buildAttemptDetailHeader } from "./attempt-detail/header.js";
import { buildTroubleSoundsSection, buildTroubleWordsSection } from "./attempt-detail/trouble-sections.js";
import { esc, getColorConfig, mdToHtml, mean } from "./progress-utils.js";
import { pickTS, pickPassageKey, pickSessionId, pickSummary } from "./attempt-pickers.js";

import {
  buildNextActivityPlanFromModel,
  saveNextActivityPlan,
} from "../next-activity/next-activity.js";

/**
 * openDetailsModal(attempt, overallScore, dateStr, ctx?)
 * ctx can include:
 *   { sid, list: Attempt[], session: {sessionId, passageKey, count, tsMin, tsMax, avgScore, hasAI} }
 */
export function openDetailsModal(attempt, overallScore, dateStr, ctx = {}) {
  const existing = document.getElementById("lux-detail-modal");
  if (existing) existing.remove();

  const list = Array.isArray(ctx?.list) && ctx.list.length ? ctx.list.slice() : [attempt].filter(Boolean);

  // Sort desc by time (latest first)
  list.sort((a, b) => +new Date(pickTS(b) || 0) - +new Date(pickTS(a) || 0));

  const sid =
    ctx?.sid ||
    ctx?.session?.sessionId ||
    pickSessionId(list[0]) ||
    "";

  const pk =
    ctx?.session?.passageKey ||
    pickPassageKey(list[0]) ||
    "";

  const tsMax =
    ctx?.session?.tsMax ??
    Math.max(...list.map((a) => +new Date(pickTS(a) || 0)));

  const tsMin =
    ctx?.session?.tsMin ??
    Math.min(...list.map((a) => +new Date(pickTS(a) || 0)));

  // Session rollups (consistent trouble logic + summary-only support)
  const sessionModel = computeRollups(list, {
    windowDays: 30,
    minWordCount: 1,
    minPhonCount: 1,
  });
  const trouble = sessionModel?.trouble || {};
  const totals = sessionModel?.totals || {};

  // Keep the exact arrays used to render chips (so data-idx lines up)
  const phItems = (trouble.phonemesAll || []).slice(0, 12);
  const wdItems = (trouble.wordsAll || []).slice(0, 12);

  // Scores (session average)
  const pronAvg =
    Number.isFinite(totals.avgScore) ? totals.avgScore : Number(overallScore) || 0;

  const accAvg = mean(list.map((a) => attemptMetric(a, "acc")));
  const fluAvg = mean(list.map((a) => attemptMetric(a, "flu")));
  const compAvg = mean(list.map((a) => attemptMetric(a, "comp")));
  const prosAvg = mean(list.map((a) => attemptMetric(a, "pros")));

  const isNoSess = String(sid).startsWith("nosess:");
  const dayGroup = isNoSess ? String(sid).slice("nosess:".length) : "";

  const title = titleFromPassageKey(pk);
  const mode = String(pk).startsWith("convo:") ? "AI Conversations" : "Pronunciation Practice";

  const isConvo = String(pk).startsWith("convo:");
  const practiceHref = isConvo ? "./convo.html#chat" : "./index.html";
  const chooseHref = isConvo ? "./convo.html#picker" : "./index.html";

  const attemptsCount = list.length;

  // Confidence badge (tiny clarity layer)
  const confidence = computeConfidence(list, sid);
  const confidenceLabel = confidence.label;
  const confidenceHint = confidence.hint;

  // Derive next-action bullets from top priorities
  const nextActions = buildNextActions(trouble, title);

  // Latest attempt quick fallback (for small sessions with no trouble lists yet)
  const latest = list[0];
  const latestSum = pickSummary(latest) || {};

  // Fallback focus words list (latest attempt summary.words)
  const focusWordsFallbackHtml = buildFocusWordsFallbackHtml(latestSum);

  // Modal shell
  const { modal, card, close, mount } = createAttemptDetailModalShell();

  const { header, againBtn, chooseBtn } = buildAttemptDetailHeader({
    title,
    mode,
    attemptsCount,
    tsMin,
    tsMax,
    fmtDateTime,
    sid,
    isNoSess,
    dayGroup,
    pronAvg,
    list,
    attemptMetric,
    confidenceLabel,
    confidenceHint,
    nextActions,
    isConvo,
  });

  card.appendChild(header);

  // Trouble Sounds
  card.appendChild(buildTroubleSoundsSection(phItems));

  // Trouble Words
  card.appendChild(buildTroubleWordsSection(wdItems, focusWordsFallbackHtml));

  // Attempts list (collapsed)
  card.appendChild(buildAttemptsListSection(list));

  // AI Coach Memory (across session)
  const aiCoachEl = buildAiCoachMemorySection(list);
  if (aiCoachEl) card.appendChild(aiCoachEl);

  mount();

  if (againBtn) {
    againBtn.addEventListener("click", (e) => {
      e.preventDefault();

      const plan = buildNextActivityPlanFromModel(sessionModel, {
        source: "session",
        confidence: { level: confidenceLabel, hint: confidenceHint },
      });

      if (plan) {
        saveNextActivityPlan(plan);
        close();
        window.location.assign("./convo.html#chat");
        return;
      }

      close();
      window.location.assign(practiceHref);
    });
  }

  if (chooseBtn) {
    chooseBtn.addEventListener("click", (e) => {
      e.preventDefault();
      close();
      window.location.assign(chooseHref);
    });
  }

  // --- Inline micro-explainer wiring (click chip => explain below section) ---
  wireAttemptDetailChipExplainers(card, { phItems, wdItems });
}
</file>

<file path="features/progress/attempt-detail/ai-coach-section.js">
// features/progress/attempt-detail/ai-coach-section.js
// Builds the "AI Coach Memory" section for the Attempt Details modal.

import { pickTS, pickSummary } from "../attempt-pickers.js";
import { mdToHtml } from "../progress-utils.js";
import { fmtDateTime } from "./format.js";

export function buildAiCoachMemorySection(list) {
  // AI Coach Memory (across session)
  const aiAttemptGroups = (list || [])
    .map((a) => {
      const sum = pickSummary(a) || {};
      const secs = sum?.ai_feedback?.sections;
      if (!Array.isArray(secs) || !secs.length) return null;
      return { ts: pickTS(a), sections: secs };
    })
    .filter(Boolean);

  if (!aiAttemptGroups.length) return null;

  const totalSecs = aiAttemptGroups.reduce((n, g) => n + (g.sections?.length || 0), 0);

  const aiContainer = document.createElement("div");
  aiContainer.style.cssText = "border-top: 1px solid #e2e8f0; padding-top: 12px; margin-top: 12px;";

  aiContainer.innerHTML = `
    <details>
      <summary style="cursor:pointer; font-weight:900; color:#334155;">🧠 AI Coach Memory (${totalSecs})</summary>
      <div style="margin-top:10px; max-height: 320px; overflow-y:auto;"></div>
    </details>
  `;

  const listDiv = aiContainer.querySelector("details > div");

  aiAttemptGroups.forEach((g) => {
    const groupHead = document.createElement("div");
    groupHead.style.cssText = "margin:12px 0 8px; font-weight:900; color:#64748b;";
    groupHead.textContent = fmtDateTime(g.ts);
    listDiv.appendChild(groupHead);

    g.sections.forEach((sec) => {
      const item = document.createElement("div");
      item.style.cssText =
        "background:#f0f9ff; border:1px solid #bae6fd; border-radius:8px; padding:12px; margin-bottom:10px;";

      const titleEn = sec?.title || "Coach Tip";
      const contentL1 = sec?.l1;
      const contentEn = sec?.en || sec?.content || "";
      const hasL1 = !!contentL1;
      let isShowingL1 = hasL1;

      const h = document.createElement("div");
      h.style.cssText = "font-weight:900; color:#0369a1; font-size:0.9em; margin-bottom:6px;";
      h.textContent = `${sec?.emoji || "🤖"} ${titleEn}`;
      item.appendChild(h);

      const contentDiv = document.createElement("div");
      contentDiv.style.cssText = "color:#334155; font-size:0.9em; line-height:1.5;";
      contentDiv.innerHTML = mdToHtml(hasL1 ? contentL1 : contentEn);
      item.appendChild(contentDiv);

      if (hasL1) {
        const btn = document.createElement("button");
        btn.textContent = "Show English 🇺🇸";
        btn.style.cssText =
          "margin-top:8px; font-size:0.8em; padding:4px 8px; cursor:pointer; background:#fff; border:1px solid #bae6fd; border-radius:6px; color:#0284c7; font-weight:900;";
        btn.onclick = () => {
          if (isShowingL1) {
            contentDiv.innerHTML = mdToHtml(contentEn);
            btn.textContent = "Show Original ↩️";
            isShowingL1 = false;
          } else {
            contentDiv.innerHTML = mdToHtml(contentL1);
            btn.textContent = "Show English 🇺🇸";
            isShowingL1 = true;
          }
        };
        item.appendChild(btn);
      }

      listDiv.appendChild(item);
    });
  });

  return aiContainer;
}
</file>

<file path="features/progress/attempt-detail/attempts-section.js">
// features/progress/attempt-detail/attempts-section.js
// Builds the "Attempts in this session" section for the Attempt Details modal.

import { esc } from "../progress-utils.js";
import { pickTS, pickSummary } from "../attempt-pickers.js";
import { fmtDateTime } from "./format.js";
import { attemptMetric } from "./metrics.js";

export function buildAttemptsListSection(list, { maxItems = 20 } = {}) {
  const attemptsCount = Array.isArray(list) ? list.length : 0;

  // Attempts list (collapsed)
  const attemptsWrap = document.createElement("div");
  attemptsWrap.style.cssText = "border-top: 1px solid #e2e8f0; padding-top: 12px; margin-top: 12px;";
  attemptsWrap.innerHTML = `
    <details>
      <summary style="cursor:pointer; font-weight:900; color:#334155;">🕘 Attempts in this session (${attemptsCount})</summary>
      <div style="margin-top:10px;"></div>
    </details>
  `;

  const attemptsBody = attemptsWrap.querySelector("details > div");

  (list || []).slice(0, maxItems).forEach((a) => {
    const ts = pickTS(a);
    const sum = pickSummary(a) || {};
    const pron = attemptMetric(a, "pron");
    const acc = attemptMetric(a, "acc");
    const flu = attemptMetric(a, "flu");
    const pros = attemptMetric(a, "pros");
    const text = String(a?.text || "").trim();

    const pills = [];
    if (pron != null) pills.push(`Pron ${Math.round(pron)}`);
    if (acc != null) pills.push(`Acc ${Math.round(acc)}`);
    if (flu != null) pills.push(`Flu ${Math.round(flu)}`);
    if (pros != null) pills.push(`Pro ${Math.round(pros)}`);

    const item = document.createElement("div");
    item.style.cssText =
      "background:#f8fafc; border:1px solid #e2e8f0; border-radius:10px; padding:10px; margin-bottom:10px;";
    item.innerHTML = `
      <div style="display:flex; justify-content:space-between; gap:10px; align-items:flex-start;">
        <div style="font-weight:900; color:#334155;">${esc(fmtDateTime(ts))}</div>
        <div style="display:flex; gap:6px; flex-wrap:wrap;">
          ${pills
            .map(
              (t) =>
                `<span style="background:#fff; border:1px solid #e2e8f0; border-radius:999px; padding:3px 8px; font-weight:900; color:#475569; font-size:0.82rem;">${esc(
                  t
                )}</span>`
            )
            .join("")}
        </div>
      </div>
      ${
        text
          ? `<details style="margin-top:8px;">
              <summary style="cursor:pointer; font-weight:900; color:#334155;">📝 Text</summary>
              <div style="margin-top:8px; color:#475569; line-height:1.45;">${esc(text)}</div>
            </details>`
          : ""
      }
    `;

    attemptsBody.appendChild(item);
  });

  return attemptsWrap;
}
</file>

<file path="features/progress/attempt-detail/chip-explainers.js">
// features/progress/attempt-detail/chip-explainers.js
// Wires up click/keyboard behavior for trouble chips to show an inline explainer panel.

import { esc } from "../progress-utils.js";

export function wireAttemptDetailChipExplainers(card, { phItems = [], wdItems = [] } = {}) {
  if (!card) return;

  const explainSounds = card.querySelector("#luxExplainSounds");
  const explainWords = card.querySelector("#luxExplainWords");

  let lastPick = ""; // `${kind}:${idx}`

  function showExplain(kind, idx) {
    const key = `${kind}:${idx}`;
    const same = key === lastPick;
    lastPick = same ? "" : key;

    const panel = kind === "phoneme" ? explainSounds : explainWords;
    const items = kind === "phoneme" ? phItems : wdItems;

    if (!panel) return;

    if (same) {
      panel.innerHTML = "";
      panel.setAttribute("hidden", "");
      return;
    }

    const item = items[idx];
    if (!item) return;

    const avg = Math.round(Number(item.avg) || 0);
    const count = Number(item.count) || 0;
    const days = Number(item.days) || 1;
    const pr = Number.isFinite(item.priority) ? item.priority.toFixed(2) : "—";

    const label = kind === "phoneme" ? `Sound ${esc(item.ipa)}` : `Word ${esc(item.word)}`;

    const examples =
      kind === "phoneme" && Array.isArray(item.examples) && item.examples.length
        ? `<div style="margin-top:8px; color:#475569;"><span style="font-weight:900;">Examples:</span> ${esc(
            item.examples.join(", ")
          )}</div>`
        : "";

    panel.innerHTML = `
      <div style="background:#f8fafc; border:1px solid #e2e8f0; border-radius:12px; padding:12px;">
        <div style="display:flex; align-items:flex-start; justify-content:space-between; gap:10px;">
          <div>
            <div style="font-weight:900; color:#334155;">${label}</div>
            <div style="margin-top:4px; color:#64748b; font-weight:800; font-size:0.92rem;">
              Seen ${count}× · ${days} day(s) · Priority ${esc(pr)}
            </div>
          </div>
          <div style="font-weight:900; color:#334155; border:1px solid #e2e8f0; background:#fff; border-radius:999px; padding:6px 10px;">
            Avg ${avg}%
          </div>
        </div>
        ${examples}
        <div style="margin-top:10px; color:#64748b; font-size:0.92rem;">
          <span style="font-weight:900;">Why it’s here:</span> low accuracy + repeated exposure (count/days) increases priority.
        </div>
      </div>
    `;

    panel.removeAttribute("hidden");
    try {
      panel.scrollIntoView({ block: "nearest" });
    } catch (_) {}
  }

  function bindChip(chip) {
    const kind = chip.getAttribute("data-kind");
    const idx = Number(chip.getAttribute("data-idx"));
    if (!kind || !Number.isFinite(idx)) return;

    chip.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();
      showExplain(kind, idx);
    });

    chip.addEventListener("keydown", (e) => {
      if (e.key === "Enter" || e.key === " ") {
        e.preventDefault();
        showExplain(kind, idx);
      }
    });
  }

  card.querySelectorAll(".lux-chip[data-kind][data-idx]").forEach(bindChip);
}
</file>

<file path="features/progress/attempt-detail/chips.js">
// features/progress/attempt-detail/chips.js
// Small HTML render helpers for Attempt Details modal.

import { esc, getColorConfig } from "../progress-utils.js";

export function pillKV(label, val) {
  return `
    <div style="background:#f8fafc; padding:8px; border-radius:8px; text-align:center;">
      <div style="font-size:0.75rem; color:#64748b; text-transform:uppercase; font-weight:700;">${esc(
        label
      )}</div>
      <div style="font-weight:800; color:#334155;">${val}</div>
    </div>
  `;
}

export function chipRowWords(items = []) {
  if (!items.length) {
    return `<p style="color:#94a3b8; font-style:italic;">Not enough word data in this session yet.</p>`;
  }
  return `
    <div class="lux-chiprow">
      ${items
        .slice(0, 12)
        .map(
          (w, i) => `
        <span
          class="lux-chip"
          data-kind="word"
          data-idx="${i}"
          role="button"
          tabindex="0"
          title="${esc(
            `Seen ${w.count}× · ${w.days || 1} day(s) · priority ${
              Number.isFinite(w.priority) ? w.priority.toFixed(2) : "—"
            }`
          )}"
        >
          <span>${esc(w.word)}</span>
          <span class="lux-pill ${
            w.avg >= 80 ? "lux-pill--blue" : w.avg >= 60 ? "lux-pill--yellow" : "lux-pill--red"
          }">${Math.round(Number(w.avg) || 0)}%</span>
        </span>
      `
        )
        .join("")}
    </div>
  `;
}

export function chipRowPhonemes(items = []) {
  if (!items.length) {
    return `<p style="color:#94a3b8; font-style:italic;">Not enough sound data in this session yet.</p>`;
  }
  return `
    <div class="lux-chiprow">
      ${items
        .slice(0, 12)
        .map((p, i) => {
          const ex =
            Array.isArray(p.examples) && p.examples.length
              ? `<div style="margin-top:4px; color:#94a3b8; font-size:0.82rem; font-weight:800;">e.g., ${esc(
                  p.examples.join(", ")
                )}</div>`
              : ``;

          return `
          <div style="display:inline-block;">
            <span
              class="lux-chip"
              data-kind="phoneme"
              data-idx="${i}"
              role="button"
              tabindex="0"
              title="${esc(
                `Seen ${p.count}× · ${p.days || 1} day(s) · priority ${
                  Number.isFinite(p.priority) ? p.priority.toFixed(2) : "—"
                }`
              )}"
            >
              <span>${esc(p.ipa)}</span>
              <span class="lux-pill ${
                p.avg >= 80 ? "lux-pill--blue" : p.avg >= 60 ? "lux-pill--yellow" : "lux-pill--red"
              }">${Math.round(Number(p.avg) || 0)}%</span>
            </span>
            ${ex}
          </div>
        `;
        })
        .join("")}
    </div>
  `;
}
</file>

<file path="features/progress/attempt-detail/derive.js">
// features/progress/attempt-detail/derive.js
// Derived logic/text builders for Attempt Details modal (no DOM nodes here).

import { esc, getColorConfig } from "../progress-utils.js";
import { pickTS } from "../attempt-pickers.js";

export function computeConfidence(list, sid) {
  const attemptsCount = Array.isArray(list) ? list.length : 0;

  const isNoSess = String(sid || "").startsWith("nosess:");

  const uniqueDays = new Set(
    (list || [])
      .map((a) => {
        const ts = +new Date(pickTS(a) || 0);
        if (!ts) return "";
        const d = new Date(ts);

        // Use en-CA if available (YYYY-MM-DD), otherwise manual.
        try {
          return d.toLocaleDateString("en-CA");
        } catch (_) {}

        const y = d.getFullYear();
        const m = String(d.getMonth() + 1).padStart(2, "0");
        const da = String(d.getDate()).padStart(2, "0");
        return `${y}-${m}-${da}`;
      })
      .filter(Boolean)
  ).size;

  let label = "Early signal";
  let hint = "Based on a small sample — keep practicing for stronger patterns.";
  if (attemptsCount >= 3 || uniqueDays >= 2) {
    label = "High confidence";
    hint = "Patterns are consistent across attempts/days.";
  } else if (attemptsCount === 2) {
    label = "Medium confidence";
    hint = "Good start — one more attempt will sharpen priorities.";
  }

  return { attemptsCount, uniqueDays, label, hint, isNoSess };
}

export function buildNextActions(trouble, title) {
  const nextActions = [];

  const topPh = (trouble?.phonemesAll || [])[0] || null;
  const topWd = (trouble?.wordsAll || [])[0] || null;

  if (topPh) {
    const ex =
      Array.isArray(topPh.examples) && topPh.examples.length
        ? ` (e.g., ${topPh.examples.join(", ")})`
        : "";
    nextActions.push(
      `Top priority sound: <strong>${esc(topPh.ipa)}</strong> — seen ${topPh.count}× across ${
        topPh.days || 1
      } day(s).${ex}`
    );
  }

  if (topWd) {
    nextActions.push(
      `Top priority word: <strong>${esc(topWd.word)}</strong> — avg ${Math.round(topWd.avg)}% over ${topWd.count}×.`
    );
  }

  if (nextActions.length) {
    nextActions.push(`Repeat <strong>${esc(title)}</strong> once more focusing on the top items above.`);
  } else {
    nextActions.push(`Keep practicing — priorities become more reliable after a few repeats.`);
  }

  return nextActions;
}

export function buildFocusWordsFallbackHtml(latestSum) {
  let html = `<p style="color:#94a3b8; font-style:italic;">No word details available.</p>`;

  if (Array.isArray(latestSum?.words) && latestSum.words.length > 0) {
    const items = latestSum.words
      .slice(0, 6)
      .map((w) => {
        const text = Array.isArray(w) ? w[0] : w?.w;
        const s = Array.isArray(w) ? w[1] : w?.s;
        const wordColor = getColorConfig(s).color;
        return `<li style="margin-bottom:4px;"><strong style="color:${wordColor};">${esc(
          text
        )}</strong> (${Math.round(Number(s) || 0)}%)</li>`;
      })
      .join("");

    html = `<ul style="padding-left:20px; color:#475569;">${items}</ul>`;
  }

  return html;
}
</file>

<file path="features/progress/attempt-detail/format.js">
// features/progress/attempt-detail/format.js
// Pure formatting helpers for Attempt Details modal.

import { passages } from "../../../src/data/passages.js";
import { SCENARIOS } from "../../convo/scenarios.js";

export function fmtDateTime(ts) {
  if (!ts) return "—";
  const d = new Date(ts);
  return d.toLocaleString(undefined, {
    month: "short",
    day: "numeric",
    year: "numeric",
    hour: "2-digit",
    minute: "2-digit",
  });
}

export function titleFromPassageKey(pk = "") {
  const s = String(pk);
  if (s.startsWith("convo:")) {
    const id = s.slice("convo:".length);
    const hit = SCENARIOS.find((x) => x.id === id);
    return hit ? `AI Conversation · ${hit.title}` : `AI Conversation · ${id}`;
  }
  const hit = passages?.[s];
  return hit?.name || s || "Practice";
}
</file>

<file path="features/progress/attempt-detail/metrics.js">
// features/progress/attempt-detail/metrics.js
// Attempt metric extraction for Attempt Details modal.
// Pulls metrics from summary when present, otherwise falls back to Azure fields.

import { pickSummary, pickAzure } from "../attempt-pickers.js";

export function attemptMetric(a, kind) {
  const sum = pickSummary(a) || {};
  const az = pickAzure(a);
  const nb = az?.NBest?.[0] || az?.nBest?.[0] || null;
  const pa =
    nb?.PronunciationAssessment ||
    nb?.pronunciationAssessment ||
    az?.PronunciationAssessment ||
    null;

  const map = {
    pron: () => (sum.pron != null ? Number(sum.pron) : Number(nb?.PronScore ?? pa?.PronScore)),
    acc: () => (sum.acc != null ? Number(sum.acc) : Number(pa?.AccuracyScore)),
    flu: () => (sum.flu != null ? Number(sum.flu) : Number(pa?.FluencyScore)),
    comp: () => (sum.comp != null ? Number(sum.comp) : Number(pa?.CompletenessScore)),
    pros: () =>
      sum.pros != null
        ? Number(sum.pros)
        : sum.pro != null
        ? Number(sum.pro)
        : Number(pa?.ProsodyScore),
  };

  const fn = map[kind];
  if (!fn) return null;
  const n = fn();
  return Number.isFinite(n) ? n : null;
}
</file>

<file path="features/progress/attempt-detail/modal-shell.js">
// features/progress/attempt-detail/modal-shell.js
// Modal shell + lifecycle for Attempt Details modal.

export function createAttemptDetailModalShell() {
  const modal = document.createElement("div");
  modal.id = "lux-detail-modal";
  modal.style.cssText = `
    position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
    background: rgba(0,0,0,0.5); z-index: 9999;
    display: flex; align-items: center; justify-content: center;
    backdrop-filter: blur(2px);
  `;

  const card = document.createElement("div");
  card.style.cssText = `
    background: white; width: 94%; max-width: 640px;
    border-radius: 16px; padding: 22px;
    box-shadow: 0 20px 25px -5px rgba(0,0,0,0.18);
    position: relative; max-height: 90vh; overflow-y: auto;
  `;

  const closeBtn = document.createElement("button");
  closeBtn.innerHTML = "&times;";
  closeBtn.style.cssText = `
    position: absolute; top: 14px; right: 14px;
    background: none; border: none; font-size: 1.6rem;
    cursor: pointer; color: #94a3b8;
  `;

  let mounted = false;

  function onKey(e) {
    if (e.key === "Escape") close();
  }

  function onBackdrop(e) {
    if (e.target === modal) close();
  }

  function close() {
    if (!mounted) {
      // Still safe to remove if someone calls close early
      try { modal.remove(); } catch (_) {}
      return;
    }

    mounted = false;
    try { modal.remove(); } catch (_) {}

    document.removeEventListener("keydown", onKey);
    modal.removeEventListener("click", onBackdrop);

    try {
      document.body.style.overflow = "";
    } catch (_) {}
  }

  closeBtn.onclick = close;

  card.appendChild(closeBtn);
  modal.appendChild(card);

  function mount() {
    if (mounted) return;
    mounted = true;

    document.body.appendChild(modal);

    try {
      document.body.style.overflow = "hidden";
    } catch (_) {}

    document.addEventListener("keydown", onKey);
    modal.addEventListener("click", onBackdrop);
  }

  return { modal, card, close, mount };
}
</file>

<file path="features/progress/attempt-detail/trouble-sections.js">
// features/progress/attempt-detail/trouble-sections.js
// Builds the "Trouble Sounds" and "Trouble Words" sections for Attempt Details modal.

import { chipRowPhonemes, chipRowWords } from "./chips.js";

export function buildTroubleSoundsSection(phItems) {
  const sounds = document.createElement("div");
  sounds.style.cssText = "border-top: 1px solid #e2e8f0; padding-top: 12px; margin-top: 12px;";
  sounds.innerHTML = `
    <h4 style="margin:0 0 10px 0; font-size:0.95rem; color:#334155;">⚠️ Trouble Sounds</h4>
    ${chipRowPhonemes(phItems)}
    <div id="luxExplainSounds" style="margin-top:10px;" hidden></div>
  `;
  return sounds;
}

export function buildTroubleWordsSection(wdItems, focusWordsFallbackHtml) {
  const words = document.createElement("div");
  words.style.cssText = "border-top: 1px solid #e2e8f0; padding-top: 12px; margin-top: 12px;";
  words.innerHTML = `
    <h4 style="margin:0 0 10px 0; font-size:0.95rem; color:#334155;">⚠️ Trouble Words</h4>
    ${chipRowWords(wdItems)}
    <div id="luxExplainWords" style="margin-top:10px;" hidden></div>
    ${
      (wdItems || []).length
        ? ""
        : `<details style="margin-top:10px;">
            <summary style="cursor:pointer; font-weight:900; color:#334155;">(Fallback) Focus words from latest attempt</summary>
            <div style="margin-top:10px;">${focusWordsFallbackHtml}</div>
          </details>`
    }
  `;
  return words;
}
</file>

<file path="features/progress/attempt-pickers.js">
// features/progress/attempt-pickers.js
// Field pickers for attempt objects (handles schema drift).

export function pickTS(a) {
  return a?.ts || a?.created_at || a?.createdAt || a?.time || a?.localTime || null;
}

export function pickPassageKey(a) {
  return a?.passage_key || a?.passageKey || a?.passage || "";
}

export function pickSessionId(a) {
  return a?.session_id || a?.sessionId || "";
}

export function pickSummary(a) {
  return a?.summary || a?.summary_json || a?.sum || null;
}

export function pickAzure(a) {
  return a?.azureResult || a?.azure_result || a?.azure || a?.result || null;
}
</file>

<file path="features/progress/progress-utils.js">
// features/progress/progress-utils.js
// Tiny shared helpers for progress UI (keep it boring + stable).

export function esc(s) {
  return String(s ?? "")
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#39;");
}

export function getColorConfig(s) {
  const n = Number(s) || 0;
  if (n >= 80) return { color: "#2563eb", bg: "#dbeafe" }; // Blue
  if (n >= 60) return { color: "#d97706", bg: "#fef3c7" }; // Yellow
  return { color: "#dc2626", bg: "#fee2e2" }; // Red
}

export function mdToHtml(md = "") {
  if (!md) return "";
  return String(md)
    .replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>")
    .replace(/\*(.+?)\*/g, "<em>$1</em>")
    .split("\n")
    .join("<br>");
}

export function mean(nums) {
  const v = (nums || []).filter((x) => Number.isFinite(x));
  if (!v.length) return null;
  return v.reduce((a, b) => a + b, 0) / v.length;
}
</file>

<file path="features/results/deps.js">
/* ============================================================================
   CANONICAL SHIM — PROSODY + TIMING GLOBAL BACKFILL
   ---------------------------------------------------------------------------
   - Canonical results renderer imports from here for timing/prosody helpers.
   - Prosody helpers are now sourced from core/prosody/index.js, which is
     currently global-backed but will be the long-term truth source.
   - This file must NOT attach window/globalThis.
   - Phase-E slice: removed hooks shim (header now imports boots directly).
============================================================================ */

import {
  computeTimings,
  median,
  classifyTempo,
  classifyGap,
  renderProsodyRibbon,
} from "../../core/prosody/index.js";

const G = globalThis;

// ------------------------------------------------------------
// Legacy shim (still global-backed for now)
// ------------------------------------------------------------
export const resolveYTLink =
  G.resolveYTLink ||
  ((arg) => {
    try {
      if (typeof G.ytLink === "function") return G.ytLink(arg);
      if (typeof G.ytLink === "string") return G.ytLink;
    } catch {}
    return null;
  });

// ------------------------------------------------------------
// Prosody helpers (re-exported from canonical gateway)
// ------------------------------------------------------------
export { computeTimings, median, classifyTempo, classifyGap, renderProsodyRibbon };
</file>

<file path="features/results/index.js">
// ui/views/index.js
// Canonical results renderer entrypoint.

import {
  showPrettyResults as legacyShowPrettyResults,
  showDetailedAnalysisSingle as legacyShowDetailedAnalysisSingle,
} from "./render-modern.js";

import { setupPhonemeHover } from "../interactions/ph-hover.js";
import { initPhonemeChipBehavior } from "../interactions/ph-chips.js";
import { showSummaryWithTracking } from "./summary-shell.js";

let lastResult = null;

/* ------------ phoneme hover boot (once) ------------ */

let phonemeHoverBooted = false;

function bootPhonemeHoverOnce() {
  if (phonemeHoverBooted) return;
  phonemeHoverBooted = true;
  try {
    setupPhonemeHover();
    console.log("[LUX] phoneme hover booted");
  } catch (e) {
    console.warn("[LUX] phoneme hover boot failed", e);
  }
}

/* ------------ phoneme chip hydration ------------ */

function hydratePhonemeChips() {
  // ✅ ENABLED: Safe version of ph-chips.js is now in place.
  try {
    if (typeof initPhonemeChipBehavior === "function") {
      initPhonemeChipBehavior();
      // console.log("[LUX] phoneme chips hydrated"); // Optional log
    } else {
      console.warn("[LUX] ph-chips: initPhonemeChipBehavior not found");
    }
  } catch (e) {
    console.warn("[LUX] phoneme chip hydration failed", e);
  }
}

/* ------------ small local helpers ------------ */

function getContainer() {
  return document.getElementById("prettyResult") || document.body;
}

function ensureRawUI(host) {
  if (!host) return null;

  let link = host.querySelector("#lux-show-raw-link");
  let wrap = host.querySelector("#lux-raw-container");
  let pre = host.querySelector("#lux-raw-pre");

  if (!wrap || !pre) {
    link = document.createElement("div");
    link.id = "lux-show-raw-link";
    link.textContent = "Show Raw Data";
    link.style.cssText =
      "display:inline-block;margin-top:10px;font-size:0.78rem;color:#2563eb;text-decoration:underline;cursor:pointer;";

    wrap = document.createElement("div");
    wrap.id = "lux-raw-container";
    wrap.style.display = "none";
    wrap.style.marginTop = "8px";

    pre = document.createElement("pre");
    pre.id = "lux-raw-pre";
    pre.style.cssText =
      "max-height:260px;overflow:auto;background:#0f172a;color:#e5e7eb;padding:8px;border-radius:8px;font-size:0.72rem;";

    wrap.appendChild(pre);
    host.appendChild(link);
    host.appendChild(wrap);

    link.onclick = () => {
      const visible = wrap.style.display === "block";
      if (visible) {
        wrap.style.display = "none";
        link.textContent = "Show Raw Data";
      } else {
        pre.textContent = JSON.stringify(lastResult, null, 2);
        wrap.style.display = "block";
        link.textContent = "Hide Raw Data";
      }
    };
  }

  return { link, wrap, pre };
}

/* ------------ core exports ------------ */

export function showPrettyResults(data) {
  lastResult = data;

  // 1) Render the pills / table via Phase-E renderer.
  legacyShowPrettyResults(data);

  // 2) Hydrate phoneme chips so .tooltiptext gets IPA/tips/video.
  hydratePhonemeChips();

  // 3) Attach hover overlay once per page.
  bootPhonemeHoverOnce();
}

export function showDetailedAnalysisSingle(result) {
  lastResult = result;

  legacyShowDetailedAnalysisSingle(result);

  hydratePhonemeChips();
  bootPhonemeHoverOnce();
}

export function showSummary({ allPartsResults, currentParts } = {}) {
  // Canonical multi-part path
  if (Array.isArray(allPartsResults) && allPartsResults.length) {
    const tail = allPartsResults[allPartsResults.length - 1];
    if (tail) lastResult = tail;

    showSummaryWithTracking({
      allPartsResults,
      currentParts: currentParts || [],
    });

    // Summary view still uses phoneme chips / tooltips.
    hydratePhonemeChips();
    bootPhonemeHoverOnce();
    return;
  }

  // Fallback
  if (lastResult) {
    showPrettyResults(lastResult);
  }
}

export function showRawData() {
  if (!lastResult) return;
  const host = getContainer();
  if (!host) return;
  const ui = ensureRawUI(host);
  if (!ui) return;

  ui.pre.textContent = JSON.stringify(lastResult, null, 2);
  ui.wrap.style.display = "block";
  ui.link.textContent = "Hide Raw Data";
}

export function updateSummaryVisibility(show = true) {
  const host = getContainer();
  if (!host) return;
  host.style.display = show ? "" : "none";
}
</file>

<file path="features/results/render-core.js">
/* ============================================================================
   PHASE-E RENDER CORE (pure-ish modern trunk)
   ---------------------------------------------------------------------------
   - Moved verbatim from render-modern.js.
   - render-modern.js becomes a thin adapter that calls these.
   - NO behavior changes. Output must remain identical.
============================================================================ */

// ui/views/render-core.js
import { computeTimings, median } from "./deps.js";
import { ensureHeader, wirePostDom } from "./header.js";
import { buildRows } from "./rows.js";
// UPDATED IMPORT: Pointing to the new independent module
import { detailedPhonemeFeedback } from "./summary-feedback.js";
import {
  computeIssueSummary,
  computeTimingsAndMedian,
  buildDetailedAnalysisHTML,
  ensureAnalysisSummaryContainer,
} from "./render-helpers.js";

export function renderPrettyResultsCore({ $out, data, nbest }) {
  // Header/shell (legend + table)
  $out.innerHTML = "";
  ensureHeader(data);

  // Timings + median
  const words = nbest.Words || [];
  const { timings, med } = computeTimingsAndMedian(
    words,
    computeTimings,
    median
  );

  // Paint rows
  const body = document.getElementById("resultBody");
  if (body) body.innerHTML = buildRows(words, timings, med);

  // Post-DOM hooks
  requestAnimationFrame(() => wirePostDom(data));
}

export function renderDetailedAnalysisCore({ $out, data, nbest }) {
  ensureHeader(data);

  const words = nbest.Words || [];
  const { timings, med } = computeTimingsAndMedian(
    words,
    computeTimings,
    median
  );

  const body = document.getElementById("resultBody");
  if (body) body.innerHTML = buildRows(words, timings, med);

  requestAnimationFrame(() => wirePostDom(data));

  // Inline detail summary
  const { issues, majorIssues } = computeIssueSummary(words);

  const html = buildDetailedAnalysisHTML({
    issues,
    majorIssues,
    detailedPhonemeFeedback,
  });

  const summary = ensureAnalysisSummaryContainer($out);
  summary.innerHTML = html;
}
</file>

<file path="features/results/render-helpers.js">
// ui/views/render-helpers.js
import { speechDetected } from "../../helpers/assess.js";
// UPDATED IMPORT: Circular dependency resolved by using the new leaf module
import { detailedPhonemeFeedback } from "./summary-feedback.js";

export function computeIssueSummary(words) {
  const issues = {};
  const majorIssues = [];

  (words || []).forEach((w) => {
    if (w.AccuracyScore != null && w.AccuracyScore < 70) {
      majorIssues.push({ word: w.Word, score: w.AccuracyScore });
    }
    (w.Phonemes || []).forEach((p) => {
      if (p.AccuracyScore != null && p.AccuracyScore < 85) {
        const key = ((w) =>
          String(w || "")
            .trim()
            .toLowerCase())(p.Phoneme);

        if (!issues[key]) issues[key] = { count: 0, scores: [], examples: [] };
        issues[key].count++;
        issues[key].scores.push(p.AccuracyScore);
        issues[key].examples.push({ word: w.Word, score: p.AccuracyScore });
      }
    });
  });

  return { issues, majorIssues };
}

export function computeTimingsAndMedian(words, computeTimings, median) {
  const timings = computeTimings?.(words) || [];
  const med =
    median?.(timings.map((t) => t.durationSec).filter(Number.isFinite)) ?? null;

  return { timings, med };
}

/**
 * Prepares the output container.
 * RESTORED: Uses speechDetected() to show the "Graceful Fallback" message
 * if Azure returns valid JSON but no audible speech.
 */
export function preparePrettyOut(data) {
  const $out = document.getElementById("prettyResult");
  if (!$out) return { $out: null, nbest: null, stop: true };

  $out.style.maxHeight = "none";
  $out.style.height = "auto";
  $out.style.overflowY = "visible";

  // 1. Hard API Errors
  if (!data || data.error) {
    $out.innerHTML = `<span class="score-bad">Error: ${
      data?.error || "Unknown"
    }</span>`;
    return { $out, nbest: null, stop: true };
  }

  // 2. Graceful Fallback: No Speech Detected
  // This catches silence, mic errors, or empty results
  if (!speechDetected(data)) {
    $out.innerHTML = `
      <div style="padding: 10px 0;">
        <h3 style="margin-top:0; color:#1f2937;">No speech detected.</h3>
        <p style="color:#b91c1c; font-weight:700; margin-bottom: 0;">
          Sorry, but we didn’t hear anything. Please check your mic and try again.
        </p>
      </div>
    `;
    // We stop here to prevent rendering a broken table
    return { $out, nbest: null, stop: true };
  }

  // 3. Valid Result
  const nbest = data.NBest && data.NBest[0];
  return { $out, nbest, stop: false };
}

export function preparePrettyOutSingle(data) {
  const $out = document.getElementById("prettyResult");
  if (!$out) return { $out: null, nbest: null, stop: true };

  $out.style.maxHeight = "none";
  $out.style.height = "auto";
  $out.style.overflowY = "visible";

  if (!speechDetected(data)) {
    $out.innerHTML = `<span>No analysis returned.</span>`;
    return { $out, nbest: null, stop: true };
  }

  const nbest = data.NBest[0];
  return { $out, nbest, stop: false };
}

export function buildDetailedAnalysisHTML({
  issues,
  majorIssues,
  detailedPhonemeFeedback,
}) {
  const worstErrors = majorIssues.slice(0, 5);

  let html = `<b>Detailed Pronunciation Analysis</b><hr style="margin:12px 0;">`;
  html += `<b>Most Frequent Error Patterns:</b><br>`;
  html += detailedPhonemeFeedback(issues);
  html += `<b>Most Serious Errors:</b><br>`;
  html += worstErrors.length
    ? worstErrors
        .map(
          (err) =>
            `<div>&bull; <b>${err.word}</b>: <span style="color:#d43c2c;">${err.score}%</span></div>`
        )
        .join("")
    : "<div>No major issues detected.</div>";

  return html;
}

export function ensureAnalysisSummaryContainer($out) {
  let summary = document.getElementById("customAnalysisSummary");
  if (!summary) {
    summary = document.createElement("div");
    summary.id = "customAnalysisSummary";
    $out.appendChild(summary);
  }
  return summary;
}
</file>

<file path="features/results/render-modern.js">
/* ============================================================================
   PHASE-E CANONICAL RENDERER (thin adapter)
   ---------------------------------------------------------------------------
   - Calls into render-core.js for the real work.
   - Keeps legacy guards & output identical.
   - NO behavior changes.
============================================================================ */

// ui/views/render-modern.js
import { preparePrettyOut, preparePrettyOutSingle } from "./render-helpers.js";
import {
  renderPrettyResultsCore,
  renderDetailedAnalysisCore,
} from "./render-core.js";

export function showPrettyResults(data) {
  const { $out, nbest, stop } = preparePrettyOut(data);
  if (stop) return;

  renderPrettyResultsCore({ $out, data, nbest });
}

export function showDetailedAnalysisSingle(data) {
  const { $out, nbest, stop } = preparePrettyOutSingle(data);
  if (stop) return;

  renderDetailedAnalysisCore({ $out, data, nbest });
}
</file>

<file path="features/results/rows-logic.js">
// ui/views/rows-logic.js
// Pure logic: calculates penalties, classifications, and error strings.

import { classifyTempo, classifyGap } from "./deps.js";

export function calculateWordStats(word, index, timings, medianDuration) {
  const t = timings?.[index] || {};
  const prev = timings?.[index - 1] || {};

  // 1. Classification
  const tempo = classifyTempo?.(t.durationSec, medianDuration) || "ok";
  const gapCls = index > 0 ? classifyGap?.(prev.end, t.start) || "ok" : "ok";

  // 2. Error Text Building
  const err = word.ErrorType && word.ErrorType !== "None" ? word.ErrorType : "";
  
  const notes = [];
  if (gapCls === "missing") notes.push("missing phrase pause");
  else if (gapCls === "unexpected") notes.push("long pause");
  if (tempo === "fast") notes.push("too fast");
  else if (tempo === "slow") notes.push("too slow");

  const errText = [err, ...notes].filter(Boolean).join("; ");

  // 3. Penalty Math
  // (Fast/Slow = -4 points, Bad Gap = -2 points)
  const penalty =
    (tempo === "fast" || tempo === "slow" ? 4 : 0) +
    (gapCls === "missing" || gapCls === "unexpected" ? 2 : 0);

  // 4. Adjusted Score
  const rawScore = word.AccuracyScore ?? 0;
  const adjScore = Math.max(
    0,
    Math.min(100, Math.round(rawScore - penalty))
  );

  return {
    tempo,
    gapCls,
    errText,
    penalty,
    adjScore,
    rawScore
  };
}
</file>

<file path="features/results/summary-feedback.js">
// features/results/summary-feedback.js
// Generates the "Priority Focus Areas" cards.
// STATUS: Updated to color-code "Problem Words" using the Universal Schema.

import { norm } from "../../src/data/phonemes/core.js";
import { getPhonemeAssetByIPA } from "../../src/data/phonemes/assets.js";
import {
  phonemeDetailsByIPA,
  articulatorPlacement,
} from "../../src/data/phonemes/details.js";
import { isCorrupt, encouragingLine } from "../../helpers/core.js";
import { resolveYTLink } from "./deps.js";

// --- Universal Color Helper (Inlined here for safety) ---
function getColor(s) {
  if (s >= 80) return { color: "#2563eb", bg: "#dbeafe" }; // Blue
  if (s >= 60) return { color: "#d97706", bg: "#fef3c7" }; // Yellow
  return { color: "#dc2626", bg: "#fee2e2" }; // Red
}

/**
 * Generates the rich HTML for the "Most Frequent Error Patterns" section.
 */
export function detailedPhonemeFeedback(issues, maxCount = 5) {
  let html = "";
  
  // Sort by frequency (most missed first)
  const sorted = Object.entries(issues)
    .sort((a, b) => b[1].count - a[1].count)
    .slice(0, maxCount);

  if (!sorted.length) {
    // Updated: Blue success message (was Green)
    return "<div style='padding:10px; color:#2563eb; background:#eff6ff; border-radius:8px;'>No major recurring errors found—great job!</div>";
  }

  sorted.forEach(([sound, obj]) => {
    // 1. Setup Data
    const key = norm(sound);
    const details = phonemeDetailsByIPA[key] ?? articulatorPlacement[key] ?? {};
    const asset = getPhonemeAssetByIPA(key) || {};
    const ytUrl = resolveYTLink(asset.ipa || sound); 
    const encouragement = encouragingLine ? encouragingLine() : "Keep practicing!";
    
    // 2. Color-code the "Lowest Score" text
    const minScore = Math.min(...obj.scores);
    const minColor = getColor(minScore).color;

    // 3. Build Problem Words (Top 3) - NOW COLOR CODED 🎨
    const examples = obj.examples
        .filter((e) => !isCorrupt(e.word))
        .slice(0, 3);
        
    const exStr = examples.map((e) => {
        const { color, bg } = getColor(e.score);
        return `<span style="white-space:nowrap; background:${bg}; color:${color}; padding:2px 8px; border-radius:4px; font-weight:600; font-size:0.9em;">${e.word} (${e.score}%)</span>`;
    }).join(" ");

    // 4. Build Card HTML
    html += `
        <div style="
            margin-bottom: 24px; 
            padding: 20px; 
            border: 1px solid #e2e8f0; 
            border-radius: 12px; 
            background: #fff;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05);
        ">
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:12px; border-bottom:1px solid #f1f5f9; padding-bottom:12px;">
             <div style="display:flex; align-items:center; gap:10px;">
                <span style="font-size:1.8em; font-weight:800; color:#0f172a;">/${asset.ipa || sound}/</span>
                <span style="font-size:0.9em; color:#64748b; background:#f8fafc; padding:2px 8px; border-radius:12px; border:1px solid #e2e8f0;">Sound</span>
             </div>
             <div style="text-align:right;">
                <div style="font-size:0.9em; color:#64748b;"><strong>${obj.count}</strong> detections</div>
                <div style="font-size:0.9em; color:${minColor};">Lowest: <strong>${minScore}%</strong></div>
             </div>
          </div>

          <div style="margin-bottom:16px;">
             <div style="font-size:0.85em; text-transform:uppercase; color:#94a3b8; font-weight:700; margin-bottom:6px;">Problem Words</div>
             <div style="line-height:1.8; display:flex; flex-wrap:wrap; gap:6px;">
               ${exStr || "<span style='color:#94a3b8; font-style:italic;'>No specific words captured.</span>"}
             </div>
          </div>

          <div style="background:#f8fafc; padding:16px; border-radius:8px; border:1px solid #e2e8f0; margin-bottom:16px;">
             ${details.tip ? `<div style="margin-bottom:8px;"><strong style="color:#0369a1;">💡 Tip:</strong> <span style="color:#334155;">${details.tip}</span></div>` : ""}
             ${details.mistake ? `<div><strong style="color:#b91c1c;">⚠️ Trap:</strong> <span style="color:#334155;">${details.mistake}</span></div>` : ""}
          </div>

          <div style="display:flex; flex-wrap:wrap; gap:20px; align-items:flex-start;">
             
             ${asset.video ? `
               <div style="flex:0 0 auto; width:140px;">
                 <video src="${asset.video}" controls playsinline preload="none" style="width:100%; border-radius:8px; background:#000; box-shadow:0 2px 5px rgba(0,0,0,0.1);"></video>
                 <div style="text-align:center; font-size:0.75em; color:#64748b; margin-top:4px;">Mouth Position</div>
               </div>
             ` : ""}

             <div style="flex:1; min-width:200px; display:flex; flex-direction:column; gap:10px;">
                
                ${ytUrl ? `
                  <a href="${ytUrl}" target="_blank" rel="noopener noreferrer" style="
                      display:flex; align-items:center; gap:8px;
                      padding: 10px; background:#eff6ff; border:1px solid #bfdbfe;
                      border-radius:8px; text-decoration:none; transition:transform 0.1s;
                  ">
                    <span style="font-size:1.2em;">📺</span>
                    <div>
                        <div style="font-weight:700; color:#1d4ed8; font-size:0.95em;">Watch Deep Dive Lesson</div>
                        <div style="font-size:0.8em; color:#60a5fa;">Detailed walkthrough of /${asset.ipa || sound}/</div>
                    </div>
                  </a>
                ` : ""}

                <a href="https://calendly.com/mark-lux/pronunciation-coaching?note=focus_${sound}" target="_blank" rel="noopener noreferrer" style="
                    display:flex; align-items:center; gap:8px;
                    padding: 10px; background:#f0fdf4; border:1px solid #bbf7d0;
                    border-radius:8px; text-decoration:none; transition:transform 0.1s;
                ">
                   <span style="font-size:1.2em;">🎓</span>
                   <div>
                        <div style="font-weight:700; color:#15803d; font-size:0.95em;">Book 1-on-1 Coaching</div>
                        <div style="font-size:0.8em; color:#4ade80;">Master this sound with an expert</div>
                   </div>
                </a>
             </div>
          </div>

          <div style="margin-top:16px; padding-top:12px; border-top:1px dashed #e2e8f0; font-size:0.9em; font-weight:600; color:#059669; text-align:center; font-style:italic;">
             "${encouragement}"
          </div>

        </div>`;
  });
  return html;
}
</file>

<file path="features/results/summary-shell.js">
/* ============================================================================
   CANONICAL SUMMARY SHELL — ACTIVE FRONT DOOR
   ----------------------------------------------------------------------------
   - Delegates the main summary rendering to ui/views/summary.js.
   - Adds the "Database Tracking" footer.
   - REPLICATES the interactive "Blue Pill" popover from the main page
     so users can jump straight to admin tools from the summary.
   - STYLE UPDATE: Matches the main page "Blue Box" (#e7f2fb) for visual consistency.
============================================================================ */

import { showSummary as renderCoreSummary } from "./summary.js";

// Best-effort UID helper
function getLuxUID() {
  const fromWindow = (window && window.LUX_USER_ID) || "";
  const fromAttr = document.documentElement.getAttribute("data-uid") || "";
  return (fromWindow || fromAttr || "—").toString();
}

function ensureFooterHost() {
  const host = document.getElementById("prettyResult");
  if (!host) return null;

  let footer = document.getElementById("lux-db-summary");
  if (!footer) {
    footer = document.createElement("div");
    footer.id = "lux-db-summary";
    // We style this to match the main page #userMsg blue box exactly
    footer.style.cssText = [
      "margin-top: 24px",
      "padding: 20px",
      "border-top: 1px solid #cce3f5", 
      "font-size: 1rem",
      "color: #134e6f",        // Darker blue text (matches main page)
      "background: #e7f2fb",   // The specific 'Blue Box' background color
      "border-radius: 0 0 12px 12px",
      "text-align: center",
      "line-height: 1.6"
    ].join(";");
    host.appendChild(footer);
  }
  return footer;
}

/**
 * Generates the Admin URLs (logic mirrored from lux-popover.js)
 */
function getAdminLinks(uid) {
  const base = "https://luxury-language-api.vercel.app/admin";
  const passages = "grandfather,rainbow,sentences,wordList";
  const fmt = (d) => d.toISOString().slice(0, 10);
  
  const now = new Date();
  const to = fmt(now);
  const from = fmt(new Date(now.getTime() - 14 * 24 * 60 * 60 * 1000)); // last 14 days

  const q = `uid=${encodeURIComponent(uid)}`;
  const dateQ = `&from=${from}&to=${to}`;

  return {
    progress: `${base}/?${q}${dateQ}&smooth=7&passages=${encodeURIComponent(passages)}&limit=500`,
    attempts: `${base}/user.html?${q}${dateQ}&passages=${encodeURIComponent(passages)}&limit=500`,
    cohort: `${base}/overview.html?from=${from}&to=${to}&sort=last&limit=10000&passages=${encodeURIComponent(passages)}&quick=14`
  };
}

/**
 * showSummaryWithTracking
 * - Renders the summary.
 * - Injects the interactive "Database tracking" pill into the footer.
 */
export function showSummaryWithTracking({
  allPartsResults,
  currentParts,
} = {}) {
  // 1) Render Core Summary
  renderCoreSummary({
    allPartsResults,
    currentParts,
  });

  // 2) Prepare Footer
  const footer = ensureFooterHost();
  if (!footer) return;

  const uid = getLuxUID();
  const links = getAdminLinks(uid);

  // 3) Inject the HTML (Structure matches the main page popover exactly)
  footer.innerHTML = `
    <h3 style="margin: 0 0 12px 0; color: #0078d7; font-size: 1.3rem; font-weight: 800;">
      Long Term Analysis
    </h3>
    
    <div>
      The more recordings you make, the better the feedback will be 🤔 💭 💡 😮:
      
      <span class="lux-cta" tabindex="0" aria-haspopup="dialog" aria-expanded="false" style="margin-left: 4px;">
        database tracking
        
        <span class="lux-pop" role="dialog" aria-label="Database tracking details" style="text-align: left;">
          <strong style="display: block; margin-bottom: 6px">Your Practice History</strong>
          <p style="margin: 0 0 8px; color: #444; font-size: 13px">
            Jump to your long-term stats to see progress over time.
          </p>

          <div class="lux-uidrow">
            <span>UID:</span>
            <code style="font-family:monospace; background:#f1f5f9; padding:2px 6px; border-radius:4px;">${uid.slice(0, 8)}...</code>
            <button id="lux-copy-footer" class="lux-btn" type="button">Copy</button>
            <small id="lux-copied-footer" class="lux-copied" aria-live="polite"></small>
          </div>

          <div class="lux-links">
            <a href="${links.attempts}" target="_blank" rel="noopener">Attempts (admin)</a>
            <a href="${links.progress}" target="_blank" rel="noopener">User Progress (admin)</a>
            <a href="${links.cohort}" target="_blank" rel="noopener">Cohort (admin)</a>
          </div>

          <small class="lux-note">Admin token required for these dashboards.</small>
        </span>
      </span>
    </div>
  `;

  // 4) Wire up the "Copy" button for this specific footer instance
  const copyBtn = document.getElementById("lux-copy-footer");
  const copyMsg = document.getElementById("lux-copied-footer");
  
  if (copyBtn) {
    copyBtn.onclick = async (e) => {
      e.stopPropagation(); // prevent closing popover immediately
      try {
        await navigator.clipboard.writeText(uid);
        if (copyMsg) {
          copyMsg.textContent = "Copied!";
          setTimeout(() => (copyMsg.textContent = ""), 1500);
        }
      } catch (err) {
        console.warn("Copy failed", err);
      }
    };
  }

  // 5) Wire up ARIA attributes for the footer interaction (Mouse/Keyboard)
  const cta = footer.querySelector(".lux-cta");
  if (cta) {
    const setEx = (v) => cta.setAttribute("aria-expanded", v);
    cta.addEventListener("mouseenter", () => setEx("true"));
    cta.addEventListener("mouseleave", () => setEx("false"));
    cta.addEventListener("focusin", () => setEx("true"));
    cta.addEventListener("focusout", () => setEx("false"));
  }
}
</file>

<file path="features/results/summary.js">
// features/results/summary.js
/* ============================================================================
   CANONICAL SUMMARY BUILDER (v1.5.0 ATLAS)
   STATUS: LOCKED to Universal Blue/Yellow/Red Schema (80/60)
   ---------------------------------------------------------------------------
============================================================================ */

import { norm } from "../../src/data/phonemes/core.js";
import { isCorrupt } from "../../helpers/core.js";
import { passages } from "../../src/data/passages.js";
import { detailedPhonemeFeedback } from "./summary-feedback.js";

// --- Universal Color Helper (Inlined for safety) ---
function getColorConfig(s) {
  if (s >= 80) return { color: "#2563eb", bg: "#dbeafe" }; // Blue
  if (s >= 60) return { color: "#d97706", bg: "#fef3c7" }; // Yellow
  return { color: "#dc2626", bg: "#fee2e2" }; // Red
}

/**
 * Main Entry Point: Renders the Summary to #prettyResult.
 * Called by summary-shell.js
 */
export function showSummary({ allPartsResults, currentParts }) {
  const $out = document.getElementById("prettyResult");
  if (!$out) return;

  $out.style.maxHeight = "none";
  $out.style.height = "auto";
  $out.style.overflowY = "visible";

  const passageKey = allPartsResults?.[0]?.passage_key || "rainbow"; 
  const passageData = passages[passageKey];
  const youtubeId = passageData?.youtubeId;

  const issues = {};
  const majorIssues = [];

  // Aggregate stats across all parts
  (allPartsResults || []).forEach((part, idx) => {
    const nb = part?.NBest?.[0];
    if (!nb) return;
    
    (nb.Words || []).forEach((w) => {
      if (isCorrupt(w.Word)) return;
      
      // Word Errors (Updated to < 60% Red Threshold)
      if (w.AccuracyScore != null && w.AccuracyScore < 60) {
        majorIssues.push({
          part: idx + 1,
          word: w.Word,
          score: w.AccuracyScore,
        });
      }

      // Phoneme Errors (85% trigger for coaching)
      (w.Phonemes || []).forEach((p) => {
        if (p.AccuracyScore != null && p.AccuracyScore < 85) {
          const key = norm(p.Phoneme);
          if (!issues[key]) issues[key] = { count: 0, scores: [], examples: [] };
          
          issues[key].count++;
          issues[key].scores.push(p.AccuracyScore);
          issues[key].examples.push({
            word: w.Word,
            part: idx + 1,
            score: p.AccuracyScore,
          });
        }
      });
    });
  });

  const worstErrors = majorIssues.filter((e) => !isCorrupt(e.word)).slice(0, 5);

  let html = `
    <div style="text-align:center; margin-bottom:24px;">
      <h2 style="margin:0 0 8px 0; color:#1e293b; font-size: 2rem;">Passage Summary</h2>
      <div style="color:#64748b; font-size:1.1em;">Analysis of all ${(currentParts || []).length} parts</div>
    </div>
  `;

  // === 2. THE GOLDEN STANDARD ACCORDION ===
  if (youtubeId) {
    html += `
      <details style="
        margin-bottom: 32px;
        background: #fff;
        border: 1px solid #e2e8f0;
        border-radius: 12px;
        overflow: hidden;
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05);
      ">
        <summary style="
          padding: 16px 20px;
          cursor: pointer;
          font-weight: 700;
          color: #0f172a;
          list-style: none;
          display: flex;
          align-items: center;
          justify-content: space-between;
          background: #f8fafc;
        ">
          <span style="display:flex; align-items:center; gap:8px;">
            <span style="font-size:1.2em">📺</span> 
            Reference: Hear Native Speaker
          </span>
          <span style="font-size: 0.8em; opacity: 0.6;">▼</span>
        </summary>
        <div style="padding: 0 16px 16px 16px; background:#fff;">
          <div style="margin-top:16px; position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; border-radius: 8px; border:1px solid #e2e8f0;">
            <iframe 
              style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;" 
              src="https://www.youtube.com/embed/${youtubeId}" 
              title="YouTube video player" 
              frameborder="0" 
              allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
              allowfullscreen>
            </iframe>
          </div>
          <div style="margin-top:12px; font-size: 0.9em; color: #64748b; text-align: center; font-style:italic;">
            Compare your rhythm, melody, and pacing to this reference.
          </div>
        </div>
      </details>
    `;
  }

  // 3. Priority Focus Areas (Phonemes)
  html += `<h3 style="color:#334155; margin-bottom:16px; font-size:1.3em;">🎯 Priority Focus Areas (Phonemes)</h3>`;
  html += detailedPhonemeFeedback(issues);

  // 4. Words to Review (UPDATED: Uses Universal Color Schema)
  html += `<h3 style="color:#334155; margin:32px 0 16px 0; font-size:1.3em;">⚠️ Words to Review</h3>`;
  
  if (worstErrors.length) {
    const pills = worstErrors.map(err => {
      const { color, bg } = getColorConfig(err.score);
      // We use the same 'border' color trick as bg but slightly darker for contrast, 
      // or just standard border. Let's keep it clean.
      return `
        <span style="
            background: ${bg}; 
            color: ${color}; 
            padding: 6px 14px; 
            border-radius: 20px; 
            font-weight: 700; 
            font-size: 0.95em;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        ">
           ${err.word} 
           <span style="opacity:0.8; font-weight:400;">(${err.score}%)</span>
           <span style="font-size:0.75em; opacity:0.6; text-transform:uppercase; letter-spacing:0.5px;">Pt ${err.part}</span>
        </span>
      `;
    }).join("");
    
    html += `<div style="display:flex; flex-wrap:wrap; gap:8px;">${pills}</div>`;
  } else {
    // Perfect Blue
    html += `<div style="color:#2563eb; font-style:italic; padding:10px; background:#dbeafe; border-radius:8px;">No word-level scores below 60%. Excellent accuracy!</div>`;
  }

  $out.innerHTML = html;
}
</file>

<file path="helpers/assess.js">
// helpers/assess.js
/** Heuristic to decide whether Azure returned usable speech. */
export function speechDetected(res) {
  const nb = res?.NBest?.[0];
  if (!nb) return false;

  const said = (res.DisplayText || nb.Display || "").trim();
  if (!said) return false;

  const words = Array.isArray(nb.Words) ? nb.Words : [];
  if (words.length === 0) return true;

  const anyWordWithScore = words.some((w) => (w?.AccuracyScore ?? 0) > 0);
  const anyPhonemeScore = words.some((w) =>
    (w?.Phonemes || []).some((p) => (p?.AccuracyScore ?? 0) > 0)
  );
  const anyGlobalScore = [
    nb.PronScore,
    nb.AccuracyScore,
    nb.FluencyScore,
    nb.CompletenessScore,
  ].some((v) => typeof v === "number" && v > 0);

  if (anyWordWithScore || anyPhonemeScore || anyGlobalScore) return true;

  const allZeroOmissions = words.every((w) => {
    const acc = Number.isFinite(w?.AccuracyScore) ? w.AccuracyScore : 0;
    const err = w?.ErrorType;
    return (err === "Omission" || err == null) && acc === 0;
  });

  return !allZeroOmissions;
}
</file>

<file path="helpers/core.js">
// helpers/core.js
import { getUID } from "../api/identity.js";

// Single source of truth for UID:
// - api/identity.js owns generation + persistence + migration
export const LUX_USER_ID = typeof window !== "undefined" ? getUID() : null;

export function scoreClass(score) {
  if (score == null || Number.isNaN(+score)) return "";
  if (score >= 85) return "score-good";
  if (score >= 70) return "score-warn";
  return "score-bad";
}

export const buildYouglishUrl = (w) =>
  `https://youglish.com/pronounce/${encodeURIComponent(w)}/english`;

export const isCorrupt = (s) =>
  /[�‘’“”—–…•\u0080-\uFFFF]/.test(String(s || ""));

export function encouragingLine() {
  const msgs = [
    "Great effort! Keep going—your persistence is paying off.",
    "Nice work! Every attempt brings you closer to perfect pronunciation.",
    "You're improving with every try—keep it up!",
    "Excellent focus! Small adjustments make a big difference.",
    "Keep practicing—you're making real progress!",
  ];
  return msgs[Math.floor(Math.random() * msgs.length)];
}

/** Tiny MD → HTML tailored for the AI feedback */
export function mdToHtml(md) {
  md = String(md || "")
    .replace(/\r\n/g, "\n")
    .replace(/^(#{2,3} .+?)\s+(?=[^\n])/gm, "$1\n")
    .replace(/^#{2,3}\s+(.+)$/gm, "<h3>$1</h3>")
    .replace(/(?:^|\n)((?:[-•]\s+.+(?:\n|$))+)/g, (_m, block) => {
      const items = block
        .trim()
        .split("\n")
        .map((l) => l.replace(/^[-•]\s+/, "").trim())
        .filter(Boolean)
        .map((t) => `<li>${t}</li>`)
        .join("");
      return `\n<ul>${items}</ul>\n`;
    })
    .replace(
      /^\s*(🏃‍♂️ Quick Coaching|🔤 Phoneme Profile|✋ Reassurance|💡 Did You Know\?|🌍 World Language Spotlight)\s*$/gm,
      "<h3>$1</h3>"
    );

  return md
    .split("\n")
    .map((line) =>
      line.match(/^<h3|^<ul|^<\/ul|^<li|^<\/li|^\s*$/) ? line : `<p>${line}</p>`
    )
    .join("\n");
}
</file>

<file path="helpers/dom.js">
// helpers/dom.js
export function bringInputToTop(elOrSelector = "#referenceText", offset = 0) {
  const el =
    typeof elOrSelector === "string"
      ? document.querySelector(elOrSelector)
      : elOrSelector;
  if (!el) return;
  const y = el.getBoundingClientRect().top + window.pageYOffset - offset;
  window.scrollTo({ top: y, behavior: "smooth" });
}

export function initUnderlineObserver(root = document) {
  const targets = root.querySelectorAll("h2, h3, strong");
  if (!targets.length || typeof IntersectionObserver !== "function") return;
  const io = new IntersectionObserver(
    (entries) => {
      entries.forEach((e) => {
        if (e.isIntersecting) {
          setTimeout(() => e.target.classList.add("underline-start"), 300);
          io.unobserve(e.target);
        }
      });
    },
    { threshold: 0.6 }
  );
  targets.forEach((el) => io.observe(el));
}

export function showClickHint(targetEl, msg, { delay = 1000 } = {}) {
  if (!targetEl || localStorage.getItem("seenClickHints")) return;
  const visibleMs = 7500,
    fadeMs = 400;
  setTimeout(() => targetEl.classList.add("pulse-once"), delay);

  const hint = document.createElement("div");
  hint.className = "hint-bubble";
  hint.textContent = msg;
  hint.style.opacity = "0";
  hint.style.transition = `opacity ${fadeMs}ms ease`;
  document.body.appendChild(hint);

  requestAnimationFrame(() => {
    const rect = targetEl.getBoundingClientRect();
    hint.style.left = rect.left + window.scrollX + 10 + "px";
    hint.style.top = rect.top + window.scrollY - hint.offsetHeight - 6 + "px";
  });

  setTimeout(() => (hint.style.opacity = "1"), delay);
  setTimeout(() => {
    hint.style.opacity = "0";
    setTimeout(() => {
      hint.remove();
      targetEl.classList.remove("pulse-once");
      localStorage.setItem("seenClickHints", "yes");
    }, fadeMs);
  }, delay + visibleMs);
}

/** Placeholder to avoid errors if somebody calls it. */
export function keepTooltipInView(_el, _padding = 8) {
  console.warn("keepTooltipInView placeholder triggered");
}
</file>

<file path="helpers/index.js">
// helpers/index.js (optional barrel)
export {
  LUX_USER_ID,
  scoreClass,
  buildYouglishUrl,
  isCorrupt,
  encouragingLine,
  mdToHtml,
} from "./core.js";
export { speechDetected } from "./assess.js";
export {
  bringInputToTop,
  initUnderlineObserver,
  showClickHint,
  keepTooltipInView,
} from "./dom.js";

/*
export {
  setupYGHover,
  setupPhHeaderHover,
  initPhonemeAudio,
  initPhonemeClickPlay,
} from "./media.js";
*/
</file>

<file path="lux-convo.atmo.css">
/* ============================================================
   Atmosphere
   ============================================================ */
.lux-atmo{
  position: fixed;
  inset: 0;
  z-index: 0;
  pointer-events: none;

  /* Light fallback (used if intro overrides not active) */
  background:
    radial-gradient(circle at 22% 18%, rgba(0,120,215,0.18), rgba(255,255,255,0) 58%),
    radial-gradient(circle at 78% 62%, rgba(124,77,255,0.16), rgba(255,255,255,0) 60%),
    linear-gradient(180deg, rgba(250,252,255,0.92), rgba(246,248,255,0.96));
}


/* Intro: white stage (landing page background) */
#convoApp[data-mode="intro"] .lux-atmo{
  background: #fff;
}


/* Picker/Chat: no atmo (keeps deck + chat crisp + fast) */
#convoApp[data-mode="picker"] .lux-atmo,
#convoApp[data-mode="chat"]   .lux-atmo{
  display: none !important;
}

/* Expensive blur layers: keep for none (we’re hiding .lux-atmo in picker/chat anyway).
   For INTRO parallax smoothness: disable the heavy blurred layers entirely. */
.lux-atmo-layer{
  position: absolute;
  inset: 0;
  border-radius: 999px;
  filter: blur(52px);
  opacity: 1;
  transform: translate3d(calc(var(--lux-mxS) * 18px), calc(var(--lux-myS) * 14px), 0);
  transition: opacity 500ms ease;
  z-index: 1;
}
.lux-atmo-layer.a{
  background: radial-gradient(circle at 30% 30%,
    var(--convo-atmo-a) 0%,
    rgba(255,255,255,0) 62%);
}
.lux-atmo-layer.b{
  background: radial-gradient(circle at 70% 60%,
    var(--convo-atmo-b) 0%,
    rgba(255,255,255,0) 66%);
  transform: translate3d(calc(var(--lux-mxS) * -16px), calc(var(--lux-myS) * -12px), 0);
}

/* Intro perf: remove blur tax (Edge does not rely on huge live blur) */
#convoApp[data-mode="intro"] .lux-atmo-layer{
  display: none !important;
}

.lux-atmo-fog{
  position: absolute;
  inset: 0;
  z-index: 2;

  background:
    radial-gradient(circle at 50% 0%, rgba(0,120,215,0.10), rgba(255,255,255,0) 55%),
    linear-gradient(180deg, rgba(255,255,255,0.52), rgba(255,255,255,0.74));
  opacity: 0.55;
}

/* Intro: fog becomes subtle dark vignette */
#convoApp[data-mode="intro"] .lux-atmo-fog{
  background:
    radial-gradient(circle at 50% 0%, rgba(0,0,0,0.35), rgba(0,0,0,0) 55%),
    linear-gradient(180deg, rgba(0,0,0,0.15), rgba(0,0,0,0.30));
  opacity: 0.65;
}


/* ============================================================
   Floating tiles (parallax) — Edge-style physics
   - Positions are JS-scattered (no more left/right “poles”)
   - Each tile gets independent drift (desynced) + depth layering
   ============================================================ */

/* Typed custom props so drift can animate smoothly in modern Edge/Chrome */
@property --lux-dx { syntax: "<length>"; inherits: false; initial-value: 0px; }
@property --lux-dy { syntax: "<length>"; inherits: false; initial-value: 0px; }
@property --lux-dr { syntax: "<angle>";  inherits: false; initial-value: 0deg; }

.lux-scene-cards{
  position: absolute;
  inset: 0;
  z-index: 3;
  opacity: 1;
  transition: opacity 400ms ease;
  pointer-events: none;
}

#convoApp[data-mode="chat"] .lux-scene-cards{ opacity: 0; }

.lux-scene-card{
  position: absolute;

  /* Anchors & sizing are injected by JS */
  left: var(--ax, 0px);
  top:  var(--ay, 0px);
  width:  var(--w, 320px);
  height: var(--h, 220px);

  right: auto;
  bottom: auto;

  border-radius: var(--r, 22px);
  overflow: hidden;
  pointer-events: none;

  /* “Full-bleed tile” look */
  background: transparent;
  border: 0;

  /* SOLID tiles (no bleed-through) */
  opacity: 1;

  /* CRYSTAL clear (no depth blur on the tiles themselves) */
  filter: none;

  /* keep depth via scale + shadow + z only */
  z-index: var(--z, 1);
  scale: var(--s, 1);
  box-shadow: 0 28px 80px rgba(0,0,0,var(--shadowA, 0.22));

  /* Parallax + drift combine via translate property */
  translate:
    calc(var(--lux-dx) + calc(var(--lux-mxS) * var(--parX, 0px)))
    calc(var(--lux-dy) + calc(var(--lux-myS) * var(--parY, 0px)));

  rotate: calc(var(--baseRot, 0deg) + var(--lux-dr));

  /* SAFE DEFAULT: prevent CSS evaluation from auto-fetching images */
  --img: none;

  transition: opacity 520ms ease, filter 520ms ease;
  will-change: translate, rotate, filter, opacity;
}

/* JS swaps images by fading tiles out/in */
.lux-scene-card.is-swap{
  opacity: 0;
  filter: blur(2px);
}

/* Image fill (already correct; keep “no viewport sliding”) */
.lux-scene-card::before{
  content:"";
  position:absolute;
  inset:0;
  background: var(--img, linear-gradient(135deg, #2b84ff, #7a4dff));
  background-size: cover;
  background-position: center;
  transform: scale(1.01);
  filter: none;
}

/* Drift only when intro is active + parallax is on */
#convoApp[data-mode="intro"][data-parallax="on"] .lux-scene-card{
  animation: luxSceneDrift var(--driftDur, 18s) ease-in-out infinite;
  animation-delay: var(--driftDelay, 0s);
}

#convoApp:not([data-mode="intro"]) .lux-scene-card{
  animation: none;
  --lux-dx: 0px;
  --lux-dy: 0px;
  --lux-dr: 0deg;
}

/* Independent drift path (per-tile amplitudes are vars) */
@keyframes luxSceneDrift{
  0%, 100%{
    --lux-dx: 0px;
    --lux-dy: 0px;
    --lux-dr: 0deg;
  }
  22%{
    --lux-dx: var(--driftX, 18px);
    --lux-dy: calc(var(--driftY, 14px) * -0.45);
    --lux-dr: calc(var(--driftR, 2deg) * -1);
  }
  50%{
    --lux-dx: calc(var(--driftX, 18px) * -0.65);
    --lux-dy: var(--driftY, 14px);
    --lux-dr: var(--driftR, 2deg);
  }
  78%{
    --lux-dx: calc(var(--driftX, 18px) * 0.35);
    --lux-dy: calc(var(--driftY, 14px) * -1);
    --lux-dr: calc(var(--driftR, 2deg) * 0.6);
  }
}

/* Micro tiles (optional Edge-like “dust” fill) */
.lux-scene-card.is-micro{
  border-radius: 18px;
  box-shadow: 0 18px 60px rgba(0,0,0,var(--shadowA, 0.16));
}


/* Reduced motion: freeze tiles completely */
@media (prefers-reduced-motion: reduce){
  #convoApp .lux-scene-card{
    animation: none !important;
    translate: 0 0 !important;
    rotate: 0deg !important;
    filter: none !important;
  }
}
</file>

<file path="lux-convo.css">
/* lux-convo.css (entrypoint)
   Split into modules to keep convo styling editable + sane.
   Revert: use lux-convo.full.css
*/

@import "./lux-convo.tokens.css";
@import "./lux-convo.system.css";
@import "./lux-convo.atmo.css";
@import "./lux-convo.picker.css";
@import "./lux-convo.knobs.css";
@import "./lux-convo.chat.css";
</file>

<file path="lux-convo.knobs.css">
/* =========================================================
   Knobs drawer (shared: picker + convo)
========================================================= */

.lux-knobsOverlay{
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.28);
  opacity: 0;
  pointer-events: none;
  transition: opacity 180ms ease;
  z-index: 998;
}
.lux-knobsOverlay[data-open="1"]{
  opacity: 1;
  pointer-events: auto;
}

.lux-knobsDrawer{
  position: fixed;
  top: 0;
  right: 0;
  height: 100vh;
  width: 340px;
  max-width: 92vw;

  background: rgba(255,255,255,0.86);
  backdrop-filter: blur(16px);
  border-left: 1px solid rgba(0,0,0,0.10);

  transform: translateX(110%);
  transition: transform 220ms ease;
  z-index: 999;

  display: flex;
  flex-direction: column;
}
.lux-knobsDrawer[data-open="1"]{
  transform: translateX(0);
}

.lux-knobsHeader{
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 14px 14px 10px;
}
.lux-knobsTitle{
  font-size: 1.05rem;
  font-weight: 700;
}
.lux-knobsClose{
  border: 0;
  background: transparent;
  font-size: 1.1rem;
  cursor: pointer;
  opacity: 0.75;
}
.lux-knobsClose:hover{ opacity: 1; }

.lux-knobsBody{
  padding: 8px 14px 14px;
  overflow: auto;
}

.lux-knobsGroup{
  padding: 10px 0 12px;
  border-top: 1px solid rgba(0,0,0,0.06);
}
.lux-knobsGroup:first-child{ border-top: 0; }

.lux-knobsLabel{
  font-weight: 700;
  margin-bottom: 10px;
}

.lux-knobsChips{
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

.lux-knobsChips button{
  border-radius: 999px;
  padding: 7px 10px;
  border: 1px solid rgba(0,0,0,0.14);
  background: rgba(255,255,255,0.78);
  cursor: pointer;
}

.lux-knobsChips button.is-on{
  border-color: rgba(0,120,215,0.42);
  box-shadow: 0 0 0 3px rgba(0,120,215,0.16);
}

/* Picker: inline knobs row under CTA */
#convoApp[data-mode="picker"] .lux-deckKnobsRow{
  display: flex;
  align-items: center;
  gap: 10px;
  margin-top: 10px;
}

#convoApp[data-mode="picker"] .lux-deckKnobsBtn{
  border-radius: 999px;
  padding: 7px 10px;
  border: 1px solid rgba(0,0,0,0.14);
  background: rgba(255,255,255,0.82);
  cursor: pointer;
}

#convoApp[data-mode="picker"] .lux-deckKnobsSummary{
  font-size: 0.95rem;
  opacity: 0.90;
}



/* ============================================================
   LEGACY knobs drawer (keep for now; delete when migration is complete)
   ============================================================ */

/* ============================================================
   Knobs drawer
   ============================================================ */
.lux-drawer{
  position: fixed;
  top: 0;
  right: 0;

  height: 100vh;
  width: min(360px, 92vw);

  background: rgba(255,255,255,0.96);
  border-left: 1px solid rgba(0,0,0,0.10);
  box-shadow: var(--convo-shadow);

  backdrop-filter: blur(10px);

  transform: translateX(102%);
  transition: transform 260ms ease;

  z-index: var(--z-modal);
  display: flex;
  flex-direction: column;
}

.lux-drawerHd{
  padding: 12px 14px;
  border-bottom: 1px solid rgba(0,0,0,0.08);

  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 10px;

  background: var(--convo-tint);
}

#convoApp.knobs-open .lux-drawer{ transform: translateX(0); }

.lux-scrim{
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.35);
  opacity: 0;
  pointer-events: none;
  transition: opacity 200ms ease;
  z-index: calc(var(--z-modal) - 1);
}
#convoApp.knobs-open .lux-scrim{
  opacity: 1;
  pointer-events: auto;
}

/* Knobs form */
.k{
  display:flex;
  flex-direction: column;
  gap: 10px;
}
.k label{ font-size: 12px; color: var(--convo-muted); }

.k select{
  width: 100%;
  border-radius: 0.6rem;
  border: 1px solid rgba(0,0,0,0.18);
  background: #fff;
  color: var(--convo-ink);
  padding: 8px 10px;
  font-weight: 850;
  font-size: 0.95rem;
}

.small{
  font-size: 12px;
  color: var(--convo-muted);
  line-height: 1.35;
}

/* ============================================================
   Docked knobs (anchored to the convo box, not the viewport)
   Earthquake-safe: scoped overrides only
   ============================================================ */

.lux-convoStage{
  position: relative; /* anchors dock + local scrim */
}

/* Local scrim that dims only the convo box area */
.lux-knobsScrim{
  position: absolute;
  inset: 0;
  border: 0;
  padding: 0;
  background: rgba(0,0,0,0.12);
  opacity: 0;
  pointer-events: none;
  transition: opacity 180ms ease;
  border-radius: 18px; /* match the chat card rounding */
}
.lux-convoStage.knobs-open .lux-knobsScrim{
  opacity: 1;
  pointer-events: auto;
}

/* Dock host sits to the RIGHT of the convo box */
.lux-knobsDock{
  position: absolute;
  top: 0;
  left: 100%;
  margin-left: 14px;
  width: min(360px, 92vw);
  height: 100%;
  overflow: hidden;     /* enables “slide from behind” */
  pointer-events: none; /* only enabled when open */
}
.lux-convoStage.knobs-open .lux-knobsDock{
  pointer-events: auto;
  /* Shadow belongs on the dock host (drawer shadow gets clipped by overflow:hidden) */
  box-shadow: var(--convo-shadow);
  border-radius: 0 18px 18px 0; /* only the OUTSIDE lip */
}

/* Override legacy viewport drawer ONLY when inside the dock */
#convoKnobsDock .lux-drawer{
  position: absolute;
  top: 0;
  left: 0;
  height: 100%;
  width: 100%;
  /* Subtle outline like other Lux panels (white-on-white separation) */
  border: 1px solid rgba(0,0,0,0.08);
  background: rgba(255,255,255,0.98);
  transform: translateX(-100%);
  opacity: 0;
  transition: transform 280ms ease, opacity 220ms ease;
  border-radius: 0 18px 18px 0; /* only the OUTSIDE lip */
}
.lux-convoStage.knobs-open #convoKnobsDock .lux-drawer{
  transform: translateX(0);
  opacity: 1;
}
</file>

<file path="lux-convo.picker.css">
/* ============================================================
   UI stage
   ============================================================ */
.lux-ui{
  position: relative;
  z-index: 1;
  min-height: 100%;
  display: grid;
  place-items: center;
  padding: 22px 16px;
}

/* Mode routing */
.lux-intro, .lux-picker, .lux-chatwrap, .lux-convo-progress{
  width: 100%;
  display: none;
}

#convoApp[data-mode="intro"]  .lux-intro { display: grid; place-items: center; }
#convoApp[data-mode="picker"] .lux-picker{ display: flex; flex-direction: column; align-items: center; gap: 14px; }

#convoApp[data-mode="chat"] .lux-chatwrap{
  display: flex;
  flex-direction: column;   /* KEY: stack pill ABOVE chat box */
  align-items: center;
  justify-content: flex-start;
  gap: 10px;
}

/* Progress widget: ONLY show in chat mode */
#convoApp[data-mode="chat"] .lux-convo-progress{
  display:flex;
  justify-content:center;
}

/* Safety: never show it outside chat */
#convoApp:not([data-mode="chat"]) .lux-convo-progress{
  display:none !important;
}



/* ============================================================
   Intro -> Picker “warp” transition (transform-only)
   ============================================================ */
#convoApp.lux-warp .lux-intro{
  animation: luxWarpIntro 360ms cubic-bezier(.18,.9,.2,1) both;
}
#convoApp.lux-warp .lux-scene-cards{
  animation: luxWarpTiles 360ms cubic-bezier(.18,.9,.2,1) both;
}

@keyframes luxWarpIntro{
  0%{ transform: translate3d(0,0,0) scale(1); opacity: 1; }
  100%{ transform: translate3d(0,-10px,0) scale(1.08); opacity: 0; }
}
@keyframes luxWarpTiles{
  0%{ transform: translate3d(0,0,0) scale(1); opacity: 1; }
  100%{ transform: translate3d(0,0,0) scale(1.06); opacity: 0.92; }
}

#convoApp.lux-arrive .lux-picker{
  animation: luxArrivePicker 420ms cubic-bezier(.18,.9,.2,1) both;
}
@keyframes luxArrivePicker{
  0%{ transform: translate3d(0,14px,0) scale(.985); opacity: 0; }
  100%{ transform: translate3d(0,0,0) scale(1); opacity: 1; }
}

@media (prefers-reduced-motion: reduce){
  #convoApp.lux-warp .lux-intro,
  #convoApp.lux-warp .lux-scene-cards,
  #convoApp.lux-arrive .lux-picker{
    animation: none !important;
  }
}


/* ============================================================
   Shared panel chrome (matches Lux “card” language)
   ============================================================ */
.lux-panel{
  background: var(--convo-card);
  border: 1px solid var(--convo-border);
  border-radius: var(--convo-radius-lg);
  overflow: hidden;
  box-shadow: var(--convo-shadow);
}

.lux-hd{
  padding: 12px 14px;
  border-bottom: 1px solid rgba(0,0,0,0.08);
  background: var(--convo-tint);

  display:flex;
  align-items:center;
  justify-content: space-between;
  gap: 10px;

  color: var(--convo-ink);
}

.lux-title{
  font-weight: 800;
  letter-spacing: 0.2px;
  color: var(--convo-ink);
}

.lux-sub{
  color: var(--convo-muted);
  font-size: 12px;
}

.lux-body{ padding: 12px 14px; }

.lux-actions{
  display: flex;
  gap: 10px;
  align-items: center;
}


/* ============================================================
   Intro hero (Edge-like)
   ============================================================ */
.lux-heroCard{
  width: min(860px, 94vw);
  border-radius: 26px;
  background: rgba(255,255,255,0.88);
  border: 1px solid rgba(0,0,0,0.08);
  box-shadow: var(--convo-shadow);
  padding: 26px 24px;
  cursor: pointer;
  position: relative;
  overflow: hidden;
}

/* Intro: LIGHT frosted glass (keeps sheen + blur, not dark) */
#convoApp[data-mode="intro"] .lux-heroCard{
  width: min(820px, 92vw);
  min-height: 420px;
  padding: 56px 54px 46px;
  border-radius: 38px;
  text-align: center;

  /* Center the hero content (vertical + horizontal) */
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  gap: 18px;

  /* slightly “milkier” glass helps the depth read */
  background: rgba(255,255,255,0.60);
  border: 1px solid rgba(0,0,0,0.10);

  /* pillowy depth + double border trick (outer rim + inner hairline) */
  box-shadow:
    0 32px 80px rgba(0,0,0,0.18),              /* main lift */
    0 10px 26px rgba(0,0,0,0.10),              /* near shadow */
    0 0 0 1px rgba(0,0,0,0.06),                /* subtle outer rim */
    inset 0 0 0 1px rgba(255,255,255,0.42),    /* hairline inner border */
    inset 0 1px 0 rgba(255,255,255,0.55),      /* top inner highlight */
    inset 0 -10px 24px rgba(0,0,0,0.06);       /* bottom inner depth */

  /* crisp rounded edge (helps it “read” as a thick card) */
  outline: 1px solid rgba(255,255,255,0.35);
  outline-offset: -1px;

  -webkit-backdrop-filter: blur(18px) saturate(1.18);
  backdrop-filter: blur(18px) saturate(1.18);
}

/* Ensure hero content stays above the glass pseudo-elements */
#convoApp[data-mode="intro"] .lux-heroCard > *{
  position: relative;
  z-index: 2;
}

/* Soft internal “glass lighting” */
#convoApp[data-mode="intro"] .lux-heroCard::before{
  content:"";
  position:absolute;
  inset:0;
  border-radius: inherit;
  pointer-events:none;
  background:
    radial-gradient(circle at 22% 18%, rgba(255,255,255,0.14), rgba(255,255,255,0) 58%),
    radial-gradient(circle at 78% 68%, rgba(255,255,255,0.08), rgba(255,255,255,0) 55%);
}

/* Diagonal sheen sweep (every few seconds) */
#convoApp[data-mode="intro"] .lux-heroCard::after{
  content:"";
  position:absolute;
  inset:-40%;
  pointer-events:none;
  background: linear-gradient(115deg,
    rgba(255,255,255,0) 42%,
    rgba(255,255,255,0.28) 50%,
    rgba(255,255,255,0) 58%);
  transform: translateX(-120%);
  opacity: 0;
  animation: luxHeroSheen 6.8s ease-in-out infinite;
  mix-blend-mode: overlay;
}

@keyframes luxHeroSheen{
  0%,72%{ transform: translateX(-120%); opacity: 0; }
  78%{ opacity: 0.85; }
  100%{ transform: translateX(120%); opacity: 0; }
}

.lux-heroBrand{
  font-size: 13px;
  letter-spacing: 0.12em;
  text-transform: uppercase;
  color: rgba(0,0,0,0.55);
}
#convoApp[data-mode="intro"] .lux-heroBrand{
  color: rgba(0,0,0,0.58);
}

.lux-heroTitle{
  font-size: 38px;
  font-weight: 860;
  margin-top: 10px;
  color: var(--convo-ink);
}
#convoApp[data-mode="intro"] .lux-heroTitle{
  color: var(--convo-ink);
  font-size: 58px;
  line-height: 1.06;
  margin-top: 0;
}

.lux-heroSub{
  margin-top: 12px;
  font-size: 15px;
  color: rgba(0,0,0,0.62);
  line-height: 1.45;
  max-width: 70ch;
}
#convoApp[data-mode="intro"] .lux-heroSub{
  color: rgba(0,0,0,0.62);
  font-size: 22px;   /* bigger body copy */
  line-height: 1.55;
  max-width: 60ch;
  margin-top: 0;
  margin-left: auto;
  margin-right: auto;
}

/* Timed underline “draw” effect (intro hero only) */
#convoApp[data-mode="intro"] .lux-uline{
  --u-color: var(--lux-blue-primary);
  --u-thickness: 3px;
  --u-delay: 1.1s;
  display: inline-block;
  padding-bottom: 2px;
  background-image: linear-gradient(var(--u-color), var(--u-color));
  background-repeat: no-repeat;
  background-position: 0 100%;
  background-size: 0% var(--u-thickness);
  animation: luxUnderlineDraw 1.4s ease forwards;
  animation-delay: var(--u-delay);
}
#convoApp[data-mode="intro"] .lux-uline.u2{ --u-delay: 2.6s; }

@keyframes luxUnderlineDraw{
  to { background-size: 100% var(--u-thickness); }
}

@media (prefers-reduced-motion: reduce){
  #convoApp[data-mode="intro"] .lux-uline{
    animation: none;
    background-size: 100% var(--u-thickness);
  }
}

.lux-heroNext{
  margin-top: 18px;
  border: 1px solid rgba(0,0,0,0.10);
  background: rgba(255,255,255,0.70);
  color: var(--convo-ink);
  border-radius: 14px;
  padding: 12px 18px;
  cursor: pointer;
  font-weight: 800;
}
.lux-heroNext:hover{ background: rgba(255,255,255,0.92); }

/* Intro CTA: Lux-style pill (light, not stark) */
#convoApp[data-mode="intro"] .lux-heroNext{
  background: rgba(255,255,255,0.78);
  border: 1px solid rgba(0,0,0,0.12);
  color: var(--convo-ink);
  border-radius: 999px;
  padding: 14px 28px;
  font-size: 17px;
  min-width: 170px;
  box-shadow: 0 12px 26px rgba(0,0,0,0.12);
  margin-top: 0;
}
#convoApp[data-mode="intro"] .lux-heroNext:hover{
  background-color: var(--lux-water-hover, rgba(233,246,255,1));
  border-color: var(--lux-water-border, rgba(0,120,215,0.28));
  box-shadow:
    0 14px 28px rgba(0,0,0,0.12),
    0 0 0 3px var(--lux-water-halo, rgba(0,120,215,0.16));
}

@media (prefers-reduced-motion: reduce){
  #convoApp[data-mode="intro"] .lux-heroCard::after{
    animation: none !important;
    opacity: 0 !important;
  }
}


/* ============================================================
   Deck (scenario picker)
   ============================================================ */
.lux-deck{
  position: relative;
  width: min(980px, 94vw);
  height: min(var(--lux-media-h, 520px), 76vh);
  transform-style: preserve-3d;
}

/* Picker sizing bump */
#convoApp[data-mode="picker"] .lux-deck{
  width: min(1120px, 96vw);
  height: min(780px, 76vh);
}

/* The card adopts the media's NATURAL ratio.
   Height is capped to viewport; width is derived automatically. */
#convoApp[data-mode="picker"] .lux-deck-card{
  height: min(var(--lux-media-h, 520px), 76vh);
  aspect-ratio: var(--lux-media-ar, 16 / 9);
  width: auto;
}
#convoApp[data-mode="picker"] .lux-deckTitle{ font-size: 44px; }
#convoApp[data-mode="picker"] .lux-deckDesc{ font-size: 18px; }
#convoApp[data-mode="picker"] .lux-navArrow,
#convoApp[data-mode="picker"] .lux-navNext{
  font-size: 16px;
  padding: 12px 18px;
}
#convoApp[data-mode="picker"] .lux-navArrow{ min-width: 108px; }

.lux-deck-card{
  position: absolute;
  top: 50%;
  left: 50%;
  /* variable-sized cards must be vertically centered */
  transform: translate(-50%, -50%);

  border-radius: 26px;
  overflow: hidden;
  isolation: isolate;
  background: rgba(255,255,255,0.88);
  border: 1px solid rgba(0,0,0,0.08);
  box-shadow: var(--convo-shadow);

  padding: 18px 18px 16px;
  backdrop-filter: blur(10px);

  transition: transform 520ms cubic-bezier(0.18, 0.9, 0.2, 1),
              filter 520ms cubic-bezier(0.18, 0.9, 0.2, 1),
              opacity 520ms cubic-bezier(0.18, 0.9, 0.2, 1);
}

/* Deck card media layering:
   ::before = soft blurred fill (always)
   ::after  = sharp still “poster” (contain)
   .lux-cardMedia/.lux-cardVideo = video (contain), shown only when playing
*/
.lux-deck-card.has-img::before{
  content:"";
  position:absolute;
  inset:-12%;
  background-image: var(--lux-card-img);
  background-size: cover;
  background-position: center;
  filter: blur(14px) saturate(1.08);
  transform: scale(1.04);
  opacity: 0.28;
  pointer-events: none;
  z-index: 0;
}

.lux-deck-card.has-img::after{
  content:"";
  position:absolute;
  inset: 0;
  background-image: var(--lux-card-img);
  background-size: cover;
  background-position: center;
  background-repeat: no-repeat;
  opacity: 0.92;
  transition: opacity 260ms ease;
  pointer-events: none;
  z-index: 2;
}

/* video layer sits under the sharp still; the still fades out while playing */
.lux-cardMedia{
  position: absolute;
  inset: 0;
  z-index: 1;
  pointer-events: none;
  overflow: hidden;
  border-radius: inherit;
}

.lux-cardVideo{
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  object-fit: cover;
  object-position: 50% 50%;
  opacity: 0;
  transition: opacity 420ms ease;
}

/* PLAYING: show video, hide sharp still */
.lux-deck-card.has-video[data-vstate="playing"] .lux-cardVideo{ opacity: 0.34; }
.lux-deck-card.has-video[data-vstate="playing"]::after{ opacity: 0; }

/* ENDED/ERROR: hide video, restore sharp still */
.lux-deck-card.has-video[data-vstate="ended"] .lux-cardVideo{ opacity: 0; }
.lux-deck-card.has-video[data-vstate="ended"]::after{ opacity: 0.92; }

.lux-deck-card.has-video[data-vstate="error"] .lux-cardVideo{ opacity: 0; }
.lux-deck-card.has-video[data-vstate="error"]::after{ opacity: 0.92; }

/* text above all media */
.lux-deck-card.has-img > *:not(.lux-cardMedia){
  position: relative;
  z-index: 3;
}

/* ============================================================
   Deck text readability panel (scrim)
   ============================================================ */
.lux-deckText{
  position: relative;
  z-index: 3;
  max-width: min(560px, 78%);
  padding: 16px 18px;
  border-radius: 18px;

  /* dark scrim so white text reads on ANY photo/video */
  background: linear-gradient(135deg,
    rgba(0,0,0,0.64),
    rgba(0,0,0,0.26)
  );

  backdrop-filter: blur(6px);
  box-shadow: 0 14px 28px rgba(0,0,0,0.18);
}

/* Make the pill readable on media */
.lux-deckText .lux-pill{
  color: rgba(255,255,255,0.86);
  background: rgba(255,255,255,0.12);
  border-color: rgba(255,255,255,0.22);
}

/* White text + subtle shadow */
.lux-deckText .lux-deckTitle{
  color: rgba(255,255,255,0.96);
  text-shadow: 0 2px 10px rgba(0,0,0,0.35);
}

.lux-deckText .lux-deckDesc{
  color: rgba(255,255,255,0.84);
  text-shadow: 0 2px 10px rgba(0,0,0,0.28);
}

/* Expand/collapse (taller “fog box” reveal) */
.lux-deckMore{
  margin-top: 10px;
  color: rgba(255,255,255,0.84);
  text-shadow: 0 2px 10px rgba(0,0,0,0.28);

  max-height: 0;
  overflow: hidden;
  opacity: 0;
  transform: translateY(-4px);

  transition:
    max-height 240ms ease,
    opacity 180ms ease,
    transform 240ms ease;
}

.lux-deck-card.isExpanded .lux-deckMore{
  max-height: 240px;
  opacity: 1;
  transform: translateY(0);
}

/* CTA stands out (and is the only "enter" affordance) */
.lux-deckText .lux-deckCta{
  background: rgba(255,255,255,0.92);
  border: 1px solid rgba(255,255,255,0.35);
  color: rgba(0,0,0,0.86);
  box-shadow: 0 12px 20px rgba(0,0,0,0.22);
}
.lux-deckText .lux-deckCta:hover{
  background: rgba(255,255,255,0.98);
}

/* While video is playing, strengthen the scrim a bit */
.lux-deck-card.has-video[data-vstate="playing"] .lux-deckText{
  background: linear-gradient(135deg,
    rgba(0,0,0,0.72),
    rgba(0,0,0,0.32)
  );
}

@media (prefers-reduced-motion: reduce){
  .lux-cardVideo{ display: none !important; }
  .lux-deck-card.has-img::after{ opacity: 0.92 !important; }
}

.lux-deck-card.is-active{
  width: min(660px, 92vw);
  z-index: 3;
  opacity: 1;
  filter: blur(0px);
  cursor: pointer;
}

.lux-deck-card.is-preview{
  width: min(520px, 86vw);
  z-index: 1;
  opacity: 0.62;       /* was 0.55 */
  filter: blur(4.5px); /* was 6px */
  cursor: pointer;
}

/* Overlap + left/right staggering (MORE separation) */
#convoApp[data-side="left"]  .lux-deck-card.is-active { transform: translate(-50%, -50%) translateX(-110px) scale(1.00); }
#convoApp[data-side="left"]  .lux-deck-card.is-preview{ transform: translate(-50%, -50%) translateX(190px)  scale(0.90); }

#convoApp[data-side="right"] .lux-deck-card.is-active { transform: translate(-50%, -50%) translateX(110px)  scale(1.00); }
#convoApp[data-side="right"] .lux-deck-card.is-preview{ transform: translate(-50%, -50%) translateX(-190px) scale(0.90); }

.lux-pill{
  display: inline-flex;
  gap: 8px;
  align-items: center;
  font-size: 12px;
  letter-spacing: 0.10em;
  text-transform: uppercase;

  color: rgba(0,0,0,0.60);
  background: rgba(0,0,0,0.04);
  border: 1px solid rgba(0,0,0,0.08);

  padding: 6px 10px;
  border-radius: 999px;
}

.lux-deckTitle{
  margin-top: 14px;
  font-size: 28px;
  font-weight: 820;
  color: var(--convo-ink);
}

.lux-deckDesc{
  margin-top: 10px;
  font-size: 15px;
  color: rgba(0,0,0,0.62);
  line-height: 1.45;
  max-width: 52ch;
}

.lux-deckCta{
  margin-top: 16px;
  background: rgba(0,120,215,0.10);
  border: 1px solid rgba(0,120,215,0.22);
  color: var(--convo-ink);
  border-radius: 14px;
  padding: 10px 14px;
  cursor: pointer;
  font-weight: 850;
}
.lux-deckCta:hover{ background: rgba(0,120,215,0.14); }

/* =========================================================
   Picker: thumbnail dots (bigger + actual image preview)
   NOTE: Your DOM uses .lux-thumbs + .lux-thumb already.
   This block upgrades them in picker mode (size + cover/center).
========================================================= */

#convoApp[data-mode="picker"] .lux-thumbs{
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 8px;
  margin-top: 10px;

  /* NEW: prevent wrap intrusion; make it a horizontal strip */
  flex-wrap: nowrap;
  overflow-x: auto;
  overflow-y: hidden;
  -webkit-overflow-scrolling: touch;

  width: min(980px, 94vw);
  max-width: min(980px, 94vw);

  padding: 6px 10px;
  margin: 14px auto 0; /* give it breathing room */
  position: relative;
  z-index: 10;
}

/* base “dot” becomes a tiny thumbnail */
#convoApp[data-mode="picker"] .lux-thumb{
  width: 28px;              /* bigger than circles, still small */
  height: 18px;
  border-radius: 6px;

  background-size: cover;
  background-position: center;
  background-repeat: no-repeat;

  border: 1px solid rgba(0,0,0,0.10);
  box-shadow: 0 8px 18px rgba(0,0,0,0.10);

  opacity: 0.70;
  transform: translateY(0);
  transition: transform 160ms ease, opacity 160ms ease, box-shadow 160ms ease;
  cursor: pointer;

  /* NEW: keep each thumb from shrinking/wrapping */
  flex: 0 0 auto;
}

/* keep non-image fallback readable (single letter) */
#convoApp[data-mode="picker"] .lux-thumb:not(.has-img){
  display: inline-flex;
  align-items: center;
  justify-content: center;
  font-size: 10px;
  line-height: 1;
}

#convoApp[data-mode="picker"] .lux-thumb:hover{
  opacity: 0.95;
  transform: translateY(-1px) scale(1.04);
  box-shadow: 0 10px 22px rgba(0,0,0,0.12);
}

#convoApp[data-mode="picker"] .lux-thumb.is-active{
  opacity: 1;
  border-color: rgba(0,120,215,0.45);
  box-shadow:
    0 12px 26px rgba(0,0,0,0.14),
    0 0 0 3px rgba(0,120,215,0.18);
}

/* Picker nav row (Back / Next) */
#convoApp[data-mode="picker"] .lux-navrow{
  width: min(980px, 94vw);
  margin: 14px auto 0;
  display:flex;
  justify-content: space-between;
  align-items:center;
  position: relative;
  z-index: 20;
}

#convoApp[data-mode="picker"] .lux-navbtn{
  min-width: 110px;
  text-align: center;
}

/* Thumbnails */
.lux-thumbs{
  width: min(980px, 94vw);
  display: flex;
  justify-content: center;
  gap: 8px;
  flex-wrap: wrap;
  padding: 2px 4px;
}
.lux-thumb{
  width: 16px;
  height: 16px;
  border-radius: 999px;
  border: 1px solid rgba(0,0,0,0.14);
  background: rgba(255,255,255,0.70);
  color: rgba(0,0,0,0.70);

  font-size: 10px;
  line-height: 14px;
  text-align: center;

  cursor: pointer;
  padding: 0;
}
.lux-thumb.is-active{
  background: rgba(0,120,215,0.14);
  border-color: rgba(0,120,215,0.35);
}

/* Deck nav */
.lux-deckNav{
  width: min(980px, 94vw);
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 12px;
  margin-top: 4px;
}
.lux-navArrow,
.lux-navNext{
  border-radius: 14px;
  padding: 10px 14px;
  border: 1px solid rgba(0,0,0,0.10);
  background: rgba(255,255,255,0.70);
  color: var(--convo-ink);
  cursor: pointer;
  font-weight: 850;
}
.lux-navArrow:hover,
.lux-navNext:hover{ background: rgba(255,255,255,0.92); }
</file>

<file path="lux-convo.system.css">
/* ============================================================
   TTS portal + drawer layering (critical for interactivity)
   ============================================================ */

/* Global-ish resets (kept from lux-convo.full.css for parity) */
*{ box-sizing: border-box; }
html, body{ height: 100%; }

#tts-controls{
  position: fixed;
  top: 0;
  right: 0;
  z-index: var(--z-drawer);
  overflow: visible;
  pointer-events: auto; /* keep TTS controls interactive */
}

/* Keep drawers above the conversation stage */
.lux-tts-panel,
.lux-sp-panel{
  z-index: var(--z-drawer) !important;
}

/* Self-Playback (Left) */
.lux-sp-panel{ left: 0 !important; right: auto !important; }
.lux-sp-tab{ left: 20px !important; right: auto !important; }

/* Text-to-Speech (Right) */
.lux-tts-panel{ right: 0 !important; left: auto !important; }
.lux-tts-tab{ right: 20px !important; left: auto !important; }

html.lux-tts-open .lux-tts-panel{ transform: translate3d(0,0,0) !important; }
html.lux-sp-open  .lux-sp-panel { transform: translate3d(0,0,0) !important; }

/* Canonical gating: drawers exist ONLY in chat mode */
html:not([data-lux-convo-mode="chat"]) #tts-controls,
html:not([data-lux-convo-mode="chat"]) .lux-tts-tab,
html:not([data-lux-convo-mode="chat"]) .lux-tts-panel,
html:not([data-lux-convo-mode="chat"]) #self-playback-drawer-target,
html:not([data-lux-convo-mode="chat"]) .lux-sp-tab,
html:not([data-lux-convo-mode="chat"]) .lux-sp-panel{
  display: none !important;
}

/* Canonical gating: Save Progress/Login button ONLY in chat mode */
html:not([data-lux-convo-mode="chat"]) #lux-auth-btn{
  display: none !important;
}



/* ============================================================
   Stage wrapper
   ============================================================ */
#convoApp{
  width: 100%;
  max-width: 1280px;       /* match lux-layout #container max width */
  min-height: calc(100vh - 20px);
  position: relative;
  overflow: hidden;

  border-radius: var(--convo-radius-lg);
  background:
    radial-gradient(circle at 28% 22%, rgba(0,120,215,0.10), rgba(255,255,255,0) 58%),
    radial-gradient(circle at 78% 62%, rgba(124,77,255,0.08), rgba(255,255,255,0) 60%),
    var(--convo-card);
  box-shadow: var(--convo-shadow-soft);

  /* Parallax driver vars set by JS */
  --lux-hue: 210;
  --lux-mx: 0;
  --lux-my: 0;

  /* Parallax strength knobs */
  --lux-par-bg: 2.8;
  --lux-par-img: 3.2;
  --lux-mxS: calc(var(--lux-mx) * var(--lux-par-bg));
  --lux-myS: calc(var(--lux-my) * var(--lux-par-bg));
  --lux-mxI: calc(var(--lux-mx) * var(--lux-par-img));
  --lux-myI: calc(var(--lux-my) * var(--lux-par-img));
}

/* Allow the chat-mode knobs dock to extend past the rounded app card.
   This is the direct fix for the “clipped by the outer white box” issue. */
#convoApp[data-mode="chat"],
#convoApp[data-mode="picker"]{
  overflow: visible;
}

/* Full-bleed stage for intro + picker (chat stays boxed) */
#convoApp[data-mode="intro"],
#convoApp[data-mode="picker"]{
  width: 100vw;
  max-width: none;
  margin-left: calc(50% - 50vw);
  margin-right: calc(50% - 50vw);

  border-radius: 0;
  box-shadow: none;
  background: transparent;
  overflow: hidden;

  --lux-par-bg: 7.5;
  --lux-par-img: 9.0;
}

/* Picker should start at the top (prevents deck creeping into header/toplinks) */
#convoApp[data-mode="picker"] .lux-ui{
  place-items: start center;
  padding-top: 28px;
  padding-bottom: 28px;
}


/* Keep chat calmer */
#convoApp[data-mode="chat"]{
  --lux-par-bg: 2.4;
  --lux-par-img: 2.8;
  background: var(--convo-card) !important;
}

/* ============================================================
   NEW: Intro must be viewport-locked (no scroll / pan)
   ============================================================ */

/* Lock page scrolling while intro is active (Edge supports :has()) */

html:has(#convoApp[data-mode="intro"]),
body:has(#convoApp[data-mode="intro"]){
  height: 100%;
  overflow: hidden;
  overscroll-behavior: none;
}

/* Lock the intro stage to the viewport */
#convoApp[data-mode="intro"]{
  position: fixed;
  inset: 0;
  height: 100vh;
  overflow: hidden;          /* overrides the earlier overflow:visible */
  overscroll-behavior: none;
  touch-action: none;        /* blocks drag-pan */
}
</file>

<file path="lux-convo.tokens.css">
/* =========================
   Convo tokens (map to Lux)
   ========================= */
:root{
  --convo-ink: var(--lux-text-main);
  --convo-muted: var(--lux-text-muted);

  --convo-accent: var(--lux-blue-primary);
  --convo-accent-hover: var(--lux-blue-hover);

  --convo-card: #ffffff;
  --convo-tint: #f8fbff;
  --convo-border: rgba(0,0,0,0.10);

  --convo-radius: 16px;
  --convo-radius-lg: 22px;

  --convo-shadow: 0 10px 28px rgba(0,0,0,0.10);
  --convo-shadow-soft: 0 3px 10px rgba(0,0,0,0.08);

  /* Light atmosphere colors (used for non-intro or fallback) */
  --convo-atmo-a: rgba(0, 120, 215, 0.14);
  --convo-atmo-b: rgba(124, 77, 255, 0.10);

  /* Edge-like intro palette */
  --edge-bg-a: #0b2a2b;
  --edge-bg-b: #12402f;
  --edge-bg-c: #0a1f2a;

  --edge-panel: rgba(12, 40, 36, 0.70);
  --edge-panel-border: rgba(255,255,255,0.14);
  --edge-panel-shadow: 0 30px 90px rgba(0,0,0,0.55);

  --edge-ink: rgba(255,255,255,0.92);
  --edge-muted: rgba(255,255,255,0.72);
}
</file>

<file path="lux-layout.core.css">
/* lux-layout.core.css */

/* Core application styles */

#typewriterMsg {
  white-space: pre;
  opacity: 1;
  transition: opacity 0.5s;
}

.hidden {
  display: none !important;
}

@keyframes tipPop {
  0% { transform: scale(0.2) rotate(-30deg); opacity: 0; color: #bbb; }
  40% { transform: scale(1.4) rotate(10deg); opacity: 1; color: #1e90ff; }
  70% { transform: scale(0.88) rotate(-5deg); color: #205080; }
  85% { transform: scale(1.05) rotate(0); color: #0078d7; }
  100% { transform: scale(1) rotate(0); color: inherit; }
}

#prettyResult a {
  text-decoration: none !important;
  font-weight: 700;
}
#prettyResult a:visited,
#prettyResult a:active,
#prettyResult a:focus {
  text-decoration: none !important;
  color: inherit !important;
}
#prettyResult a:hover {
  text-decoration: underline dotted;
  color: #0078d7;
}

.pop-in {
  animation: tipPop 1.4s cubic-bezier(0.18, 1.7, 0.28, 1.01);
}

body {
  min-height: 100vh;
  display: flex;
  justify-content: center;
  align-items: flex-start;
  font-family: "Montserrat", system-ui, sans-serif;
  background: #fff;
  color: #333;
  margin: 0;
  line-height: 1.5;
  padding: 10px;
}

#container {
  width: 100%;
  max-width: 1280px;
  margin: 0 auto;
  padding: calc(2vw + var(--lux-top-banner-offset, 0px)) 2vw 3vw;
  box-sizing: border-box;
}

@keyframes slowSpin {
  0% { transform: rotate(0); }
  100% { transform: rotate(360deg); }
}

.ai-spinner {
  display: inline-block;
  animation: slowSpin 2.4s linear infinite;
}

button,
#nextPartBtn {
  transition: background 0.15s, transform 0.18s ease, filter 0.18s ease;
}
/* EDITED: Added :not(.lux-col-toggle) to prevent conflict with rotation transforms */
button:hover:not(:disabled):not(.lux-col-toggle),
#nextPartBtn:hover:not(:disabled) {
  transform: scale(1.12);
  filter: brightness(0.85);
}

/* ============================================================
   RESULTS PILL BASE (CRITICAL FIX)
   - Remove legacy scale + brightness from result word-pill hover
   - Remove filter transition from result pills
   - Do NOT define #prettyResult a:hover here anymore; let global
     "interactive depth" handle transform/box-shadow (lift/press).
   - Explicitly neutralize tooltip hover inside results to prevent
     global .tooltip:hover darken from leaking into results.
   ============================================================ */
#prettyResult a,
#prettyResult .tooltip {
  display: inline-block;
  transition: transform 140ms ease, box-shadow 140ms ease;
}

/* Keep result tooltips consistent: lift + shadow only, no darken */
#prettyResult .tooltip:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.28);
  filter: none;
}
#prettyResult .tooltip:active {
  transform: translateY(0);
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.20);
  filter: none;
}

/* --- Input Effects --- */
#referenceText,
#partsInfoTip {
  transition: transform 0.18s ease, box-shadow 0.18s ease;
}
#referenceText:hover,
#partsInfoTip:hover {
  transform: translateY(-2px);
  filter: none;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.28);
}

.tooltip {
  transition: transform 0.18s ease, filter 0.18s ease;
}
.tooltip:hover {
  transform: scale(1.12);
  filter: brightness(0.85);
}

h2 {
  font-size: 2.25rem;
  margin: 2rem 0 1rem;
  text-align: center;
}

label {
  font-size: 1.15rem;
  display: inline-block;
  text-align: center;
  width: 100%;
}

#referenceText {
  width: 95vw;
  max-width: 880px;
  min-height: 120px;
  font-size: 1.6rem;
  font-weight: 700;
  line-height: 1.4;
  padding: 1.2rem;
  border-radius: 0.8rem;
  resize: vertical;
}

input::placeholder {
  color: #888 !important;
  font-style: italic;
  letter-spacing: 0.03em;
  opacity: 1;
  font-size: 1.12rem;
}
#referenceText::placeholder {
  opacity: 1;
  transition: opacity 0.45s ease;
  font-style: italic;
}
#referenceText.placeholder-fade::placeholder {
  opacity: 0;
}

select {
  font-size: 1.17rem;
  font-weight: 700;
  padding: 0.5rem 1rem;
  border: 1px solid #bbb;
  border-radius: 0.6rem;
  background: #f8f8f8;
  margin: 0.3rem auto 1rem;
}
</file>

<file path="lux-layout.harvard.css">
/* lux-layout.harvard.css */

/* Harvard picker: centered row under the passage select */
.lux-harvard-picker{
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 10px;
  margin-top: 10px;
}

/* Harvard label should match "Select Passage:" label sizing */
.lux-harvard-label{
  font-size: 1.15rem;    /* matches your global label rule */
  line-height: 1;
  white-space: nowrap;
}

/* Make Harvard buttons a bit smaller (scoped to this row only) */
.lux-harvard-picker button{
  font-size: 1.0rem;
  padding: 0.55rem 1.15rem;
  border-radius: 0.6rem;
}

/* Arrows: slightly narrower so they don’t dominate */
#harvardPrev,
#harvardNext{
  padding: 0.55rem 0.95rem;
}

/* Number input: slightly larger + rounder */
.lux-harvard-picker input[type="number"]{
  width: 76px;
  padding: 8px 10px;
  font-size: 1.05rem;
  border-radius: 0.8rem;
  text-align: center;
}

/* Optional: if you keep sr-only in HTML */
.sr-only{
  position: absolute !important;
  width: 1px; height: 1px;
  padding: 0; margin: -1px;
  overflow: hidden;
  clip: rect(0,0,0,0);
  white-space: nowrap;
  border: 0;
}
</file>

<file path="lux-layout.interactions.css">
/* lux-layout.interactions.css */

/* ============================================================
   Global Interactive Depth Effect (Generic)
   ============================================================ */
a,
button,
select,
.tooltip,
input[type="checkbox"],
input[type="radio"],
.clickable {
  transition: box-shadow 0.18s ease, transform 0.18s ease;
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.18);
}
a:hover,
button:hover,
select:hover,
input[type="checkbox"]:hover,
input[type="radio"]:hover,
.clickable:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.28);
}
a:active,
button:active,
select:active,
.tooltip:active,
input[type="checkbox"]:active,
input[type="radio"]:active,
.clickable:active {
  transform: translateY(0);
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
}
a:focus-visible,
button:focus-visible,
select:focus-visible,
.tooltip:focus-visible,
input[type="checkbox"]:focus-visible,
input[type="radio"]:focus-visible,
.clickable:focus-visible {
  outline: 2px solid #0078d7;
  outline-offset: 2px;
}

@media (max-width: 650px) {
  #container { padding: 1vw 0.5vw 4vw; }
  h2 { font-size: 1.5rem; }
  input[type="text"], button, #prettyResult, .score-table th, .score-table td { font-size: 1rem; }
  input[type="text"] { width: 95vw; max-width: 99vw; }
}

@keyframes pulseOnce {
  0% { box-shadow: 0 0 0 0 rgba(0, 140, 255, 0.6); }
  70% { box-shadow: 0 0 0 12px rgba(0, 140, 255, 0); }
  100% { box-shadow: 0 0 0 0 rgba(0, 140, 255, 0); }
}
.pulse-once { animation: pulseOnce 1.7s ease-out 1; border-radius: 4px; }

.hint-bubble {
  position: absolute; background: #008cff; color: #fff; padding: 10px 14px; border-radius: 8px;
  font-size: 1rem; line-height: 1.2; opacity: 0.9; white-space: nowrap; z-index: 9999;
  pointer-events: none; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15);
}
</file>

<file path="lux-layout.nav-cta.css">
/* lux-layout.nav-cta.css */

/* ===========================
   AI Convo CTA — Apple Intelligence ring (v5)
   Goals:
   - Obvious motion (ring rotates + hotspot orbits)
   - Visible “thickness ripple” (hotspot wedge riding the ring)
   - One-time glass sheen sweep across the button interior on hover entry
   - No weird interior artifacts (shimmer is its own layer, not baked into backgrounds)
   =========================== */

@property --luxRingAngle {
  syntax: "<angle>";
  inherits: true;          /* IMPORTANT: let ::after see it */
  initial-value: 0deg;
}
@property --luxHotAngle {
  syntax: "<angle>";
  inherits: true;          /* IMPORTANT: let ::after see it */
  initial-value: 0deg;
}

/* Wrapper */
.lux-toplinks{
  margin: 18px auto 0;
  width: min(980px, 94vw);
  display:flex;
  gap: 8px;

  position: relative;
  z-index: 200; /* stay above atmo/deck layers */
}

/* Centered CTA wrapper (if used on some pages) */
.lux-toplinks-cta{
  display: flex;
  justify-content: center;
  margin-bottom: 18px;

  position: relative;
  z-index: 200; /* match top links */
}

.lux-toplink{
  font-weight: 800;
  text-decoration: none;
}


/* Base: same pill size/shape everywhere */
.lux-navpill {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: min(420px, 92vw);   /* SAME SIZE everywhere */
  padding: 16px 30px;
  font-size: 18px;
  font-weight: 900;
  text-decoration: none;
  border-radius: 999px;
  position: relative;
  isolation: isolate;

  color: #1f2a37;
  background: rgba(255,255,255,0.98);
  border: 1px solid rgba(0,0,0,0.10);
  box-shadow: 0 12px 26px rgba(0,0,0,0.10);
  transition:
    transform 160ms ease,
    background-color 180ms ease,
    border-color 180ms ease,
    box-shadow 200ms ease,
    color 180ms ease,
    filter 180ms ease;
  cursor: pointer;
  -webkit-appearance: none;
  appearance: none;
}

/* Hover: water-blue wash */
.lux-navpill:hover:not(:disabled){
  transform: translateY(-2px);
  background-color: var(--lux-water-hover);
  border-color: var(--lux-water-border);
  box-shadow:
    0 14px 28px rgba(0,0,0,0.10),
    0 0 0 3px var(--lux-water-halo);
}

/* Press: slightly deeper “dip” */
.lux-navpill:active:not(:disabled){
  transform: translateY(0);
  background-color: var(--lux-water-hover-2);
  border-color: rgba(0,120,215,0.34);
  box-shadow:
    0 10px 18px rgba(0,0,0,0.12),
    0 0 0 3px rgba(0,120,215,0.12);
}

.lux-navpill:focus-visible { outline: 3px solid rgba(0,120,215,0.35); outline-offset: 3px; }

/* ========================================================================
   DISABLED: Destination animation “to AI Conversations” = rainbow ring
   (The “windmill” system)
   ======================================================================== */

/*
.lux-navpill--to-convo {
  background: transparent;
  border: none;
  box-shadow: none;
}

.lux-navpill--to-convo::before {
  content: "";
  position: absolute;
  inset: 0;
  border-radius: 999px;
  background: conic-gradient(
    from 0deg,
    #3b82f6, #a855f7, #ec4899, #f97316, #f59e0b, #22c55e, #3b82f6
  );
  animation: luxNavRingSpin var(--luxRingDur, 4.2s) linear infinite;
  z-index: -2;
}

.lux-navpill--to-convo::after {
  content: "";
  position: absolute;
  inset: 3px;               ring thickness
  border-radius: 999px;
  background: rgba(255,255,255,0.98);
  border: 1px solid rgba(0,0,0,0.10);
  box-shadow: 0 12px 26px rgba(0,0,0,0.10);
  z-index: -1;
}

@keyframes luxNavRingSpin {
  to { transform: rotate(360deg); }
}
*/



/* Use on any CTA you want to match the AI Conversations pill size */
.lux-cta-same {
  width: min(420px, 92vw);   /* consistent “big button” width, responsive */
  display: inline-flex;
  align-items: center;
  justify-content: center;
  text-align: center;
}

/* Ripple-ready: keeps filter effects from looking janky */
[data-lux-ripple]{
  display: inline-block;
  transform: translateZ(0); /* encourage GPU compositing */
  will-change: filter;
}
/* Don't let the ripple helper clobber navpill centering */
.lux-navpill[data-lux-ripple]{
  display: inline-flex;
}


/* Base button */
a.lux-toplink-cta,
button.lux-toplink-cta{
  padding: 16px 30px;
  font-size: 18px;
  font-weight: 900;

  --luxRingDur: 4.2s;      /* SPEED KNOB: lower = faster */
  --luxHotDur: 2.6s;       /* hotspot moves faster than the ring */

  position: relative;
  isolation: isolate;

  color: #1f2a37;
  border: 1px solid rgba(0,0,0,0.10);
  border-radius: 999px;
  background: linear-gradient(rgba(255,255,255,0.98), rgba(255,255,255,0.98)) padding-box;

  box-shadow: 0 12px 26px rgba(0,0,0,0.10);
  transition: transform 160ms ease, box-shadow 160ms ease;

  /* important for button parity */
  cursor: pointer;
  appearance: none;
  -webkit-appearance: none;
}

/* One-time “sun flash” glass sheen (interior only) */
a.lux-toplink-cta::before,
button.lux-toplink-cta::before{
  content: "";
  position: absolute;
  inset: 0;
  border-radius: inherit;
  pointer-events: none;
  z-index: 2;

  /* wider bright band + softer shoulders (bigger + more “glass”) */
  background: linear-gradient(135deg,
    rgba(255,255,255,0) 0%,
    rgba(255,255,255,0) 28%,
    rgba(255,255,255,0.30) 40%,
    rgba(255,255,255,0.78) 50%,
    rgba(255,255,255,0.98) 55%,
    rgba(255,255,255,0.55) 66%,
    rgba(255,255,255,0) 78%,
    rgba(255,255,255,0) 100%
  );

  transform: translate3d(-160%, -26%, 0) rotate(12deg);
  opacity: 0;
  mix-blend-mode: screen; /* gives the “glass” vibe without muddying */
}

/* Outer glow halo (ring-only cutout) */
a.lux-toplink-cta::after,
button.lux-toplink-cta::after{
  content: "";
  position: absolute;
  inset: -22px;
  border-radius: inherit;
  pointer-events: none;
  z-index: 0;

  opacity: 0;

  background: conic-gradient(
    from var(--luxRingAngle),
    rgba(255,55,95,0.85),
    rgba(255,159,10,0.78),
    rgba(255,214,10,0.74),
    rgba(50,215,75,0.74),
    rgba(100,210,255,0.78),
    rgba(10,132,255,0.85),
    rgba(191,90,242,0.85),
    rgba(255,45,85,0.85),
    rgba(255,55,95,0.85)
  );

  mix-blend-mode: screen;

  /* ring-only cutout (prevents filling the center) */
  padding: 18px;
  -webkit-mask:
    linear-gradient(#000 0 0) content-box,
    linear-gradient(#000 0 0);
  -webkit-mask-composite: xor;
  mask-composite: exclude;
}

/* Hover: crisp rotating ring + moving thickness hotspot + one-time sheen */
a.lux-toplink-cta:hover,
a.lux-toplink-cta:focus-visible,
button.lux-toplink-cta:hover,
button.lux-toplink-cta:focus-visible{
  transform: translateY(-1px) !important; /* override global a:hover */
  box-shadow: 0 16px 36px rgba(0,0,0,0.14) !important;

  border: 3px solid transparent;

  background:
    /* fill */
    linear-gradient(rgba(255,255,255,0.98), rgba(255,255,255,0.98)) padding-box,

    /* HOTSPOT (this is your “thickness ripple” cue) */
    conic-gradient(
      from var(--luxHotAngle),
      rgba(255,255,255,0.00) 0deg,
      rgba(255,255,255,0.00) 300deg,
      rgba(255,255,255,0.85) 322deg,
      rgba(255,255,255,0.15) 346deg,
      rgba(255,255,255,0.00) 360deg
    ) border-box,

    /* main ring */
    conic-gradient(
      from var(--luxRingAngle),
      #ff375f,
      #ff9f0a,
      #ffd60a,
      #32d74b,
      #64d2ff,
      #0a84ff,
      #bf5af2,
      #ff2d55,
      #ff375f
    ) border-box;

  /* Motion: ring rotates + hotspot orbits */
  animation:
    luxRingSpin var(--luxRingDur) linear infinite,
    luxHotSpin var(--luxHotDur) linear infinite;
}

/* Start the halo + breathe it a bit */
a.lux-toplink-cta:hover::after,
a.lux-toplink-cta:focus-visible::after,
button.lux-toplink-cta:hover::after,
button.lux-toplink-cta:focus-visible::after{
  opacity: 0.80;
  filter: url(#luxCoronaFlare);
  animation:
    luxGlowBreath 3.4s ease-in-out infinite;
}

/* Sheen runs ONCE per hover entry */
a.lux-toplink-cta:hover::before,
a.lux-toplink-cta:focus-visible::before,
button.lux-toplink-cta:hover::before,
button.lux-toplink-cta:focus-visible::before{
  opacity: 0.95;
  animation: luxGlassSweep 980ms ease-out 1;
}

/* Animations */
@keyframes luxRingSpin{ to { --luxRingAngle: 360deg; } }
@keyframes luxHotSpin { to { --luxHotAngle: 360deg; } }

@keyframes luxGlowBreath{
  0%,100%{ opacity: 0.74; transform: scale(1); }
  50%{    opacity: 0.92; transform: scale(1.035); }
}

@keyframes luxGlassSweep{
  0%   { transform: translate3d(-160%, -26%, 0) rotate(12deg); opacity: 0; }
  12%  { opacity: 0.85; }
  100% { transform: translate3d(160%, 26%, 0) rotate(12deg); opacity: 0; }
}

@media (prefers-reduced-motion: reduce){
  a.lux-toplink-cta:hover,
  a.lux-toplink-cta:focus-visible,
  button.lux-toplink-cta:hover,
  button.lux-toplink-cta:focus-visible{ animation: none; }
  a.lux-toplink-cta:hover::before,
  a.lux-toplink-cta:focus-visible::before,
  a.lux-toplink-cta:hover::after,
  a.lux-toplink-cta:focus-visible::after,
  button.lux-toplink-cta:hover::before,
  button.lux-toplink-cta:focus-visible::before,
  button.lux-toplink-cta:hover::after,
  button.lux-toplink-cta:focus-visible::after{ animation: none; }
}
</file>

<file path="lux-layout.tokens.css">
/* lux-layout.tokens.css */
/* ============================================================================
   THE LUX CONSTITUTION: Global Variables
   Single Source of Truth for Layers & Theme
   ============================================================================ */
:root {
  /* --- 1. Z-INDEX TIER SCALE (The Peace Treaty) --- 
      FIXED: Elevated Drawer tier to 900 to sit above the new Modal/Blue Box tier (800) */
  --z-base: 1;
  --z-ui-low: 100;    /* Result pills, generic UI */
  --z-popover: 600;   /* Standard Tooltips */
  --z-modal: 800;     /* Blue Box, Context Menus, High-Priority Cards */
  --z-drawer: 900;    /* Self-Playback & TTS Drawers (Must slide OVER the Blue Box) */
  --z-toast: 950;     /* Error messages / Toasts */
  --z-max: 1000;      /* The absolute ceiling (Onboarding Overlay) */

  /* --- 2. GLOBAL COLORS --- */
  --lux-blue-primary: #0078d7;
  --lux-blue-hover: #005a9e;
  --lux-bg-light: #ffffff;
  --lux-text-main: #333333;
  --lux-text-muted: #666666;

  /* --- 3. RECORDING STATES (Moved from base.css) --- */
  --rec-base: #eab308;
  --rec-ink: #111;
  --rec-glow-soft: rgba(234, 179, 8, 0.55);
  --rec-glow-strong: rgba(234, 179, 8, 0.92);
  --stripe-green-1: #34d399;
  --stripe-green-2: #059669;

  /* --- 4. NAV PILL WATER HOVER (CTA polish) --- */
  --lux-water-hover: #e9f6ff;        /* light water blue */
  --lux-water-hover-2: #dff1ff;      /* slightly deeper for active */
  --lux-water-border: rgba(0,120,215,0.28);
  --lux-water-halo: rgba(0,120,215,0.16);
}
</file>

<file path="lux-onboarding.css">
/* features/onboarding/lux-onboarding.css */

/* Scrim */
.lux-onb-overlay {
  position: fixed;
  inset: 0;
  background: rgba(26, 26, 26, 0.65); /* deep charcoal @ 65% */
  z-index: 999; /* adjust if you have a treaty; must sit over app */
  display: grid;
  place-items: center;
  padding: 18px;
}

/* Card */
.lux-onb-card {
  width: min(720px, 100%);
  background: #fff;
  border-radius: 16px;
  box-shadow: 0 22px 60px rgba(0,0,0,0.22);
  overflow: hidden;
  position: relative;
}

/* 4px Lux-blue accent */
.lux-onb-accent {
  height: 4px;
  background: var(--lux-blue-primary, #0078d7);
}

/* Header */
.lux-onb-header {
  display: flex;
  align-items: flex-start;
  justify-content: space-between;
  gap: 12px;
  padding: 18px 20px 10px 20px;
}

.lux-onb-title {
  margin: 0;
  font-size: 26px;
  line-height: 1.15;
  font-weight: 650;
  color: #1f2937; /* dark slate */
}

.lux-onb-skip {
  background: transparent;
  border: none;
  color: rgba(31, 41, 55, 0.55);
  font-size: 14px;
  cursor: pointer;
  padding: 6px 8px;
  border-radius: 10px;
}

.lux-onb-skip:hover,
.lux-onb-skip:focus-visible {
  background: rgba(0,0,0,0.06);
  outline: none;
}

.lux-onb-body {
  padding: 8px 20px 6px 20px;
  color: rgba(31, 41, 55, 0.72);
  font-size: 16px;
  line-height: 1.5;
}

.lux-onb-bullets {
  margin: 10px 0 0 18px;
}

.lux-onb-tip {
  display: inline-flex;
  align-items: center;
  gap: 8px;
  margin-top: 12px;
  padding: 8px 10px;
  border-radius: 999px;
  background: rgba(0, 120, 215, 0.10);
  color: rgba(31, 41, 55, 0.78);
  font-size: 14px;
}

.lux-onb-tip .lux-onb-tip-dot {
  width: 18px;
  height: 18px;
  border-radius: 50%;
  display: grid;
  place-items: center;
  background: rgba(0, 120, 215, 0.18);
  color: rgba(0, 90, 158, 1);
  font-weight: 700;
  font-size: 12px;
}

/* Footer / controls */
.lux-onb-footer {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 12px;
  padding: 14px 20px 18px 20px;
}

.lux-onb-left,
.lux-onb-right {
  display: flex;
  align-items: center;
  gap: 10px;
}

/* Labeled stepper */
.lux-onb-stepper {
  display: grid;
  grid-auto-flow: column;
  gap: 14px;
  align-items: center;
  justify-content: center;
  padding: 0 20px 4px 20px;
}

.lux-onb-step {
  text-align: center;
  min-width: 70px;
}

.lux-onb-dot {
  width: 10px;
  height: 10px;
  border-radius: 999px;
  background: rgba(0,0,0,0.18);
  margin: 0 auto 6px auto;
}

.lux-onb-step.is-active .lux-onb-dot {
  background: var(--lux-blue-primary, #0078d7);
}

.lux-onb-label {
  font-size: 12px;
  color: rgba(31,41,55,0.55);
}

.lux-onb-step.is-active .lux-onb-label {
  color: rgba(31,41,55,0.78);
}

/* Buttons */
.lux-onb-btn {
  border: 1px solid rgba(0,0,0,0.12);
  background: #fff;
  color: #111827;
  border-radius: 12px;
  padding: 10px 12px;
  font-size: 14px;
  cursor: pointer;
}

.lux-onb-btn:hover { background: rgba(0,0,0,0.04); }

.lux-onb-btn-primary {
  border: none;
  background: var(--lux-blue-primary, #0078d7);
  color: #fff;
  padding: 10px 14px;
  font-weight: 650;
}

.lux-onb-btn-primary:hover {
  background: var(--lux-blue-hover, #005a9e);
}

.lux-onb-btn-primary.is-success {
  background: #15803d; /* green */
}

.lux-onb-btn-link {
  border: none;
  background: transparent;
  color: rgba(31,41,55,0.65);
  padding: 8px 8px;
}

.lux-onb-btn-link:hover { background: rgba(0,0,0,0.05); border-radius: 10px; }

/* Mic meter (ghost waveform) */
.lux-onb-meter {
  margin-top: 12px;
  height: 10px;
  border-radius: 999px;
  background: rgba(0,0,0,0.08);
  overflow: hidden;
}

.lux-onb-meter > span {
  display: block;
  height: 100%;
  width: 10%;
  transform-origin: left center;
  background: rgba(0, 120, 215, 0.55);
  transform: scaleX(0.10);
}
</file>

<file path="lux-popover.css">
/* lux-popover.css */
/* ==========================================================================
   Lux DB tracking inline callout + popover (v3)
   – no hover gap
   – popover always above site tooltips (Moved to Modal Tier)
   – high-contrast “Copy” button
   – namespaced with .lux-* to avoid collisions
   ========================================================================== */

/* ── CRITICAL CONTAINER PATCH ───────────────────────────────────────────── */
/* We explicitly lift the parent container (#userMsg) to the Modal Tier.
   This prevents later DOM elements (like the (?) tooltip or dropdowns)
   from "shining through" the popover because they live in a lower layer.
*/
#userMsg {
  position: relative;
  z-index: var(--z-modal) !important; /* Tier 800: Beats standard tooltips (600) */
}

/* ── Trigger chip ───────────────────────────────────────────────────────── */
.lux-cta {
  position: relative; /* anchor for popover */
  display: inline-flex;
  align-items: center;
  gap: 4px;
  padding: 0 4px 2px; /* tiny bottom pad closes any gap */
  border-radius: 6px;
  cursor: help;
  user-select: none;

  /* RESTORED: Stronger pulse ring */
  box-shadow: 0 0 0 0 rgba(37, 99, 235, 0.6);
  animation: luxPulse 2.6s ease-in-out infinite !important;

  /* Added color transition here to replace JS injection later */
  transition: transform 0.12s ease, background-color 0.12s ease, color 0.15s ease;

  /* create own stacking context & sit above ordinary tips */
  isolation: isolate;
  
  /* Ensure the chip itself is also high in the local stack */
  z-index: var(--z-modal); 
}

@media (prefers-reduced-motion: reduce) {
  .lux-cta {
    animation: none !important;
  }
}

.lux-cta:hover,
.lux-cta:focus {
  background: #eef3ff;
  color: #409cff; 
  transform: translateY(-1px) scale(1.02);
  /* Ring persists on hover */
}

.lux-cta:focus-visible {
  outline: 2px solid #2563eb;
  outline-offset: 2px;
}

/* RESTORED: Pulse keyframes (Opacity increased for visibility against blue bg) */
@keyframes luxPulse {
  0% {
    box-shadow: 0 0 0 0 rgba(37, 99, 235, 0.5);
  }
  70% {
    box-shadow: 0 0 0 10px rgba(37, 99, 235, 0);
  }
  100% {
    box-shadow: 0 0 0 0 rgba(37, 99, 235, 0);
  }
}

/* ── Popover panel ──────────────────────────────────────────────────────── */
.lux-pop {
  position: absolute;
  /* eliminate the hover gap (touch the trigger) */
  top: calc(100% - 2px);
  left: -6px;

  min-width: 280px;
  max-width: 360px;
  padding: 10px;

  background: #fff;
  border: 1px solid #e6e6e6;
  border-radius: 12px;
  box-shadow: 0 10px 22px rgba(0, 0, 0, 0.08);

  opacity: 0;
  transform: translateY(6px) scale(0.98);
  pointer-events: none;
  transition: opacity 0.15s ease, transform 0.15s ease;
  will-change: opacity, transform;

  /* decisively above any tooltip bubbles elsewhere */
  z-index: calc(var(--z-modal) + 1); 
}
.lux-cta:hover .lux-pop,
.lux-cta:focus-within .lux-pop,
.lux-cta[aria-expanded="true"] .lux-pop {
  opacity: 1;
  pointer-events: auto;
  transform: translateY(0) scale(1);
}

/* caret */
.lux-pop::before {
  content: "";
  position: absolute;
  top: -6px;
  left: 16px;
  width: 12px;
  height: 12px;
  background: #fff;
  border-left: 1px solid #e6e6e6;
  border-top: 1px solid #e6e6e6;
  transform: rotate(45deg);
}

/* ── Content rows ──────────────────────────────────────────────────────── */
.lux-uidrow {
  display: flex;
  align-items: center;
  gap: 8px;
  margin: 4px 0 10px 0;
  font-size: 13px;
}
.lux-uidrow code {
  background: #f6f7fb;
  padding: 2px 6px;
  border-radius: 6px;
}

/* High-contrast utility button (Copy) — override global button styles */
button.lux-btn {
  background: #e9f1ff;
  color: #183b6b; /* dark ink for readability */
  font-weight: 700;
  border: 1px solid #b8c7ea;
  border-radius: 8px;
  padding: 5px 10px;
  line-height: 1;
  cursor: pointer;
  font-size: 12px;
  transition: background-color 0.12s ease, transform 0.12s ease,
    box-shadow 0.12s ease;
}
button.lux-btn:hover {
  background: #dbe8ff;
  transform: translateY(-1px);
  box-shadow: 0 1px 4px rgba(0, 0, 0, 0.08);
}
button.lux-btn:active {
  transform: translateY(0);
}
button.lux-btn:focus-visible {
  outline: 2px solid #2563eb;
  outline-offset: 2px;
}
button.lux-btn:disabled {
  background: #eef2f7;
  color: #8aa0bb;
  border-color: #d7deea;
}

.lux-copied {
  margin-left: 4px;
  color: #0a7;
  font-size: 12px;
}

/* admin links cluster */
.lux-links {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  margin: 2px 0 6px 0;
}
.lux-links a {
  display: inline-block;
  padding: 4px 8px;
  border: 1px solid #dfe6f5;
  border-radius: 999px;
  background: #f8fbff;
  font-size: 12px;
  text-decoration: none;
  color: inherit;
  transition: background-color 0.12s ease, transform 0.12s ease;
}
.lux-links a:hover {
  background: #eef4ff;
  transform: translateY(-1px);
}

.lux-note {
  display: block;
  color: #666;
  font-size: 11px;
}

/* ── Small-screen tweak ────────────────────────────────────────────────── */
@media (max-width: 520px) {
  .lux-pop {
    min-width: 240px;
    left: -2px;
  }
}

/* Hover video preview for pills */
#hoverPlayer {
  position: fixed;
  bottom: 16px;
  left: 16px;
  width: 320px;
  aspect-ratio: 16/9;
  opacity: 0;
  transition: opacity 0.15s ease;
  border-radius: 12px;
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
  pointer-events: none; /* don't capture the mouse */
  z-index: 9999;
}

/* ── NEW: Body-level tooltip used by prosody bars ──────────────────────── */
.lux-tip {
  position: fixed;
  z-index: calc(var(--z-modal) + 10); /* Keep consistent above modaled popover */
  pointer-events: none; /* mouse goes through */
  background: rgba(0, 0, 0, 0.88);
  color: #fff;
  font: 12px/1.3 system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
  padding: 6px 8px;
  border-radius: 6px;
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.25);
  white-space: nowrap;
  display: none; /* toggled by JS */
}

/* If any old in-cell pseudo-tooltips exist, suppress them */
.prosody-bar[data-tip]::after {
  display: none !important;
}
</file>

<file path="lux-popover.js">
// lux-popover.js
(() => {
  const KEY = "LUX_USER_ID";
  const uid = window.LUX_USER_ID || localStorage.getItem(KEY) || "";

  // Show UID
  const $uid = document.getElementById("lux-uid");
  if ($uid) $uid.textContent = uid || "not found";

  // Copy button
  const $copy = document.getElementById("lux-copy");
  const $copied = document.getElementById("lux-copied");
  if ($copy) {
    $copy.addEventListener("click", async () => {
      try {
        await navigator.clipboard.writeText(uid);
        if ($copied) {
          $copied.textContent = "Copied!";
          setTimeout(() => ($copied.textContent = ""), 1400);
        }
      } catch {
        if ($copied) $copied.textContent = "Copy failed";
      }
    });
  }

  // Build absolute admin links (last 14 days)
  const base = "https://luxury-language-api.vercel.app/admin";
  const passages = "grandfather,rainbow,sentences,wordList";
  const fmt = (d) => d.toISOString().slice(0, 10);
  const to = fmt(new Date());
  const from = fmt(new Date(Date.now() - 14 * 24 * 60 * 60 * 1000));

  const links = {
    "lux-link-progress": `${base}/?uid=${encodeURIComponent(
      uid
    )}&from=${from}&to=${to}&smooth=7&passages=${encodeURIComponent(
      passages
    )}&limit=500`,
    "lux-link-attempts": `${base}/user.html?uid=${encodeURIComponent(
      uid
    )}&from=${from}&to=${to}&passages=${encodeURIComponent(
      passages
    )}&limit=500`,
    "lux-link-cohort": `${base}/overview.html?from=${from}&to=${to}&sort=last&limit=10000&passages=${encodeURIComponent(
      passages
    )}&quick=14`,
  };

  Object.entries(links).forEach(([id, href]) => {
    const a = document.getElementById(id);
    if (!a) return;
    a.href = href;
    a.target = "_blank";
    a.rel = "noopener";
  });

  // Keep aria state tidy (also helps hover/focus behaviour)
  const cta = document.querySelector(".lux-cta");
  if (cta) {
    const set = (v) => cta.setAttribute("aria-expanded", v);
    cta.addEventListener("mouseenter", () => set("true"));
    cta.addEventListener("mouseleave", () => set("false"));
    cta.addEventListener("focusin", () => set("true"));
    cta.addEventListener("focusout", () => set("false"));
  }
})();
/* --- Pill hover preview (muted) + click toggle (sound/pause) --- */
(function () {
  const PILL_SELECTOR = ".pill, .word-pill, .phoneme-pill"; // adjust to your classes
  const CONTAINER = document.body; // event delegation root

  function ensureHoverPlayer() {
    let v = document.getElementById("hoverPlayer");
    if (v) return v;
    v = document.createElement("video");
    v.id = "hoverPlayer";
    v.playsInline = true;
    v.preload = "auto";
    v.muted = true; // previews must start muted
    document.body.appendChild(v); // CSS handles its look/position
    return v;
  }

  function sameSrc(el, src) {
    try {
      return (
        el.currentSrc === new URL(src, location.href).href || el.src === src
      );
    } catch {
      return el.src === src;
    }
  }

  function getPill(e) {
    return e.target && e.target.closest
      ? e.target.closest(PILL_SELECTOR)
      : null;
  }

  function getVideoSrcForPill(pill) {
    // Primary: explicit data attribute
    if (pill?.dataset?.video) return pill.dataset.video;

    // Fallback: derive from text/IPA (optional; change to your path/pattern)
    const kind = pill?.classList?.contains("phoneme") ? "phoneme" : "word";
    const key = (pill.dataset.key || pill.dataset.ipa || pill.textContent || "")
      .trim()
      .toLowerCase()
      .replace(/\s+/g, "-")
      .replace(/[^\w-]/g, "");
    if (!key) return null;
    return `/clips/${kind}-${key}.mp4`; // <-- adjust base path if needed
  }

  document.addEventListener("DOMContentLoaded", () => {
    const player = ensureHoverPlayer();
    let currentPill = null;

    function showFor(pill) {
      const src = getVideoSrcForPill(pill);
      if (!src) return;
      if (!sameSrc(player, src)) {
        player.src = src;
        player.currentTime = 0;
      }
      player.muted = true; // hover preview is ALWAYS muted
      player.play().catch(() => {});
      player.style.opacity = 1;
    }

    function hide() {
      player.pause();
      player.currentTime = 0;
      player.style.opacity = 0;
      // remain muted until a click explicitly unmutes
    }

    // Hover preview: only pills count (not headers/wrappers)
    CONTAINER.addEventListener("mouseover", (e) => {
      const pill = getPill(e);
      if (!pill || pill === currentPill) return;
      currentPill = pill;
      showFor(pill);
    });

    CONTAINER.addEventListener("mouseout", (e) => {
      const from = getPill(e);
      if (!from || from !== currentPill) return;
      const to =
        e.relatedTarget &&
        e.relatedTarget.closest &&
        e.relatedTarget.closest(PILL_SELECTOR);
      if (to === currentPill) return; // still inside same pill
      currentPill = null;
      hide();
    });

    // Click: toggle sound/pause for that pill
    CONTAINER.addEventListener("click", async (e) => {
      const pill = getPill(e);
      if (!pill) return;
      const src = getVideoSrcForPill(pill);
      if (!src) return;

      if (!sameSrc(player, src)) {
        // Clicking a different pill: switch, unmute, and play
        player.src = src;
        player.currentTime = 0;
        player.muted = false;
        try {
          await player.play();
          player.style.opacity = 1;
        } catch {}
        return;
      }

      // Same pill:
      if (player.paused) {
        player.muted = false;
        try {
          await player.play();
          player.style.opacity = 1;
        } catch {}
      } else if (player.muted) {
        player.muted = false;
        try {
          await player.play();
        } catch {}
      } else {
        player.pause(); // second click pauses
      }
    });

    // A11y parity for keyboard users
    CONTAINER.addEventListener("focusin", (e) => {
      const pill = getPill(e);
      if (!pill) return;
      currentPill = pill;
      showFor(pill);
    });
    CONTAINER.addEventListener("focusout", (e) => {
      const pill = getPill(e);
      if (!pill) return;
      if (
        document.activeElement &&
        document.activeElement.closest(PILL_SELECTOR) === pill
      )
        return;
      currentPill = null;
      hide();
    });
    CONTAINER.addEventListener("keydown", (e) => {
      if (e.key !== "Enter" && e.key !== " ") return;
      const pill = getPill(e);
      if (!pill) return;
      e.preventDefault();
      pill.click(); // reuse click logic
    });
  });
})();
</file>

<file path="package.json">
{
  "name": "lux-pronunciation-tool",
  "version": "1.6.9",
  "description": "Lux Pronunciation Tool with Vite",
  "main": "index.html",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "thumbs": "node scripts/make-thumbs.mjs",
    "lux:snapshot": "powershell -ExecutionPolicy Bypass -File scripts/lux-snapshot.ps1",
    "lux:release": "powershell -ExecutionPolicy Bypass -File scripts/lux-release.ps1"
  },
  "keywords": [
    "pronunciation",
    "learning",
    "app"
  ],
  "author": "Mark",
  "license": "MIT",
  "devDependencies": {
    "serve": "11.2.0",
    "sharp": "^0.34.5",
    "vite": "^6.0.0"
  },
  "dependencies": {
    "@supabase/supabase-js": "^2.87.1"
  }
}
</file>

<file path="progress.html">
<!-- progress.html (User Progress) -->
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Lux — My Progress</title>

    <link rel="stylesheet" href="lux-layout.css" />
    <link rel="stylesheet" href="lux-results.css" />
    <link rel="stylesheet" href="lux-progress.css" />

    <!-- Optional: warp nav styling if you want it later -->
    <link rel="stylesheet" href="./ui/warp.css" />
  </head>
  <body>
    <div class="lux-container" id="container">
      <div class="lux-header">
        <h2>My Progress</h2>
        <div class="lux-toplinks">
<a class="lux-toplink lux-navpill" href="./index.html" data-lux-ripple>
  Practice Skills
</a>

<a class="lux-toplink lux-toplink-cta lux-cta-same" href="./convo.html">AI Conversations</a>

        </div>
      </div>

      <div id="dashboard-root"></div>
    </div>

    <script type="module" src="./src/progress.js"></script>
    <script type="module" src="./ui/warp-nav.js"></script>
  </body>
</html>
</file>

<file path="prosody/annotate.js">
// prosody/annotate.js
// Per-word tempo/gap classifiers + dev audit

import { ticksToSec, computeTimings, median } from "./core-calc.js";

export function classifyTempo(durationSec, medianDur) {
  if (!Number.isFinite(durationSec)) return "ok";
  if (Number.isFinite(medianDur) && medianDur > 0) {
    if (durationSec >= medianDur * 1.45) return "slow";
    if (durationSec <= medianDur * 0.6) return "fast";
    return "ok";
  }
  if (durationSec > 0.65) return "slow";
  if (durationSec < 0.3) return "fast";
  return "ok";
}

export function classifyGap(prevEnd, currStart) {
  var pe = ticksToSec(prevEnd) ?? (prevEnd == null ? null : Number(prevEnd));
  var cs = ticksToSec(currStart) ?? (currStart == null ? null : Number(currStart));
  
  if (!Number.isFinite(pe) || !Number.isFinite(cs)) return "ok";
  var gap = cs - pe;
  if (!Number.isFinite(gap) || gap < 0) return "ok";
  if (gap > 0.6) return "unexpected";
  if (gap >= 0.35) return "missing";
  return "ok";
}

export function devAuditProsody(data, limit) {
  limit = Number.isFinite(limit) ? limit : 10;
  var words = data?.NBest?.[0]?.Words || [];
  var timings = computeTimings(words);
  var med = median(
    timings
      .map(function (t) {
        return t.durationSec;
      })
      .filter(Number.isFinite)
  );
  var rows = [];
  var lastEnd = null;
  for (var i = 0; i < Math.min(words.length, limit); i++) {
    var w = words[i] || {};
    var t = timings[i] || {};
    var gap =
      Number.isFinite(lastEnd) && Number.isFinite(t.start)
        ? +(t.start - lastEnd).toFixed(3)
        : null;
    rows.push({
      i,
      word: w.Word,
      rawOffset: w.Offset,
      rawDuration: w.Duration,
      startSec: t.start,
      durSec: t.durationSec,
      endSec: t.end,
      gapSec: gap,
      tempo: classifyTempo(t.durationSec, med),
      gapClass:
        i > 0 && Number.isFinite(gap)
          ? gap > 0.6
            ? "unexpected"
            : gap >= 0.35
            ? "missing"
            : "ok"
          : "n/a",
    });
    lastEnd = t.end;
  }
  console.table(rows);
  var hugeGaps = rows.filter(function (r) {
    return r.gapSec != null && r.gapSec > 5;
  });
  if (hugeGaps.length) {
    console.warn(
      "⚠️ Suspiciously large gaps (>5s). This usually means a unit mismatch (ms vs ticks vs s) in Offset/Duration:",
      hugeGaps
    );
  }
  return rows;
}
</file>

<file path="prosody/prosody-help-bars.js">
// prosody/prosody-help-bars.js
// Helpers for prosody ribbons + a body-level tooltip.

let isInstalled = false;

export function initProsodyTooltips() {
  if (isInstalled) return;
  isInstalled = true;

  if (typeof document === "undefined") return;

  const tip = document.createElement("div");
  tip.className = "lux-tip"; // styled in lux-popover.css
  tip.style.display = "none";
  document.body.appendChild(tip);

  let currentEl = null;
  const PAD = 8;

  function coerceElement(n) {
    if (!n) return null;
    if (n.nodeType === 1) return n;
    return n.parentElement || null;
  }

  function getBarFromEventTarget(target) {
    const el = coerceElement(target);
    if (!el || typeof el.closest !== "function") return null;
    return el.closest(".prosody-bar");
  }

  function showFor(el, clientX, clientY) {
    if (!el) return;
    const txt =
      el.dataset.tip ||
      el.getAttribute("aria-label") ||
      el.getAttribute("title") ||
      "";
    if (!txt) return;

    tip.textContent = txt;
    tip.style.display = "block";

    requestAnimationFrame(() => {
      const r = tip.getBoundingClientRect();
      let x = Math.max(
        PAD,
        Math.min(clientX + 12, window.innerWidth - r.width - PAD)
      );
      let y = clientY - r.height - 14;
      if (y < PAD) y = clientY + 16;
      tip.style.left = x + "px";
      tip.style.top = y + "px";
    });
  }

  function hide() {
    tip.style.display = "none";
    currentEl = null;
  }

  document.addEventListener(
    "mouseover",
    (e) => {
      const el = getBarFromEventTarget(e.target);
      if (!el) return;
      currentEl = el;
      showFor(el, e.clientX, e.clientY);
    },
    true
  );

  document.addEventListener(
    "mousemove",
    (e) => {
      if (!currentEl) return;
      const over = document.elementFromPoint(e.clientX, e.clientY);
      const stillOnBar = over && getBarFromEventTarget(over);
      if (!stillOnBar) {
        hide();
        return;
      }
      showFor(currentEl, e.clientX, e.clientY);
    },
    true
  );

  document.addEventListener(
    "mouseout",
    (e) => {
      const from = getBarFromEventTarget(e.target);
      const to = getBarFromEventTarget(e.relatedTarget);
      if (from && !to) hide();
    },
    true
  );

  window.addEventListener("scroll", hide, { passive: true });
  window.addEventListener("blur", hide);
  
  console.log("[LUX] Prosody tooltips initialized");
}
</file>

<file path="prosody/prosody-render-bars.js">
// prosody/prosody-render-bars.js
// Renders the two-bar prosody ribbon.

import { classifyTempo, classifyGap } from "./annotate.js";

/**
 * @param {number} index     word index in timings
 * @param {Array}  words     (kept for signature parity)
 * @param {Array}  timings   [{ start, end, durationSec }, ...]
 * @param {number} medianDur median word duration (seconds)
 * @returns {string} HTML string
 */
export function renderProsodyRibbon(index, words, timings, medianDur) {
  const t = (timings && timings[index]) || {};
  const prev = (timings && timings[index - 1]) || {};

  const tempo = classifyTempo(t.durationSec, medianDur);
  const gapVal =
    Number.isFinite(prev.end) && Number.isFinite(t.start)
      ? t.start - prev.end
      : null;
  const gapCls = index > 0 ? classifyGap(prev.end, t.start) : "ok";

  // Width scaling (elongated, readable bars)
  const baselineTempo = Number.isFinite(medianDur) ? medianDur : 0.45;
  const tempoRatio = Number.isFinite(t.durationSec)
    ? t.durationSec / baselineTempo
    : 1;
  const tempoW = Math.min(150, Math.max(16, Math.round(110 * tempoRatio)));

  const baselineGap = 0.35;
  const gapRatio = Number.isFinite(gapVal) ? gapVal / baselineGap : 1;
  const gapW = Math.min(160, Math.max(10, Math.round(100 * gapRatio)));

  // Tooltip strings
  const gapTitle = Number.isFinite(gapVal)
    ? `Pause before word: ${gapVal.toFixed(2)}s (${gapCls})`
    : "Pause before word: —";
  const tempoTitle = Number.isFinite(t.durationSec)
    ? `Word length: ${t.durationSec.toFixed(2)}s (${tempo})`
    : "Word length: —";

  const esc = (s) => String(s).replace(/"/g, "&quot;");

  return (
    '<div class="prosody-ribbon" role="img" aria-label="' +
    esc(gapTitle + "; " + tempoTitle) +
    '">' +
    // Gap (pause-before-word)
    '<span class="prosody-bar pr-seg pr-gap ' +
    gapCls +
    '" style="width:' +
    gapW +
    'px" data-tip="' +
    esc(gapTitle) +
    '" aria-label="' +
    esc(gapTitle) +
    '"></span>' +
    // Word length (tempo)
    '<span class="prosody-bar pr-seg pr-tempo ' +
    tempo +
    '" style="width:' +
    tempoW +
    'px" data-tip="' +
    esc(tempoTitle) +
    '" aria-label="' +
    esc(tempoTitle) +
    '"></span>' +
    "</div>"
  );
}
</file>

<file path="README.md">
# lux-back3-phonemes-fixed-2025-11-21
Created with CodeSandbox
</file>

<file path="scripts/lux-release.ps1">
param(
  [string]$Message = ""  # Optional: manual commit summary override
)

# --- CONFIGURATION ---
$DesktopPath  = [Environment]::GetFolderPath("Desktop")
$TargetFolder = Join-Path $DesktopPath "PRONUNCIATION_TOOL_BACKUPS"
$Timestamp    = Get-Date -Format "yyyyMMdd-HHmm"
$ZipName      = "lux-release-$Timestamp.zip"
$FinalZipPath = Join-Path $TargetFolder $ZipName

Write-Host ">>> Starting Lux Release..." -ForegroundColor Cyan

# Ensure the desktop backup folder exists
if (!(Test-Path $TargetFolder)) {
  New-Item -ItemType Directory -Path $TargetFolder | Out-Null
  Write-Host ">>> Created new backup folder at: $TargetFolder" -ForegroundColor Yellow
}

# --- 1) STAGE ---
git add -A | Out-Null

# --- 2) BUILD AUTO COMMIT MESSAGE (from STAGED changes) ---
$stagedStatus = (git diff --cached --name-status) 2>$null
$stagedFiles  = (git diff --cached --name-only) 2>$null

function Get-Category([string]$path) {
  if ($path -match '^features/interactions/') { return 'interactions' }
  if ($path -match '^features/results/')      { return 'results' }
  if ($path -match '^features/passages/')     { return 'passages' }
  if ($path -match '^features/features/')     { return 'features' }
  if ($path -match '^ui/')                    { return 'ui' }
  if ($path -match '^src/')                   { return 'src' }
  if ($path -match '^styles?/')               { return 'styles' }
  if ($path -match '^index\.html$')           { return 'index.html' }
  return 'misc'
}

function New-AutoMessage([string[]]$files, [string[]]$statusLines, [string]$stamp) {
  $cats = @()
  foreach ($f in $files) { if ($f) { $cats += (Get-Category $f) } }

  $catSummary = ($cats | Sort-Object -Unique) -join ", "
  if ([string]::IsNullOrWhiteSpace($catSummary)) { $catSummary = "misc" }

  $count = ($files | Where-Object { $_ } | Measure-Object).Count

  # IMPORTANT: use ${} because PowerShell treats "$var:" specially
  $summary = "Lux release ${stamp}: ${catSummary} (${count} files)"

  $bodyLines = @(
    "Changed files:",
    ""
  ) + ($statusLines | Where-Object { $_ } | ForEach-Object { " - $_" })

  return @{
    Summary = $summary
    Body    = ($bodyLines -join "`n")
  }
}

# --- 3) COMMIT (only if there are staged changes) ---
if ($stagedStatus -and $stagedStatus.Trim().Length -gt 0) {
  Write-Host ">>> Changes detected. Committing..." -ForegroundColor Yellow

  if ([string]::IsNullOrWhiteSpace($Message)) {
    $auto = New-AutoMessage -files $stagedFiles -statusLines $stagedStatus -stamp $Timestamp
    $commitSummary = $auto.Summary
    $commitBody    = $auto.Body
  } else {
    $commitSummary = "Lux release ${Timestamp}: ${Message}"
    $commitBody    = "Changed files:`n" + (($stagedStatus | ForEach-Object { " - $_" }) -join "`n")
  }

  git commit -m $commitSummary -m $commitBody | Out-Null
  Write-Host ">>> Commit: $commitSummary" -ForegroundColor Green
} else {
  Write-Host ">>> No staged changes to commit. Proceeding to tag + zip..." -ForegroundColor DarkGray
}

# --- 4) TAG (annotated; avoid collisions) ---
$baseTag = "build-$Timestamp"
$TagName = $baseTag
$i = 1

while (git rev-parse -q --verify "refs/tags/$TagName" 2>$null) {
  $TagName = "${baseTag}-$i"
  $i++
}

git tag -a $TagName -m "Lux Release $Timestamp" | Out-Null
Write-Host ">>> Tagged HEAD as $TagName" -ForegroundColor Green

# --- 5) ARCHIVE (clean source zip from HEAD) ---
Write-Host ">>> Archiving clean source code..." -ForegroundColor Yellow

try {
  git archive --format=zip --output "$FinalZipPath" HEAD
} catch {
  Write-Error "Failed to create git archive. Make sure git is in your PATH."
  exit 1
}

# --- 6) VERIFICATION ---
if (Test-Path $FinalZipPath) {
  $SizeKB = "{0:N2}" -f ((Get-Item $FinalZipPath).Length / 1KB)
  Write-Host ""
  Write-Host "SUCCESS!" -ForegroundColor Green
  Write-Host "File saved to: $FinalZipPath" -ForegroundColor White
  Write-Host "Clean Size:    $SizeKB KB" -ForegroundColor Cyan
} else {
  Write-Error "Something went wrong. The zip file was not created."
}
</file>

<file path="scripts/lux-snapshot.ps1">
param(
  [string]$BackupDir = "$env:USERPROFILE\OneDrive\Desktop\PRONUNCIATION_TOOL_BACKUPS"
)

if (!(Test-Path $BackupDir)) { New-Item -ItemType Directory -Path $BackupDir | Out-Null }

$RepoRoot = git rev-parse --show-toplevel
Set-Location $RepoRoot

$sha = (git rev-parse --short HEAD).Trim()
$stamp = Get-Date -Format "yyyyMMdd-HHmm"
$zipName = "lux-$stamp-$sha.zip"
$zipPath = Join-Path $BackupDir $zipName

$items = Get-ChildItem -Path $RepoRoot -Force | Where-Object { $_.Name -ne ".git" }
Compress-Archive -Path $items.FullName -DestinationPath $zipPath -Force

Write-Host "Snapshot saved to $zipPath"
</file>

<file path="scripts/make-thumbs.mjs">
import fs from "node:fs";
import path from "node:path";
import sharp from "sharp";

const ROOT = process.cwd();
const SRC_DIR = path.join(ROOT, "public", "convo-img");
const OUT_DIR = path.join(SRC_DIR, "thumbs");

// Thumb tuning
const MAX_W = 280;     // 200–320 ideal
const QUALITY = 60;    // 50–70 typical
const EFFORT = 4;

const OK_EXT = new Set([".webp", ".jpg", ".jpeg", ".png"]);

function walk(dir) {
  const out = [];
  for (const entry of fs.readdirSync(dir, { withFileTypes: true })) {
    const p = path.join(dir, entry.name);
    if (entry.isDirectory()) out.push(...walk(p));
    else out.push(p);
  }
  return out;
}

function isThumbPath(p) {
  return p.includes(`${path.sep}thumbs${path.sep}`);
}

function outThumbPath(inPath) {
  // Preserve relative folder structure, but always output .webp
  const rel = path.relative(SRC_DIR, inPath);
  const parsed = path.parse(rel); // { dir, name, ext }
  return path.join(OUT_DIR, parsed.dir, `${parsed.name}.webp`);
}

if (!fs.existsSync(SRC_DIR)) {
  console.error(`[thumbs] missing folder: ${SRC_DIR}`);
  process.exit(1);
}

fs.mkdirSync(OUT_DIR, { recursive: true });

const files = walk(SRC_DIR)
  .filter((p) => !isThumbPath(p))
  .filter((p) => OK_EXT.has(path.extname(p).toLowerCase()));

let made = 0;

for (const inPath of files) {
  const outPath = outThumbPath(inPath);

  fs.mkdirSync(path.dirname(outPath), { recursive: true });

  // Skip if output exists and is newer/equal
  if (fs.existsSync(outPath)) {
    const inStat = fs.statSync(inPath);
    const outStat = fs.statSync(outPath);
    if (outStat.mtimeMs >= inStat.mtimeMs) continue;
  }

  await sharp(inPath)
    .resize({ width: MAX_W, withoutEnlargement: true })
    .webp({ quality: QUALITY, effort: EFFORT })
    .toFile(outPath);

  made++;
}

console.log(`[thumbs] done. generated/updated: ${made}`);
console.log(`[thumbs] output dir: ${OUT_DIR}`);
</file>

<file path="src/api/index.js">
export * from "../../api/index.js";
</file>

<file path="src/api/util.js">
export * from "../../api/util.js";
</file>

<file path="src/convo.js">
// src/convo.js
import { ensureUID } from "../api/identity.js";

import { bootConvo } from "../features/convo/index.js";
import { initAudioSink } from "../app-core/audio-sink.js";
import { bootTTS } from "../features/features/tts/boot-tts.js";
import { initConvoProgress } from "../features/convo/progress.js";
import { initAuthUI } from "../ui/auth-dom.js";
import { bootRippleButtons } from "../ui/ui-ripple-filter.js";

// 0. Initialize UID (single source of truth)
ensureUID();

// 1. Initialize the global audio handler
initAudioSink();

// 2. Load the sliding "peekaboo" logic
// This script looks for the #playbackAudio element we added to HTML
import "../features/features/08-selfpb-peekaboo.js";

// 3. Boot TTS
// This looks for #tts-controls and attaches the highlight-to-speak logic
bootTTS();

// 4. Boot Save Progress / Login button (top-right)
initAuthUI();

// 5. Start the AI Conversation app
bootConvo();
initConvoProgress();

// 6. Boot ripple buttons (safe here: script loads at end of body)
bootRippleButtons();
</file>

<file path="src/data/harvard-lists.js">
// src/data/harvard-lists.js
// Harvard Sentences (Phonetically Balanced)
// 72 lists × 10 sentences each

export const harvardList01Parts = [
  "The birch canoe slid on the smooth planks.",
  "Glue the sheet to the dark blue background.",
  "It's easy to tell the depth of a well.",
  "These days a chicken leg is a rare dish.",
  "Rice is often served in round bowls.",
  "The juice of lemons makes fine punch.",
  "The box was thrown beside the parked truck.",
  "The hogs were fed chopped corn and garbage.",
  "Four hours of steady work faced us.",
  "A large size in stockings is hard to sell.",
];

export const harvardList02Parts = [
  "The boy was there when the sun rose.",
  "A rod is used to catch pink salmon.",
  "The source of the huge river is the clear spring.",
  "Kick the ball straight and follow through.",
  "Help the woman get back to her feet.",
  "A pot of tea helps to pass the evening.",
  "Smoky fires lack flame and heat.",
  "The soft cushion broke the man's fall.",
  "The salt breeze came across from the sea.",
  "The girl at the booth sold fifty bonds.",
];

export const harvardList03Parts = [
  "The small pup gnawed a hole in the sock.",
  "The fish twisted and turned on the bent hook.",
  "Press the pants and sew a button on the vest.",
  "The swan dive was far short of perfect.",
  "The beauty of the view stunned the young boy.",
  "Two blue fish swam in the tank.",
  "Her purse was full of useless trash.",
  "The colt reared and threw the tall rider.",
  "It snowed, rained, and hailed the same morning.",
  "Read verse out loud for pleasure.",
];

export const harvardList04Parts = [
  "Hoist the load to your left shoulder.",
  "Take the winding path to reach the lake.",
  "Note closely the size of the gas tank.",
  "Wipe the grease off his dirty face.",
  "Mend the coat before you go out.",
  "The wrist was badly strained and hung limp.",
  "The stray cat gave birth to kittens.",
  "The young girl gave no clear response.",
  "The meal was cooked before the bell rang.",
  "What joy there is in living.",
];

export const harvardList05Parts = [
  "A king ruled the state in the early days.",
  "The ship was torn apart on the sharp reef.",
  "Sickness kept him home the third week.",
  "The wide road shimmered in the hot sun.",
  "The lazy cow lay in the cool grass.",
  "Lift the square stone over the fence.",
  "The rope will bind the seven books at once.",
  "Hop over the fence and plunge in.",
  "The friendly gang left the drug store.",
  "Mesh wire keeps chicks inside.",
];

export const harvardList06Parts = [
  "The frosty air passed through the coat.",
  "The crooked maze failed to fool the mouse.",
  "Adding fast leads to wrong sums.",
  "The show was a flop from the very start.",
  "A saw is a tool used for making boards.",
  "The wagon moved on well oiled wheels.",
  "March the soldiers past the next hill.",
  "A cup of sugar makes sweet fudge.",
  "Place a rosebush near the porch steps.",
  "Both lost their lives in the raging storm.",
];

export const harvardList07Parts = [
  "We talked of the side show in the circus.",
  "Use a pencil to write the first draft.",
  "He ran half way to the hardware store.",
  "The clock struck to mark the third period.",
  "A small creek cut across the field.",
  "Cars and busses stalled in snow drifts.",
  "The set of china hit the floor with a crash.",
  "This is a grand season for hikes on the road.",
  "The dune rose from the edge of the water.",
  "Those words were the cue for the actor to leave.",
];

export const harvardList08Parts = [
  "A yacht slid around the point into the bay.",
  "The two met while playing on the sand.",
  "The ink stain dried on the finished page.",
  "The walled town was seized without a fight.",
  "The lease ran out in sixteen weeks.",
  "A tame squirrel makes a nice pet.",
  "The horn of the car woke the sleeping cop.",
  "The heart beat strongly and with firm strokes.",
  "The pearl was worn in a thin silver ring.",
  "The fruit peel was cut in thick slices.",
];

export const harvardList09Parts = [
  "The Navy attacked the big task force.",
  "See the cat glaring at the scared mouse.",
  "There are more than two factors here.",
  "The hat brim was wide and too droopy.",
  "The lawyer tried to lose his case.",
  "The grass curled around the fence post.",
  "Cut the pie into large parts.",
  "Men strive but seldom get rich.",
  "Always close the barn door tight.",
  "He lay prone and hardly moved a limb.",
];

export const harvardList10Parts = [
  "The slush lay deep along the street.",
  "A wisp of cloud hung in the blue air.",
  "A pound of sugar costs more than eggs.",
  "The fin was sharp and cut the clear water.",
  "The play seems dull and quite stupid.",
  "Bail the boat to stop it from sinking.",
  "The term ended in late June that year.",
  "A tusk is used to make costly gifts.",
  "Ten pins were set in order.",
  "The bill was paid every third week.",
];

export const harvardList11Parts = [
  "Oak is strong and also gives shade.",
  "Cats and dogs each hate the other.",
  "The pipe began to rust while new.",
  "Open the crate but don't break the glass.",
  "Add the sum to the product of these three.",
  "Thieves who rob friends deserve jail.",
  "The ripe taste of cheese improves with age.",
  "Act on these orders with great speed.",
  "The hog crawled under the high fence.",
  "Move the vat over the hot fire.",
];

export const harvardList12Parts = [
  "The bark of the pine tree was shiny and dark.",
  "Leaves turn brown and yellow in the fall.",
  "The pennant waved when the wind blew.",
  "Split the log with a quick, sharp blow.",
  "Burn peat after the logs give out.",
  "He ordered peach pie with ice cream.",
  "Weave the carpet on the right hand side.",
  "Hemp is a weed found in parts of the tropics.",
  "A lame back kept his score low.",
  "We find joy in the simplest things.",
];

export const harvardList13Parts = [
  "Type out three lists of orders.",
  "The harder he tried the less he got done.",
  "The boss ran the show with a watchful eye.",
  "The cup cracked and spilled its contents.",
  "Paste can cleanse the most dirty brass.",
  "The slang word for raw whiskey is booze.",
  "It caught its hind paw in a rusty trap.",
  "The wharf could be seen at the farther shore.",
  "Feel the heat of the weak dying flame.",
  "The tiny girl took off her hat.",
];

export const harvardList14Parts = [
  "A cramp is no small danger on a swim.",
  "He said the same phrase thirty times.",
  "Pluck the bright rose without leaves.",
  "Two plus seven is less than ten.",
  "The glow deepened in the eyes of the sweet girl.",
  "Bring your problems to the wise chief.",
  "Write a fond note to the friend you cherish.",
  "Clothes and lodging are free to new men.",
  "We frown when events take a bad turn.",
  "Port is a strong wine with a smoky taste.",
];

export const harvardList15Parts = [
  "The young kid jumped the rusty gate.",
  "Guess the results from the first scores.",
  "A salt pickle tastes fine with ham.",
  "The just claim got the right verdict.",
  "These thistles bend in a high wind.",
  "Pure bred poodles have curls.",
  "The tree top waved in a graceful way.",
  "The spot on the blotter was made by green ink.",
  "Mud was spattered on the front of his white shirt.",
  "The cigar burned a hole in the desk top.",
];

export const harvardList16Parts = [
  "The empty flask stood on the tin tray.",
  "A speedy man can beat this track mark.",
  "He broke a new shoelace that day.",
  "The coffee stand is too high for the couch.",
  "The urge to write short stories is rare.",
  "The pencils have all been used.",
  "The pirates seized the crew of the lost ship.",
  "We tried to replace the coin but failed.",
  "She sewed the torn coat quite neatly.",
  "The sofa cushion is red and of light weight.",
];

export const harvardList17Parts = [
  "The jacket hung on the back of the wide chair.",
  "At that high level the air is pure.",
  "Drop the two when you add the figures.",
  "A filing case is now hard to buy.",
  "An abrupt start does not win the prize.",
  "Wood is best for making toys and blocks.",
  "The office paint was a dull, sad tan.",
  "He knew the skill of the great young actress.",
  "A rag will soak up spilled water.",
  "A shower of dirt fell from the hot pipes.",
];

export const harvardList18Parts = [
  "Steam hissed from the broken valve.",
  "The child almost hurt the small dog.",
  "There was a sound of dry leaves outside.",
  "The sky that morning was clear and bright blue.",
  "Torn scraps littered the stone floor.",
  "Sunday is the best part of the week.",
  "The doctor cured him with these pills.",
  "The new girl was fired today at noon.",
  "They felt gay when the ship arrived in port.",
  "Add the store's account to the last cent.",
];

export const harvardList19Parts = [
  "Acid burns holes in wool cloth.",
  "Fairy tales should be fun to write.",
  "Eight miles of woodland burned to waste.",
  "The third act was dull and tired the players.",
  "A young child should not suffer fright.",
  "Add the column and put the sum here.",
  "We admire and love a good cook.",
  "There the flood mark is ten inches.",
  "He carved a head from the round block of marble.",
  "She has a smart way of wearing clothes.",
];

export const harvardList20Parts = [
  "The fruit of a fig tree is apple-shaped.",
  "Corn cobs can be used to kindle a fire.",
  "Where were they when the noise started.",
  "The paper box is full of thumb tacks.",
  "Sell your gift to a buyer at a good gain.",
  "The tongs lay beside the ice pail.",
  "The petals fall with the next puff of wind.",
  "Bring your best compass to the third class.",
  "They could laugh although they were sad.",
  "Farmers came in to thresh the oat crop.",
];

export const harvardList21Parts = [
  "The brown house was on fire to the attic.",
  "The lure is used to catch trout and flounder.",
  "Float the soap on top of the bath water.",
  "A blue crane is a tall wading bird.",
  "A fresh start will work such wonders.",
  "The club rented the rink for the fifth night.",
  "After the dance, they went straight home.",
  "The hostess taught the new maid to serve.",
  "He wrote his last novel there at the inn.",
  "Even the worst will beat his low score.",
];

export const harvardList22Parts = [
  "The cement had dried when he moved it.",
  "The loss of the second ship was hard to take.",
  "The fly made its way along the wall.",
  "Do that with a wooden stick.",
  "Live wires should be kept covered.",
  "The large house had hot water taps.",
  "It is hard to erase blue or red ink.",
  "Write at once or you may forget it.",
  "The doorknob was made of bright clean brass.",
  "The wreck occurred by the bank on Main Street.",
];

export const harvardList23Parts = [
  "A pencil with black lead writes best.",
  "Coax a young calf to drink from a bucket.",
  "Schools for ladies teach charm and grace.",
  "The lamp shone with a steady green flame.",
  "They took the axe and the saw to the forest.",
  "The ancient coin was quite dull and worn.",
  "The shaky barn fell with a loud crash.",
  "Jazz and swing fans like fast music.",
  "Rake the rubbish up and then burn it.",
  "Slash the gold cloth into fine ribbons.",
];

export const harvardList24Parts = [
  "Try to have the court decide the case.",
  "They are pushed back each time they attack.",
  "He broke his ties with groups of former friends.",
  "They floated on the raft to sun their white backs.",
  "The map had an X that meant nothing.",
  "Whitings are small fish caught in nets.",
  "Some ads serve to cheat buyers.",
  "Jerk the rope and the bell rings weakly.",
  "A waxed floor makes us lose balance.",
  "Madam, this is the best brand of corn.",
];

export const harvardList25Parts = [
  "On the islands the sea breeze is soft and mild.",
  "The play began as soon as we sat down.",
  "This will lead the world to more sound and fury.",
  "Add salt before you fry the egg.",
  "The rush for funds reached its peak Tuesday.",
  "The birch looked stark white and lonesome.",
  "The box is held by a bright red snapper.",
  "To make pure ice, you freeze water.",
  "The first worm gets snapped early.",
  "Jump the fence and hurry up the bank.",
];

export const harvardList26Parts = [
  "Yell and clap as the curtain slides back.",
  "They are men who walk the middle of the road.",
  "Both brothers wear the same size.",
  "In some form or other we need fun.",
  "The prince ordered his head chopped off.",
  "The houses are built of red clay bricks.",
  "Ducks fly north but lack a compass.",
  "Fruit flavors are used in fizz drinks.",
  "These pills do less good than others.",
  "Canned pears lack full flavor.",
];

export const harvardList27Parts = [
  "The dark pot hung in the front closet.",
  "Carry the pail to the wall and spill it there.",
  "The train brought our hero to the big town.",
  "We are sure that one war is enough.",
  "Gray paint stretched for miles around.",
  "The rude laugh filled the empty room.",
  "High seats are best for football fans.",
  "Tea served from the brown jug is tasty.",
  "A dash of pepper spoils beef stew.",
  "A zestful food is the hot-cross bun.",
];

export const harvardList28Parts = [
  "The horse trotted around the field at a brisk pace.",
  "Find the twin who stole the pearl necklace.",
  "Cut the cord that binds the box tightly.",
  "The red tape bound the smuggled food.",
  "Look in the corner to find the tan shirt.",
  "The cold drizzle will halt the bond drive.",
  "Nine men were hired to dig the ruins.",
  "The junk yard had a mouldy smell.",
  "The flint sputtered and lit a pine torch.",
  "Soak the cloth and drown the sharp odor.",
];

export const harvardList29Parts = [
  "The shelves were bare of both jam or crackers.",
  "A joy to every child is the swan boat.",
  "All sat frozen and watched the screen.",
  "A cloud of dust stung his tender eyes.",
  "To reach the end he needs much courage.",
  "Shape the clay gently into block form.",
  "A ridge on a smooth surface is a bump or flaw.",
  "Hedge apples may stain your hands green.",
  "Quench your thirst, then eat the crackers.",
  "Tight curls get limp on rainy days.",
];

export const harvardList30Parts = [
  "The mute muffled the high tones of the horn.",
  "The gold ring fits only a pierced ear.",
  "The old pan was covered with hard fudge.",
  "Watch the log float in the wide river.",
  "The node on the stalk of wheat grew daily.",
  "The heap of fallen leaves was set on fire.",
  "Write fast if you want to finish early.",
  "His shirt was clean but one button was gone.",
  "The barrel of beer was a brew of malt and hops.",
  "Tin cans are absent from store shelves.",
];

export const harvardList31Parts = [
  "Slide the box into that empty space.",
  "The plant grew large and green in the window.",
  "The beam dropped down on the workmen's head.",
  "Pink clouds floated with the breeze.",
  "She danced like a swan, tall and graceful.",
  "The tube was blown and the tire flat and useless.",
  "It is late morning on the old wall clock.",
  "Let's all join as we sing the last chorus.",
  "The last switch cannot be turned off.",
  "The fight will end in just six minutes.",
];

export const harvardList32Parts = [
  "The store walls were lined with colored frocks.",
  "The peace league met to discuss their plans.",
  "The rise to fame of a person takes luck.",
  "Paper is scarce, so write with much care.",
  "The quick fox jumped on the sleeping cat.",
  "The nozzle of the fire hose was bright brass.",
  "Screw the round cap on as tight as needed.",
  "Time brings us many changes.",
  "The purple tie was ten years old.",
  "Men think and plan and sometimes act.",
];

export const harvardList33Parts = [
  "Fill the ink jar with sticky glue.",
  "He smoke a big pipe with strong contents.",
  "We need grain to keep our mules healthy.",
  "Pack the records in a neat thin case.",
  "The crunch of feet in the snow was the only sound.",
  "The copper bowl shone in the sun's rays.",
  "Boards will warp unless kept dry.",
  "The plush chair leaned against the wall.",
  "Glass will clink when struck by metal.",
  "Bathe and relax in the cool green grass.",
];

export const harvardList34Parts = [
  "Nine rows of soldiers stood in line.",
  "The beach is dry and shallow at low tide.",
  "The idea is to sew both edges straight.",
  "The kitten chased the dog down the street.",
  "Pages bound in cloth make a book.",
  "Try to trace the fine lines of the painting.",
  "Women form less than half of the group.",
  "The zones merge in the central part of town.",
  "A gem in the rough needs work to polish.",
  "Code is used when secrets are sent.",
];

export const harvardList35Parts = [
  "Most of the news is easy for us to hear.",
  "He used the lathe to make brass objects.",
  "The vane on top of the pole revolved in the wind.",
  "Mince pie is a dish served to children.",
  "The clan gathered on each dull night.",
  "Let it burn, it gives us warmth and comfort.",
  "A castle built from sand fails to endure.",
  "A child's wit saved the day for us.",
  "Tack the strip of carpet to the worn floor.",
  "Next Tuesday we must vote.",
];

export const harvardList36Parts = [
  "Pour the stew from the pot into the plate.",
  "Each penny shone like new.",
  "The man went to the woods to gather sticks.",
  "The dirt piles were lines along the road.",
  "The logs fell and tumbled into the clear stream.",
  "Just hoist it up and take it away.",
  "A ripe plum is fit for a king's palate.",
  "Our plans right now are hazy.",
  "Brass rings are sold by these natives.",
  "It takes a good trap to capture a bear.",
];

export const harvardList37Parts = [
  "Feed the white mouse some flower seeds.",
  "The thaw came early and freed the stream.",
  "He took the lead and kept it the whole distance.",
  "The key you designed will fit the lock.",
  "Plead to the council to free the poor thief.",
  "Better hash is made of rare beef.",
  "This plank was made for walking on.",
  "The lake sparkled in the red hot sun.",
  "He crawled with care along the ledge.",
  "Tend the sheep while the dog wanders.",
];

export const harvardList38Parts = [
  "It takes a lot of help to finish these.",
  "Mark the spot with a sign painted red.",
  "Take two shares as a fair profit.",
  "The fur of cats goes by many names.",
  "North winds bring colds and fevers.",
  "He asks no person to vouch for him.",
  "Go now and come here later.",
  "A sash of gold silk will trim her dress.",
  "Soap can wash most dirt away.",
  "That move means the game is over.",
];

export const harvardList39Parts = [
  "He wrote down a long list of items.",
  "A siege will crack the strong defense.",
  "Grape juice and water mix well.",
  "Roads are paved with sticky tar.",
  "Fake stones shine but cost little.",
  "The drip of the rain made a pleasant sound.",
  "Smoke poured out of every crack.",
  "Serve the hot rum to the tired heroes.",
  "Much of the story makes good sense.",
  "The sun came up to light the eastern sky.",
];

export const harvardList40Parts = [
  "Heave the line over the port side.",
  "A lathe cuts and trims any wood.",
  "It's a dense crowd in two distinct ways.",
  "His hip struck the knee of the next player.",
  "The stale smell of old beer lingers.",
  "The desk was firm on the shaky floor.",
  "It takes heat to bring out the odor.",
  "Beef is scarcer than some lamb.",
  "Raise the sail and steer the ship northward.",
  "A cone costs five cents on Mondays.",
];

export const harvardList41Parts = [
  "A pod is what peas always grow in.",
  "Jerk the dart from the cork target.",
  "No cement will hold hard wood.",
  "We now have a new base for shipping.",
  "A list of names is carved around the base.",
  "The sheep were led home by a dog.",
  "Three for a dime, the young peddler cried.",
  "The sense of smell is better than that of touch.",
  "No hardship seemed to keep him sad.",
  "Grace makes up for lack of beauty.",
];

export const harvardList42Parts = [
  "Nudge gently but wake her now.",
  "The news struck doubt into restless minds.",
  "Once we stood beside the shore.",
  "A chink in the wall allowed a draft to blow.",
  "Fasten two pins on each side.",
  "A cold dip restores health and zest.",
  "He takes the oath of office each March.",
  "The sand drifts over the sill of the old house.",
  "The point of the steel pen was bent and twisted.",
  "There is a lag between thought and act.",
];

export const harvardList43Parts = [
  "Seed is needed to plant the spring corn.",
  "Draw the chart with heavy black lines.",
  "The boy owed his pal thirty cents.",
  "The chap slipped into the crowd and was lost.",
  "Hats are worn to tea and not to dinner.",
  "The ramp led up to the wide highway.",
  "Beat the dust from the rug onto the lawn.",
  "Say it slowly but make it ring clear.",
  "The straw nest housed five robins.",
  "Screen the porch with woven straw mats.",
];

export const harvardList44Parts = [
  "This horse will nose his way to the finish.",
  "The dry wax protects the deep scratch.",
  "He picked up the dice for a second roll.",
  "These coins will be needed to pay his debt.",
  "The nag pulled the frail cart along.",
  "Twist the valve and release hot steam.",
  "The vamp of the shoe had a gold buckle.",
  "The smell of burned rags itches my nose.",
  "New pants lack cuffs and pockets.",
  "The marsh will freeze when cold enough.",
];

export const harvardList45Parts = [
  "They slice the sausage thin with a knife.",
  "The bloom of the rose lasts a few days.",
  "A gray mare walked before the colt.",
  "Breakfast buns are fine with a hot drink.",
  "Bottles hold four kinds of rum.",
  "The man wore a feather in his felt hat.",
  "He wheeled the bike past the winding road.",
  "Drop the ashes on the worn old rug.",
  "The desk and both chairs were painted tan.",
  "Throw out the used paper cup and plate.",
];

export const harvardList46Parts = [
  "A clean neck means a neat collar.",
  "The couch cover and hall drapes were blue.",
  "The stems of the tall glasses cracked and broke.",
  "The wall phone rang loud and often.",
  "The clothes dried on a thin wooden rack.",
  "Turn on the lantern which gives us light.",
  "The cleat sank deeply into the soft turf.",
  "The bills were mailed promptly on the tenth of the month.",
  "To have is better than to wait and hope.",
  "The price is fair for a good antique clock.",
];

export const harvardList47Parts = [
  "The music played on while they talked.",
  "Dispense with a vest on a day like this.",
  "The bunch of grapes was pressed into wine.",
  "He sent the figs, but kept the ripe cherries.",
  "The hinge on the door creaked with old age.",
  "The screen before the fire kept in the sparks.",
  "Fly by night, and you waste little time.",
  "Thick glasses helped him read the print.",
  "Birth and death mark the limits of life.",
  "The chair looked strong but had no bottom.",
];

export const harvardList48Parts = [
  "The kite flew wildly in the high wind.",
  "A fur muff is stylish once more.",
  "The tin box held priceless stones.",
  "We need an end of all such matter.",
  "The case was puzzling to the old and wise.",
  "The bright lanterns were gay on the dark lawn.",
  "We don't get much money but we have fun.",
  "The youth drove with zest, but little skill.",
  "Five years he lived with a shaggy dog.",
  "A fence cuts through the corner lot.",
];

export const harvardList49Parts = [
  "The way to save money is not to spend much.",
  "Shut the hatch before the waves push it in.",
  "The odor of spring makes young hearts jump.",
  "Crack the walnut with your sharp side teeth.",
  "He offered proof in the form of a large chart.",
  "Send the stuff in a thick paper bag.",
  "A quart of milk is water for the most part.",
  "They told wild tales to frighten him.",
  "The three story house was built of stone.",
  "In the rear of the ground floor was a large passage.",
];

export const harvardList50Parts = [
  "A man in a blue sweater sat at the desk.",
  "Oats are a food eaten by horse and man.",
  "Their eyelids droop for want of sleep.",
  "A sip of tea revives his tired friend.",
  "There are many ways to do these things.",
  "Tuck the sheet under the edge of the mat.",
  "A force equal to that would move the earth.",
  "We like to see clear weather.",
  "The work of the tailor is seen on each side.",
  "Take a chance and win a china doll.",
];

export const harvardList51Parts = [
  "Shake the dust from your shoes, stranger.",
  "She was kind to sick old people.",
  "The square wooden crate was packed to be shipped.",
  "The dusty bench stood by the stone wall.",
  "We dress to suit the weather of most days.",
  "Smile when you say nasty words.",
  "A bowl of rice is free with chicken stew.",
  "The water in this well is a source of good health.",
  "Take shelter in this tent, but keep still.",
  "That guy is the writer of a few banned books.",
];

export const harvardList52Parts = [
  "The little tales they tell are false.",
  "The door was barred, locked, and bolted as well.",
  "Ripe pears are fit for a queen's table.",
  "A big wet stain was on the round carpet.",
  "The kite dipped and swayed, but stayed aloft.",
  "The pleasant hours fly by much too soon.",
  "The room was crowded with a wild mob.",
  "This strong arm shall shield your honor.",
  "She blushed when he gave her a white orchid.",
  "The beetle droned in the hot June sun.",
];

export const harvardList53Parts = [
  "Press the pedal with your left foot.",
  "Neat plans fail without luck.",
  "The black trunk fell from the landing.",
  "The bank pressed for payment of the debt.",
  "The theft of the pearl pin was kept secret.",
  "Shake hands with this friendly child.",
  "The vast space stretched into the far distance.",
  "A rich farm is rare in this sandy waste.",
  "His wide grin earned many friends.",
  "Flax makes a fine brand of paper.",
];

export const harvardList54Parts = [
  "Hurdle the pit with the aid of a long pole.",
  "A strong bid may scare your partner stiff.",
  "Even a just cause needs power to win.",
  "Peep under the tent and see the clowns.",
  "The leaf drifts along with a slow spin.",
  "Cheap clothes are flashy but don't last.",
  "A thing of small note can cause despair.",
  "Flood the mails with requests for this book.",
  "A thick coat of black paint covered all.",
  "The pencil was cut to be sharp at both ends.",
];

export const harvardList55Parts = [
  "Those last words were a strong statement.",
  "He wrote his name boldly at the top of the sheet.",
  "Dill pickles are sour but taste fine.",
  "Down that road is the way to the grain farmer.",
  "Either mud or dust are found at all times.",
  "The best method is to fix it in place with clips.",
  "If you mumble your speech will be lost.",
  "At night the alarm roused him from a deep sleep.",
  "Read just what the meter says.",
  "Fill your pack with bright trinkets for the poor.",
];

export const harvardList56Parts = [
  "The small red neon lamp went out.",
  "Clams are small, round, soft, and tasty.",
  "The fan whirled its round blades softly.",
  "The line where the edges join was clean.",
  "Breathe deep and smell the piny air.",
  "It matters not if he reads these words or those.",
  "A brown leather bag hung from its strap.",
  "A toad and a frog are hard to tell apart.",
  "A white silk jacket goes with any shoes.",
  "A break in the dam almost caused a flood.",
];

export const harvardList57Parts = [
  "Paint the sockets in the wall dull green.",
  "The child crawled into the dense grass.",
  "Bribes fail where honest men work.",
  "Trample the spark, else the flames will spread.",
  "The hilt of the sword was carved with fine designs.",
  "A round hole was drilled through the thin board.",
  "Footprints showed the path he took up the beach.",
  "She was waiting at my front lawn.",
  "A vent near the edge brought in fresh air.",
  "Prod the old mule with a crooked stick.",
];

export const harvardList58Parts = [
  "It is a band of steel three inches wide.",
  "The pipe ran almost the length of the ditch.",
  "It was hidden from sight by a mass of leaves and shrubs.",
  "The weight of the package was seen on the high scale.",
  "Wake and rise, and step into the green outdoors.",
  "The green light in the brown box flickered.",
  "The brass tube circled the high wall.",
  "The lobes of her ears were pierced to hold rings.",
  "Hold the hammer near the end to drive the nail.",
  "Next Sunday is the twelfth of the month.",
];

export const harvardList59Parts = [
  "Every word and phrase he speaks is true.",
  "He put his last cartridge into the gun and fired.",
  "They took their kids from the public school.",
  "Drive the screw straight into the wood.",
  "Keep the hatch tight and the watch constant.",
  "Sever the twine with a quick snip of the knife.",
  "Paper will dry out when wet.",
  "Slide the catch back and open the desk.",
  "Help the weak to preserve their strength.",
  "A sullen smile gets few friends.",
];

export const harvardList60Parts = [
  "Stop whistling and watch the boys march.",
  "Jerk the cord, and out tumbles the gold.",
  "Slide the tray across the glass top.",
  "The cloud moved in a stately way and was gone.",
  "Light maple makes for a swell room.",
  "Set the piece here and say nothing.",
  "Dull stories make her laugh.",
  "A stiff cord will do to fasten your shoe.",
  "Get the trust fund to the bank early.",
  "Choose between the high road and the low.",
];

export const harvardList61Parts = [
  "A plea for funds seems to come again.",
  "He lent his coat to the tall gaunt stranger.",
  "There is a strong chance it will happen once more.",
  "The duke left the park in a silver coach.",
  "Greet the new guests and leave quickly.",
  "When the frost has come it is time for turkey.",
  "Sweet words work better than fierce.",
  "A thin stripe runs down the middle.",
  "A six comes up more often than a ten.",
  "Lush fern grow on the lofty rocks.",
];

export const harvardList62Parts = [
  "The ram scared the school children off.",
  "The team with the best timing looks good.",
  "The farmer swapped his horse for a brown ox.",
  "Sit on the perch and tell the others what to do.",
  "A steep trail is painful for our feet.",
  "The early phase of life moves fast.",
  "Green moss grows on the northern side.",
  "Tea in thin china has a sweet taste.",
  "Pitch the straw through the door of the stable.",
  "The latch on the back gate needed a nail.",
];

export const harvardList63Parts = [
  "The goose was brought straight from the old market.",
  "The sink is the thing in which we pile dishes.",
  "A whiff of it will cure the most stubborn cold.",
  "The facts don't always show who is right.",
  "She flaps her cape as she parades the street.",
  "The loss of the cruiser was a blow to the fleet.",
  "Loop the braid to the left and then over.",
  "Plead with the lawyer to drop the lost cause.",
  "Calves thrive on tender spring grass.",
  "Post no bills on this office wall.",
];

export const harvardList64Parts = [
  "Tear a thin sheet from the yellow pad.",
  "A cruise in warm waters in a sleek yacht is fun.",
  "A streak of color ran down the left edge.",
  "It was done before the boy could see it.",
  "Crouch before you jump or miss the mark.",
  "Pack the kits and don't forget the salt.",
  "The square peg will settle in the round hole.",
  "Fine soap saves tender skin.",
  "Poached eggs and tea must suffice.",
  "Bad nerves are jangled by a door slam.",
];

export const harvardList65Parts = [
  "Ship maps are different from those for planes.",
  "Dimes showered down from all sides.",
  "They sang the same tunes at each party.",
  "The sky in the west is tinged with orange red.",
  "The pods of peas ferment in bare fields.",
  "The horse balked and threw the tall rider.",
  "The hitch between the horse and cart broke.",
  "Pile the coal high in the shed corner.",
  "A gold vase is both rare and costly.",
  "The knife was hung inside its bright sheath.",
];

export const harvardList66Parts = [
  "The rarest spice comes from the far East.",
  "The roof should be tilted at a sharp slant.",
  "A smatter of French is worse than none.",
  "The mule trod the treadmill day and night.",
  "The aim of the contest is to raise a great fund.",
  "To send it now in large amounts is bad.",
  "There is a fine hard tang in salty air.",
  "Cod is the main business of the north shore.",
  "The slab was hewn from heavy blocks of slate.",
  "Dunk the stale biscuits into strong drink.",
];

export const harvardList67Parts = [
  "Hang tinsel from both branches.",
  "Cap the jar with a tight brass cover.",
  "The poor boy missed the boat again.",
  "Be sure to set the lamp firmly in the hole.",
  "Pick a card and slip it under the pack.",
  "A round mat will cover the dull spot.",
  "The first part of the plan needs changing.",
  "A good book informs of what we ought to know.",
  "The mail comes in three batches per day.",
  "You cannot brew tea in a cold pot.",
];

export const harvardList68Parts = [
  "Dots of light betrayed the black cat.",
  "Put the chart on the mantel and tack it down.",
  "The night shift men rate extra pay.",
  "The red paper brightened the dim stage.",
  "See the player scoot to third base.",
  "Slide the bill between the two leaves.",
  "Many hands help get the job done.",
  "We don't like to admit our small faults.",
  "No doubt about the way the wind blows.",
  "Dig deep in the earth for pirate's gold.",
];

export const harvardList69Parts = [
  "The steady drip is worse than a drenching rain.",
  "A flat pack takes less luggage space.",
  "Green ice frosted the punch bowl.",
  "A stuffed chair slipped from the moving van.",
  "The stitch will serve but needs to be shortened.",
  "A thin book fits in the side pocket.",
  "The gloss on top made it unfit to read.",
  "The hail pattered on the burnt brown grass.",
  "Seven seals were stamped on great sheets.",
  "Our troops are set to strike heavy blows.",
];

export const harvardList70Parts = [
  "The store was jammed before the sale could start.",
  "It was a bad error on the part of the new judge.",
  "One step more and the board will collapse.",
  "Take the match and strike it against your shoe.",
  "The pot boiled, but the contents failed to jell.",
  "The baby puts his right foot in his mouth.",
  "The bombs left most of the town in ruins.",
  "Stop and stare at the hard working man.",
  "The streets are narrow and full of sharp turns.",
  "The pup jerked the leash as he saw a feline shape.",
];

export const harvardList71Parts = [
  "Open your book to the first page.",
  "Fish evade the net and swim off.",
  "Dip the pail once and let it settle.",
  "Will you please answer that phone.",
  "The big red apple fell to the ground.",
  "The curtain rose and the show was on.",
  "The young prince became heir to the throne.",
  "He sent the boy on a short errand.",
  "Leave now and you will arrive on time.",
  "The corner store was robbed last night.",
];

export const harvardList72Parts = [
  "A gold ring will please most any girl.",
  "The long journey home took a year.",
  "She saw a cat in the neighbor's house.",
  "A pink shell was found on the sandy beach.",
  "Small children came to see him.",
  "The grass and bushes were wet with dew.",
  "The blind man counted his old coins.",
  "A severe storm tore down the barn.",
  "She called his name many times.",
  "When you hear the bell, come quickly.",
];
</file>

<file path="src/data/harvard.js">
// src/data/harvard.js
// Adapter: builds a passages map from harvard-lists.js exports (no manual 72 edits)

import * as lists from "./harvard-lists.js";

function pad2(n) {
  return String(n).padStart(2, "0");
}

export const harvardPassages = Object.fromEntries(
  Object.entries(lists)
    .filter(([name, val]) => /^harvardList\d{2}Parts$/.test(name) && Array.isArray(val))
    .sort(([a], [b]) => a.localeCompare(b))
    .map(([name, parts]) => {
      const m = name.match(/^harvardList(\d{2})Parts$/);
      const n = m ? m[1] : "??";

      // Keys become: harvard01, harvard02, ... (matches wireHarvardPicker())
      const key = `harvard${n}`;

      // Shape matches your passages.js objects: { name, parts }
      return [key, { name: `Harvard List ${n}`, parts: parts.slice(0, 10) }];
    })
);
</file>

<file path="src/data/passages.js">
// src/data/passages.js
// Centralized passage arrays extracted from the original data.js

/* ---------- PASSAGES / PART ARRAYS ---------- */
export const rainbowParts = [
  "When the sunlight strikes raindrops in the air,",
  "they act like a prism and form a rainbow.",
  "The rainbow is a division of white light into many beautiful colors.",
  "These take the shape of a long, round arch,",
  "with its path high above, and its two ends apparently beyond the horizon.",
  "There is, according to legend, a boiling pot of gold at one end.",
  "People look, but no one ever finds it.",
  "When a man looks for something beyond his reach,",
  "his friends say he is looking for the pot of gold at the end of the rainbow.",
  "Others have tried to explain the phenomenon physically.",
  "Aristotle thought that the rainbow was caused by reflection of the sun's rays by the rain.",
  "Since then, physicists have found that it is not reflection, but refraction by the raindrops,",
  "which causes the rainbows.",
];

export const grandfatherParts = [
  "You wish to know all about my grandfather.",
  "Well, he is nearly ninety-three years old, yet he still thinks as swiftly as ever.",
  "He dresses himself in an old black frock coat, usually with several buttons missing.",
  "A long beard clings to his chin, giving those who observe him a pronounced feeling of respect.",
  "When he speaks, his voice is just a bit cracked and quivers a trifle.",
  "Twice each day, he plays skillfully and with zest upon a small organ.",
  "Except in the winter, when the snow or ice prevents, he slowly takes a short walk in the open air each day.",
  "We have often urged him to walk more and smoke less, but he always answers, No, you see, I am quite well.",
  "He likes to eat simple, wholesome food.",
  "He enjoys his pipe and his daily walks.",
  "Grandfather is a wonderful man.",
];

export const caterpillarParts = [
  "Do you like amusement parks? Well, I sure do.",
  "To amuse myself, I went twice last spring.",
  "My most memorable moment was riding on the Caterpillar,",
  "which is a gigantic rollercoaster high above the ground.",
  "When I saw how high the Caterpillar rose into the bright blue sky, I knew it was for me.",
  "After waiting in line for thirty minutes, I made it to the front",
  "where the man measured my height to see if I was tall enough.",
  "I gave the man my coins, asked for change, and jumped on the cart.",
  "Tick, tick, tick, the Caterpillar climbed slowly up the tracks.",
  "It went so high I could see the parking lot.",
  "Boy was I scared! I thought to myself, “There’s no turning back now.”",
  "People were so scared they screamed as we swiftly zoomed fast, fast, and faster along the tracks.",
  "As quickly as it started, the Caterpillar came to a stop.",
  "Unfortunately, it was time to pack the car and drive home.",
  "That night I dreamt of the wild ride on the Caterpillar.",
  "Taking a trip to the amusement park and riding on the Caterpillar was my most memorable moment ever!",
];

export const hunterScriptParts = [
  "In late spring and early June, short rays of the sun call a true son out-of-doors.",
  "To an old hand, the job of the new boy at the forge is to hold the hot iron.",
  "A large size in shoes is a joy to a tall boy.",
  "The boy saw a small fly on the wall.",
  "He should stay out of the way of the car.",
  "A small blue bird is near the tall door.",
  "The young boy has a small box.",
  "One shoe is for a small foot.",
  "A big shoe is for a big foot.",
  "The boy should hold the box.",
];

export const huntersStoryParts = [
  "A young hunter named John went into the forest to find some food.",
  "He carried a long bow and a quiver of arrows.",
  "The sun was high in the sky, and the air was warm.",
  "John walked quietly, listening for any sounds of animals.",
  "Suddenly, he saw a deer standing near a large oak tree.",
  "He carefully pulled an arrow from his quiver and placed it on the bowstring.",
  "He took a deep breath, aimed, and let the arrow fly.",
  "The arrow struck a branch instead of the deer.",
  "The deer heard the noise and ran away into the thick brush.",
  "John sighed, but he was not discouraged.",
  "He knew that he would have another chance tomorrow.",
];

/* Arthur the Rat — Parts 1–3 */
export const arthurTheRat_p1_Parts = [
  "Once there was a young rat named Arthur, who could never make up his mind.",
  "Whenever his friends asked him if he would like to go out with them,",
  "he would only answer, \"I don't know.\"",
  "He wouldn't say \"yes\" or \"no\" either.",
  "He would always shirk making a choice.",
  "His aunt Helen said to him, \"Now look here.",
  "No one is going to care for you if you carry on like this.",
  "You have no more mind than a blade of grass.\"",
];

export const arthurTheRat_p2_Parts = [
  "One rainy day, the rats heard a great noise in the loft.",
  "The pine rafters were all rotten, so that the barn was rather unsafe.",
  "At last the joists gave way and fell to the ground.",
  "The walls shook and all the rats' hair stood on end with fear and horror.",
  "\"This won't do,\" said the captain.",
  "\"I'll send out scouts to search for a new home.\"",
  "Within five hours the ten scouts came back and said,",
  "\"We found a stone house where there is room and board for us all.",
  "There is a kindly horse named Nelly, a cow, a calf, and a garden with an elm tree.\"",
  "The rats crawled out of their little houses and stood on the floor in a long line.",
  "Just then the old one saw Arthur.",
  "\"Stop,\" he ordered coarsely.",
  "\"You are coming, of course?\"",
  "\"I'm not certain,\" said Arthur, undaunted.",
  "\"The roof may not come down yet.\"",
  "\"Well,\" said the angry old rat, \"we can't wait for you to join us.",
  "Right about face. March!\"",
];

export const arthurTheRat_p3_Parts = [
  "Arthur stood and watched them hurry away.",
  "\"I think I'll go tomorrow,\" he calmly said to himself,",
  "but then again \"I don't know; it's so nice and snug here.\"",
  "That night there was a big crash.",
  "In the morning some men—with some boys and girls—rode up and looked at the barn.",
  "One of them moved a board and he saw a young rat, quite dead, half in and half out of his hole.",
  "Thus the shirker got his due.",
];

/* The John Passage */
export const johnPassageParts = [
  "John planted a seed in his garden.",
  "He dug into the sod while humming a tune from the radio.",
  "The song was a tad off key,",
  "but John persisted because he was in a keyed up frame of mind from the long work week.",
  "As he worked, John’s buddy Todd walked by.",
  "Todd was thought to be somewhat of a cad by most, but was known for his stories.",
  "He spun a tale about an eccentric woman who sat on her stoop every night.",
  "She fed a cod and a shad to the pigeons that cooed from above.",
  "Every time she threw a bit of fish to the birds flying around her hair,",
  "she’d comment on how sad the pigeons seemed.",
  "Although the woman shooed the pigeons away when their numbers grew too big,",
  "the neighbors grew tired of the spectacle and they sued the woman.",
  "The woman decided to give up the pigeons and pursued her love for golf.",
  "Every morning at eight o’clock, she teed off at the first hole.",
  "Instead of a golf cart, however, she traveled from hole to hole",
  "on her freshly shod horse named Charlie.",
];

// Comma Gets a Cure — Parts 1–4
export const commaGetsACure_p1_Parts = [
  "Well, here’s a story for you: Sarah Perry was a veterinary nurse",
  "who had been working daily at an old zoo",
  "in a deserted district of the territory,",
  "so she was very happy to start a new job at a superb private practice in North Square near the Duke Street Tower.",
  "That area was much nearer for her and more to her liking.",
  "Even so, on her first morning, she felt stressed.",
  "She ate a bowl of porridge, checked herself in the mirror, and washed her face in a hurry.",
  "Then she put on a plain yellow dress and a fleece jacket, picked up her kit, and headed for work.",
];

export const commaGetsACure_p2_Parts = [
  "When she got there, there was a woman with a goose waiting for her.",
  "The woman gave Sarah an official letter from the vet.",
  "The letter implied that the animal could be suffering from a rare form of foot and mouth disease,",
  "which was surprising, because normally you would only expect to see it in a dog or a goat.",
  "Sarah was sentimental, so this made her feel sorry for the beautiful bird.",
];

export const commaGetsACure_p3_Parts = [
  "Before long, that itchy goose began to strut around the office like a lunatic, which made an unsanitary mess.",
  "The goose’s owner, Mary Harrison, kept calling, “Comma, Comma,” which Sarah thought was an odd choice for a name.",
  "Comma was strong and huge, so it would take some force to trap her, but Sarah had a different idea.",
  "First she tried gently stroking the goose’s lower back with her palm, then singing a tune to her.",
  "Finally, she administered ether.",
  "Her efforts were not futile.",
];

export const commaGetsACure_p4_Parts = [
  "In no time, the goose began to tire, so Sarah was able to hold on to Comma and give her a relaxing bath.",
  "Once Sarah had managed to bathe the goose, she wiped her off with a cloth and laid her on her right side.",
  "Then Sarah confirmed the vet’s diagnosis.",
  "Almost immediately, she remembered an effective treatment that required her to measure out a lot of medicine.",
  "Sarah warned that this course of treatment might be expensive—either five or six times the cost of penicillin.",
  "I can’t imagine paying so much, but Mrs. Harrison—a millionaire lawyer—thought it was a fair price for a cure.",
];

export const northWindAndSunParts = [
  "The North Wind and the Sun disputed which was the most powerful,",
  "and agreed that he should be declared the victor,",
  "who could first strip a wayfaring man of his clothes.",
  "The North Wind first tried his power, and blew with all his might:",
  "but the keener became his blasts, the closer the Traveller wrapped his cloak around him;",
  "till at last, resigning all hope of victory, he called upon the Sun to see what he could do.",
  "The Sun suddenly shone out with all his warmth.",
  "The Traveller no sooner felt his genial rays than he took off one garment after another,",
  "and at last, fairly overcome with heat, undressed, and bathed in a stream that lay in his path.",
  "Persuasion is better than Force.",
];

export const bambooPassageParts = [
  "Bamboo walls are getting to be very popular.",
  "They are strong, easy to use, and good-looking.",
  "They provide a good background and can create a look of a Japanese garden.",
  "Bamboo is a grass, and is one of the most rapidly growing grasses in the world.",
  "Many varieties of bamboo are grown in Asia, although it is also grown in America.",
  "Last year we bought a new home and have been working on the flower garden.",
  "In a few more days, we will be done with the bamboo wall in our garden.",
  "We have really enjoyed the project.",
];

/* Minimal-pair sets */
export const minLRParts = ["light", "right", "glass", "grass", "collect", "correct"];
export const minEEIHParts = ["sheep", "ship", "beat", "bit", "leave", "live"];
export const minAUAHParts = ["cap", "cup", "bat", "but", "bag", "bug"];

/* Targeted word list */
export const wordListParts = [
  "three", "think", "this", "street", "spring",
  "milk", "world", "advice", "leaves", "buzz",
];

/* Controlled sentences */
export const sentenceParts = [
  "Larry rarely reads really large red books.",
  "Three thin thieves thought they thrilled the throne.",
  "Sue saw six slippery snakes sliding south.",
];

/* Short paragraph */
export const shortStoryParts = [
  "Last Friday, Larry and Ruth went to a little park.",
  "They saw three red birds, six green frogs, and a group of small sheep.",
  "Larry thought the birds were really pretty, but Ruth liked the frogs best.",
  "They laughed and talked until it got dark.",
];

/* ---------- MASTER LOOKUP (UPDATED) ---------- */
export const passages = {
  rainbow: {
    name: "Rainbow Passage",
    parts: rainbowParts,
    // Mandarin speakers video sample
    youtubeId: "2Sf3vDdV2Ps",
    startAt: 0,
  },
  grandfather: {
    name: "Grandfather Passage",
    parts: grandfatherParts,
    // OTOY Interview Video
    youtubeId: "vAMGh1YLgAE",
    startAt: 0,
  },

  /* new passages */
  caterpillar: { name: "The Caterpillar", parts: caterpillarParts },
  hunterScript: { name: "The Hunter Script", parts: hunterScriptParts },
  huntersStory: { name: "The Hunter’s Story", parts: huntersStoryParts },

  // Arthur the Rat (3-part set)
  arthurTheRat_p1: { name: "Arthur the Rat (Part 1)", parts: arthurTheRat_p1_Parts },
  arthurTheRat_p2: { name: "Arthur the Rat (Part 2)", parts: arthurTheRat_p2_Parts },
  arthurTheRat_p3: { name: "Arthur the Rat (Part 3)", parts: arthurTheRat_p3_Parts },

  // The John Passage
  johnPassage: { name: "The John Passage", parts: johnPassageParts },

  // Comma Gets a Cure (4-part set)
  commaGetsACure_p1: { name: "Comma Gets a Cure (Part 1)", parts: commaGetsACure_p1_Parts },
  commaGetsACure_p2: { name: "Comma Gets a Cure (Part 2)", parts: commaGetsACure_p2_Parts },
  commaGetsACure_p3: { name: "Comma Gets a Cure (Part 3)", parts: commaGetsACure_p3_Parts },
  commaGetsACure_p4: { name: "Comma Gets a Cure (Part 4)", parts: commaGetsACure_p4_Parts },

  northWindAndSun: { name: "The North Wind and the Sun", parts: northWindAndSunParts },
  bamboo: { name: "The Bamboo Passage", parts: bambooPassageParts },

  /* tests */
  minLR: { name: "Phoneme Test: L vs R", parts: minLRParts },
  minEEIH: { name: "Phoneme Test: EE vs IH", parts: minEEIHParts },
  minAUAH: { name: "Phoneme Test: A vs U", parts: minAUAHParts },
  wordList: { name: "Challenging Word List", parts: wordListParts },
  sentences: { name: "Challenging Sentences", parts: sentenceParts },
  shortStory: { name: "Short Story Practice", parts: shortStoryParts },
};
</file>

<file path="src/data/phonemes/assets.js">
// assets.js
// Phoneme asset map (ipa + video) and lookup. Uses norm from core.
//
// COMPATIBILITY EDITION (pull-up strategy):
// - Keeps ALL your original keys exactly as-is (zero break risk for any code
//   that references phonemeAssets["u_short"], phonemeAssets["schwa"], etc.).
// - Adds extra alias keys (Azure-friendly codes like iy/uw/ax/ey/...) that
//   point to the SAME assets, so more inputs resolve to the same videos.
// - Builds an O(1) canonical lookup by IPA (assetsByIPA) and always uses norm().

import { norm } from "./core.js";

/* ---------------------------------------------------------
           Original map (unchanged keys)
   --------------------------------------------------------- */
const phonemeAssets = {
  /* Original batch */
  r: {
    ipa: "ɹ",
    video:
      "https://video.wixstatic.com/video/0d5d6f_7d727f4cc0d54acfb98e40c828905f0b/720p/mp4/file.mp4",
  },
  dh: {
    ipa: "ð",
    video:
      "https://video.wixstatic.com/video/0d5d6f_c0087bc4d2844ee78d209b004b9ac87d/720p/mp4/file.mp4",
  },
  th: {
    ipa: "θ",
    video:
      "https://video.wixstatic.com/video/0d5d6f_a84f54cbcdc043dabb5677dd27293e0e/720p/mp4/file.mp4",
  },
  l: {
    ipa: "l",
    video:
      "https://video.wixstatic.com/video/0d5d6f_368f7009129f4458bb8093e43c710463/720p/mp4/file.mp4",
  },
  sh: {
    ipa: "ʃ",
    video:
      "https://video.wixstatic.com/video/0d5d6f_4a4ea5cc1c7548739da1b6d8b0c11970/720p/mp4/file.mp4",
  },
  ae: {
    ipa: "æ",
    video:
      "https://video.wixstatic.com/video/0d5d6f_86dfe7364dcf4c6aaea6418f245b203f/480p/mp4/file.mp4",
  },
  v: {
    ipa: "v",
    video:
      "https://video.wixstatic.com/video/0d5d6f_f2e53f03b6eb4f05b9c24aa3302b6a51/720p/mp4/file.mp4",
  },
  zh: {
    ipa: "ʒ",
    video:
      "https://video.wixstatic.com/video/0d5d6f_b7941cad4a9f4ca985bb9e79cfa7c0ea/720p/mp4/file.mp4",
  },
  z: {
    ipa: "z",
    video:
      "https://video.wixstatic.com/video/0d5d6f_98738905164b417da9305818c866ccdf/720p/mp4/file.mp4",
  },

  ["ɳ"]: {
    ipa: "ɳ",
    video:
      "https://video.wixstatic.com/video/0d5d6f_fd6d5d0b30a14f5b8156276908f071d6/720p/mp4/file.mp4",
  },
  u_short: {
    ipa: "ʊ",
    video:
      "https://video.wixstatic.com/video/0d5d6f_d1f044e5eb254a858505df8cdc38cc6b/144p/mp4/file.mp4",
  },

  /* New Seeing-Speech clips — Stops / Plosives */
  p: {
    ipa: "p",
    video:
      "https://video.wixstatic.com/video/0d5d6f_cd77a253e2044a2f97ae82820c2e7db1/720p/mp4/file.mp4",
  },
  b: {
    ipa: "b",
    video:
      "https://video.wixstatic.com/video/0d5d6f_427b1facf4f94387b044e38e24573fbb/720p/mp4/file.mp4",
  },
  t: {
    ipa: "t",
    video:
      "https://video.wixstatic.com/video/0d5d6f_1c0eedc2840f46faba1a7c81cb6ec2b3/720p/mp4/file.mp4",
  },
  d: {
    ipa: "d",
    video:
      "https://video.wixstatic.com/video/0d5d6f_18f272949b024ed8bb09c9f82571ca4f/720p/mp4/file.mp4",
  },
  k: {
    ipa: "k",
    video:
      "https://video.wixstatic.com/video/0d5d6f_6e534b826f76438b8849303a93e058be/720p/mp4/file.mp4",
  },
  g: {
    ipa: "g",
    video:
      "https://video.wixstatic.com/video/0d5d6f_7ddce2d0d737482fa021d4a5e08e6c83/720p/mp4/file.mp4",
  },
  ["ʔ"]: {
    ipa: "ʔ",
    video:
      "https://video.wixstatic.com/video/0d5d6f_0738fc5a714b44528439e1ab67887525/720p/mp4/file.mp4",
  },

  /* Vowels (monophthongs & useful contrasts) */
  i: {
    ipa: "i",
    video:
      "https://video.wixstatic.com/video/0d5d6f_7bfbbe6277e04dc9bf6b4c25b7085fc6/144p/mp4/file.mp4",
  },
  ih: {
    ipa: "ɪ",
    video:
      "https://video.wixstatic.com/video/0d5d6f_bcfcacac0c8341caa2131bade4621ee5/144p/mp4/file.mp4",
  },
  e: {
    ipa: "e",
    video:
      "https://video.wixstatic.com/video/0d5d6f_6fe00ec89935410d8ce645528186046c/144p/mp4/file.mp4",
  },
  schwa: {
    ipa: "ə",
    video:
      "https://video.wixstatic.com/video/0d5d6f_b29663890f8e4d1aa96005c8e46bf497/144p/mp4/file.mp4",
  },
  eh: {
    ipa: "ɛ",
    video:
      "https://video.wixstatic.com/video/0d5d6f_5753dd7d338b472a9c5e0b4009a90a44/144p/mp4/file.mp4",
  },
  uh: {
    ipa: "ʌ",
    video:
      "https://video.wixstatic.com/video/0d5d6f_1602100a59d8495098039185c8fe09e6/144p/mp4/file.mp4",
  },
  u: {
    ipa: "u",
    video:
      "https://video.wixstatic.com/video/0d5d6f_a8aa8854bb3e4fccbc1e70a9e847d9b8/144p/mp4/file.mp4",
  },
  ah: {
    ipa: "ɑ",
    video:
      "https://video.wixstatic.com/video/0d5d6f_16ba279a5bed4aa4a3ae915a0c708e98/144p/mp4/file.mp4",
  },
  aw: {
    ipa: "ɔ",
    video:
      "https://video.wixstatic.com/video/0d5d6f_dca89bb4ab2b409fad8e4b9fc97edd27/144p/mp4/file.mp4",
  },
  o: {
    ipa: "o",
    video:
      "https://video.wixstatic.com/video/0d5d6f_70ffa1aa7b914a1484fc27ff65180012/144p/mp4/file.mp4",
  },

  /* === Rhotic vowels === */
  er: {
    ipa: "ɝ",
    video:
      "https://video.wixstatic.com/video/0d5d6f_a4fd7aac7c27437fa0c9f70b243d0824/480p/mp4/file.mp4",
  },
  axr: {
    ipa: "ɚ",
    video:
      "https://video.wixstatic.com/video/0d5d6f_4686a9b0407d4546b1c4fa746ade7392/480p/mp4/file.mp4",
  },

  /* Diphthongs */
  ["eɪ"]: {
    ipa: "eɪ",
    video:
      "https://video.wixstatic.com/video/0d5d6f_c2d47dad0b3f470aa51768cd8f4dea74/480p/mp4/file.mp4",
  },
  ["aɪ"]: {
    ipa: "aɪ",
    video:
      "https://video.wixstatic.com/video/0d5d6f_dedfc9cb295c4ebb972acb13cfebdd1d/480p/mp4/file.mp4",
  },
  ["ɔɪ"]: {
    ipa: "ɔɪ",
    video:
      "https://video.wixstatic.com/video/0d5d6f_afc6389fce44476a921b4eee252726fa/480p/mp4/file.mp4",
  },
  ["aʊ"]: {
    ipa: "aʊ",
    video:
      "https://video.wixstatic.com/video/0d5d6f_a4ed3fe3131e4d658be6bf6fad23ea4d/480p/mp4/file.mp4",
  },
  ["oʊ"]: {
    ipa: "oʊ",
    video:
      "https://video.wixstatic.com/video/0d5d6f_7ccc4f3663c84a409f4b9ec41324e9ac/480p/mp4/file.mp4",
  },

  /* Nasals */
  m: {
    ipa: "m",
    video:
      "https://video.wixstatic.com/video/0d5d6f_7ee24079934f49c99418747c7fb9b291/720p/mp4/file.mp4",
  },
  n: {
    ipa: "n",
    video:
      "https://video.wixstatic.com/video/0d5d6f_cc606e7ffbd94b45b34f086802771210/720p/mp4/file.mp4",
  },
  ["ŋ"]: {
    ipa: "ŋ",
    video:
      "https://video.wixstatic.com/video/0d5d6f_3a8df55492824f7abfaf245c40bf9982/720p/mp4/file.mp4",
  },

  /* Fricatives */
  f: {
    ipa: "f",
    video:
      "https://video.wixstatic.com/video/0d5d6f_c14cb7ce09204f4b9e3476e1bb39e0b6/720p/mp4/file.mp4",
  },
  s: {
    ipa: "s",
    video:
      "https://video.wixstatic.com/video/0d5d6f_1a60932597874db19eda4c5c69191826/720p/mp4/file.mp4",
  },
  h: {
    ipa: "h",
    video:
      "https://video.wixstatic.com/video/0d5d6f_eec4d7bd4500484a857a1ffeaeb2ab5b/720p/mp4/file.mp4",
  },

  /* Affricates */
  ["tʃ"]: {
    ipa: "tʃ",
    video:
      "https://video.wixstatic.com/video/0d5d6f_ad3b6fb26e7d46fab857862c3de1d752/720p/mp4/file.mp4",
  },
  ["dʒ"]: {
    ipa: "dʒ",
    video:
      "https://video.wixstatic.com/video/0d5d6f_805a57c5fdbc48eab56188314951b385/720p/mp4/file.mp4",
  },

  /* Approximants / Glides */
  w: {
    ipa: "w",
    video:
      "https://video.wixstatic.com/video/0d5d6f_9532587ba76245ae86301b2734b632dd/720p/mp4/file.mp4",
  },
  j: {
    ipa: "j",
    video:
      "https://video.wixstatic.com/video/0d5d6f_9e45cb00760e4d4d8b8236ea8b61b1c9/720p/mp4/file.mp4",
  },
  ["ʍ"]: {
    ipa: "ʍ",
    video:
      "https://video.wixstatic.com/video/0d5d6f_5e09d71fb68e494480d5122d722a0e02/720p/mp4/file.mp4",
  },
  ["ɾ"]: {
    ipa: "ɾ",
    video:
      "https://video.wixstatic.com/video/0d5d6f_2e1b9a5fd9e14b40975a59ce641c6925/720p/mp4/file.mp4",
  },
};

// Capture canonical keys BEFORE we add alias keys (prevents aliases from overwriting).
const CANON_KEYS = Object.keys(phonemeAssets);

/* ---------------------------------------------------------
   Compatibility aliases (additive; points to existing entries)
   - Adds Azure-friendly codes that your core.js already knows about
     without changing any of your original keys.
   - If a key already exists, we DO NOT overwrite it.
   --------------------------------------------------------- */
function addAliasKey(newKey, existingKey) {
  if (!phonemeAssets[newKey] && phonemeAssets[existingKey]) {
    phonemeAssets[newKey] = phonemeAssets[existingKey];
  }
}

// Vowels (Azure -> existing keys you already use)
addAliasKey("iy", "i");
addAliasKey("ax", "schwa");
addAliasKey("uw", "u");
addAliasKey("aa", "ah"); // /ɑ/
addAliasKey("ao", "aw"); // /ɔ/
addAliasKey("ey", "eɪ");
addAliasKey("ay", "aɪ");
addAliasKey("oy", "ɔɪ");
addAliasKey("ow", "oʊ");

// Consonants (Azure -> existing)
addAliasKey("ng", "ŋ");
addAliasKey("ch", "tʃ");
addAliasKey("jh", "dʒ");
addAliasKey("dx", "ɾ");
addAliasKey("wh", "ʍ");
addAliasKey("q", "ʔ");
addAliasKey("y", "j");

// Also accept direct IPA keys for convenience (without changing anything)
addAliasKey("ɹ", "r");
addAliasKey("θ", "th");
addAliasKey("ð", "dh");

/* ---------------------------------------------------------
   Front-facing mouth videos (served from /public)
   Convention: /vid/ph-front/<CANON_KEY>.mp4
   (We URI-encode the key so unicode phones like ɾ/ʔ/tʃ work.)
   --------------------------------------------------------- */
const FRONT_BASE = "/vid/ph-front/";
for (const k of CANON_KEYS) {
  const a = phonemeAssets[k];
  if (a && !a.videoFront) {
    a.videoFront = FRONT_BASE + encodeURIComponent(k) + ".mp4";
  }
}

/* ---------------------------------------------------------
   Build O(1) lookup by canonical IPA
   - We normalize before indexing to prevent drift.
   --------------------------------------------------------- */
const assetsByIPA = Object.create(null);

Object.values(phonemeAssets).forEach((a) => {
  if (!a?.ipa || !a?.video) return;
  const ipa = norm(a.ipa);
  if (!assetsByIPA[ipa])
    assetsByIPA[ipa] = { ipa, video: a.video, videoFront: a.videoFront || "" };
});

/* Defensive fallback: if ɚ ever goes missing, reuse the ɹ clip (better than null). */
if (!assetsByIPA["ɚ"] && assetsByIPA["ɹ"]?.video) {
  assetsByIPA["ɚ"] = {
    ipa: "ɚ",
    video: assetsByIPA["ɹ"].video,
    videoFront: assetsByIPA["ɹ"].videoFront || "",
  };
}

/** Fast lookup by IPA (or Azure code—both normalized). */
export function getPhonemeAssetByIPA(symbol) {
  return assetsByIPA[norm(symbol)] || null;
}

export { phonemeAssets };
</file>

<file path="src/data/phonemes/core.js">
// core.js
// Normalization helpers and sequence coalescing (from original data.js)
// Canonical IPA truth lives here.
//
// ALIGNMENT UPDATE (assets-compatible):
// - Adds aliases for any asset keys you use (e.g., schwa, u_short).
// - Keeps ALL existing mappings unchanged (safe).
// - Slightly hardens norm(): trim + lowercases underscore/hyphen codes too.
// - Keeps affricate/tie-bar handling as before.

const phonemeAlias = {
  // ---------------------------
  // VOWELS (Azure → canonical IPA)
  // ---------------------------
  iy: "i",
  ih: "ɪ",
  eh: "ɛ",
  ae: "æ",
  aa: "ɑ",
  ao: "ɔ",
  ah: "ʌ",
  ax: "ə",
  axr: "ɚ",
  er: "ɝ",
  uw: "u",
  uh: "ʊ",
  ey: "eɪ",
  ay: "aɪ",
  aw: "aʊ",
  ow: "oʊ",
  oy: "ɔɪ",

  // ---------------------------
  // VOWEL LABELS USED IN ASSETS / UI (project-friendly)
  // ---------------------------
  schwa: "ə",
  u_short: "ʊ",

  // ---------------------------
  // CONSONANTS (Azure/ASCII → canonical IPA)
  // ---------------------------
  p: "p",
  b: "b",
  t: "t",
  d: "d",
  k: "k",
  g: "g",
  f: "f",
  v: "v",
  th: "θ",
  dh: "ð",
  s: "s",
  z: "z",
  sh: "ʃ",
  zh: "ʒ",
  h: "h",
  hh: "h",
  m: "m",
  n: "n",
  ng: "ŋ",
  l: "l",
  r: "ɹ",
  w: "w",
  y: "j",
  ch: "tʃ",
  jh: "dʒ",
  dx: "ɾ",
  wh: "ʍ",
  q: "ʔ",

  // ---------------------------
  // Legacy / alternate symbols that show up in old data
  // ---------------------------
  "t͡ʃ": "tʃ",
  "d͡ʒ": "dʒ",
  "ʧ": "tʃ",
  "ʤ": "dʒ",

  // ---------------------------
  // Already-IPA passthrough (no change, but harmless if seen)
  // (Includes everything core already covered + the extra asset symbol ɳ.)
  // ---------------------------
  "ŋ": "ŋ",
  "ɹ": "ɹ",
  "ɾ": "ɾ",
  "ʔ": "ʔ",
  "ʍ": "ʍ",
  "θ": "θ",
  "ð": "ð",
  "ʃ": "ʃ",
  "ʒ": "ʒ",
  "tʃ": "tʃ",
  "dʒ": "dʒ",

  // Extras present in assets.js (safe to include; does not affect Azure outputs)
  "ɳ": "ɳ",
};

// combining tie-bars, ZWJ, etc.
const TIE = /[\u0361\u035C\u200D\u034F]/g;

// legacy single-codepoint affricates some fonts use
const LEGACY = { "ʧ": "tʃ", "ʤ": "dʒ" };

/** Normalize any phoneme symbol to the canonical form used everywhere. */
export function norm(sym) {
  if (!sym) return sym;

  let s = String(sym).normalize("NFC").trim();
  if (!s) return s;

  // Lowercase ASCII-ish codes (letters, digits, underscores, hyphens).
  // Keeps IPA intact because IPA symbols are non-ASCII.
  if (/^[A-Za-z0-9_-]+$/.test(s)) s = s.toLowerCase();

  // Legacy single-codepoint affricates first
  if (LEGACY[s]) s = LEGACY[s];

  // Replace explicit tie-bar affricates
  s = s
    .replace(/t[\u0361\u035C]?ʃ/g, "tʃ")
    .replace(/d[\u0361\u035C]?ʒ/g, "dʒ");

  // Strip any leftover tie bars / ZWJ
  s = s.replace(TIE, "");

  // Finally map Azure/legacy -> canonical IPA (and any remaining aliases)
  return phonemeAlias[s] || s;
}

/* ---------- Sequence coalescing (fix for ɚ not surfacing) ---------- */
/**
 * Normalize and coalesce an Azure phoneme sequence into canonical IPA,
 * merging rhotic schwa combos (ax + r / ə + ɹ → ɚ).
 *
 * Call this on the array you get back from Azure before scoring/display.
 */
export function normalizePhoneSequence(seq) {
  if (!Array.isArray(seq)) return [];
  const out = [];

  for (let i = 0; i < seq.length; i++) {
    const cur = norm(seq[i]);
    const next = norm(seq[i + 1]);

    // Merge unstressed rhotic vowel: schwa + r  -> ɚ
    if (cur === "ə" && next === "ɹ") {
      out.push("ɚ");
      i++; // skip the following /ɹ/
      continue;
    }

    out.push(cur);
  }

  return out;
}
</file>

<file path="src/data/phonemes/details.js">
// details.js
// articulatorPlacement + per-phoneme coaching details and youtube link
//
// This file is the “plain-English” side (friendly, independently clear).
// Technical/jargon-heavy copy can live in a future “tech side” map.

import { norm } from "./core.js";

/* =========================================================================
   Articulator placement (PLAIN ENGLISH)
   - Keyed by CANONICAL IPA (so it aligns with core.js + assets.js).
   - Each entry stands alone (no “same as X” dependencies).
   ========================================================================= */

export const articulatorPlacement = {
  /* -------------------- CONSONANTS -------------------- */

  p: {
    label: "P (no voice) — lips stop, then pop open",
    example: "pie",
    tip: "Close your lips tightly, build a small puff of air, then release. Keep your throat quiet (no buzzing).",
  },
  b: {
    label: "B (voice on) — lips stop, then pop open",
    example: "buy",
    tip: "Close your lips, turn your voice on (feel a gentle throat buzz), then release the lips.",
  },
  t: {
    label: "T (no voice) — tongue tap behind top teeth",
    example: "tea",
    tip: "Touch the tip of your tongue to the gum ridge just behind your upper front teeth. Hold air briefly, then release with no throat buzz.",
  },
  d: {
    label: "D (voice on) — tongue tap behind top teeth",
    example: "do",
    tip: "Touch the tongue tip to the gum ridge behind your upper front teeth, keep your voice on (throat buzz), then release.",
  },
  k: {
    label: "K (no voice) — back of tongue blocks, then releases",
    example: "cat",
    tip: "Lift the back of your tongue to touch the soft palate (back of the roof of your mouth). Release with a clean burst of air and no throat buzz.",
  },
  g: {
    label: "G (voice on) — back of tongue blocks, then releases",
    example: "go",
    tip: "Lift the back of your tongue to the soft palate, keep your voice on (throat buzz), then release.",
  },

  m: {
    label: "M (voice on) — lips closed, air through nose",
    example: "me",
    tip: "Close your lips and let the sound come out through your nose. Keep your voice on (gentle throat buzz).",
  },
  n: {
    label: "N (voice on) — tongue behind top teeth, air through nose",
    example: "no",
    tip: "Touch the tongue tip to the gum ridge behind your upper front teeth and let air flow through your nose while voicing.",
  },
  "ŋ": {
    label: "NG (voice on) — back of tongue, air through nose",
    example: "sing",
    tip: "Raise the back of your tongue (as for /k/ or /g/) and let the sound come out through your nose. Keep voicing on.",
  },

  f: {
    label: "F (no voice) — teeth on lip, steady air",
    example: "fine",
    tip: "Rest your top teeth gently on your bottom lip and blow air steadily. No throat buzz.",
  },
  v: {
    label: "V (voice on) — teeth on lip, steady air",
    example: "vine",
    tip: "Top teeth lightly on bottom lip, blow air steadily, and keep your voice on (throat buzz).",
  },

  "θ": {
    label: "TH (no voice) — tongue lightly at the teeth",
    example: "think",
    tip: "Place your tongue tip lightly between your teeth (or just behind the top teeth) and let air hiss through. No throat buzz.",
  },
  "ð": {
    label: "TH (voice on) — tongue lightly at the teeth",
    example: "this",
    tip: "Place your tongue tip lightly between your teeth (or just behind the top teeth), let air pass through, and keep your voice on (throat buzz).",
  },

  s: {
    label: "S (no voice) — narrow air stream at the front",
    example: "see",
    tip: "Keep your tongue close to the front roof of your mouth (behind upper teeth) and blow a thin stream of air through the middle. No throat buzz.",
  },
  z: {
    label: "Z (voice on) — narrow air stream at the front",
    example: "zoo",
    tip: "Make the same narrow air stream as /s/, but keep your voice on (throat buzz).",
  },

  "ʃ": {
    label: "SH (no voice) — rounded lips, air over a slightly back tongue",
    example: "shoe",
    tip: "Round your lips slightly and pull your tongue a little farther back than /s/. Let air flow steadily with no throat buzz.",
  },
  "ʒ": {
    label: "ZH (voice on) — like “measure” sound",
    example: "measure",
    tip: "Shape your mouth like /ʃ/ (slight lip rounding, tongue a bit back) but keep your voice on (throat buzz).",
  },

  h: {
    label: "H (no voice) — open mouth breath sound",
    example: "he",
    tip: "Open your mouth and breathe out smoothly, as if fogging a window—no tongue or lip contact needed.",
  },

  "tʃ": {
    label: "CH (no voice) — stop + quick “sh” release",
    example: "chair",
    tip: "Make a quick tongue stop behind the upper teeth, then immediately release into a “sh”-like airflow, all as one sound. No throat buzz.",
  },
  "dʒ": {
    label: "J (voice on) — stop + quick “zh” release",
    example: "judge",
    tip: "Make a quick tongue stop behind the upper teeth, then release into the “measure” (ʒ) type airflow while keeping your voice on.",
  },

  "ɹ": {
    label: "R (voice on) — tongue lifted but not touching",
    example: "red",
    tip: "Lift and bunch your tongue slightly back in the mouth without touching the roof. Keep your voice on and avoid friction.",
  },
  l: {
    label: "L (voice on) — tongue tip up, air flows around sides",
    example: "let",
    tip: "Touch your tongue tip to the gum ridge behind the upper teeth. Keep voicing on and let air escape around the sides of the tongue.",
  },

  w: {
    label: "W (voice on) — rounded lips, quick glide",
    example: "we",
    tip: "Round your lips and move quickly into the next vowel while keeping your voice on.",
  },
  j: {
    label: "Y (voice on) — quick “ee”-like glide",
    example: "yes",
    tip: "Lift the front of your tongue toward the hard palate (like the start of “ee”) and glide into the next vowel with voicing on.",
  },

  "ɾ": {
    label: "Fast T/D tap (voice on) — quick tongue flick",
    example: "water (American)",
    tip: "Keep voicing on and flick the tongue tip quickly against the gum ridge behind the upper teeth. It’s a very fast, light contact.",
  },

  "ʔ": {
    label: "Throat stop — tiny pause in airflow",
    example: "uh-oh",
    tip: "Briefly close your vocal folds to stop the air for a moment, then release. It feels like a tiny catch in your throat.",
  },

  "ʍ": {
    label: "Breathy W (no voice) — “which” (for some speakers)",
    example: "which",
    tip: "Round your lips like /w/, but keep your voice off and push air through. It’s a breathy, whispered W.",
  },

  "ɳ": {
    label: "N with tongue curled back (not common in English)",
    example: "—",
    tip: "Curl the tongue tip slightly back (a retroflex shape) and let the sound come out through the nose while voicing. This sound is mainly used in some languages other than English.",
  },

  /* -------------------- VOWELS (MONOPHTHONGS) -------------------- */

  i: {
    label: "EE vowel — steady, smile-like",
    example: "see",
    tip: "Spread your lips slightly (like a small smile) and raise the front of your tongue high. Hold the vowel steady.",
  },
  "ɪ": {
    label: "IH vowel — relaxed, shorter",
    example: "sit",
    tip: "Keep the tongue high-front but a little lower and more relaxed than /i/. Lips relaxed; vowel is usually shorter.",
  },
  e: {
    label: "AY start vowel — the start of “day”",
    example: "day (start)",
    tip: "Raise the front of your tongue to a mid-high position. Lips neutral. (In many accents, this vowel quickly glides into /ɪ/.)",
  },
  "ɛ": {
    label: "EH vowel — open-mid front",
    example: "bed",
    tip: "Open your mouth a bit more and keep the tongue mid-front. Lips neutral.",
  },
  "æ": {
    label: "A vowel — wide mouth, low-front",
    example: "cat",
    tip: "Drop your jaw and keep the tongue low and forward. Lips neutral to slightly spread.",
  },
  "ɑ": {
    label: "AH vowel — open, back",
    example: "father",
    tip: "Open the mouth wide. Keep the tongue low and back. Lips relaxed (not rounded).",
  },
  "ɔ": {
    label: "AW vowel — back + rounded lips",
    example: "thought",
    tip: "Round your lips and keep the tongue back with a medium-open jaw. (Some speakers merge this with /ɑ/.)",
  },
  o: {
    label: "OH start vowel — the start of “go”",
    example: "go (start)",
    tip: "Round your lips and keep the tongue mid-back. (In many accents, this vowel quickly glides toward /ʊ/.)",
  },
  "ʊ": {
    label: "Short OO vowel — like “book”",
    example: "book",
    tip: "Loosely round your lips and keep the tongue high-back but relaxed. Keep it short.",
  },
  u: {
    label: "OO vowel — like “food”",
    example: "food",
    tip: "Round your lips more firmly and raise the tongue high-back. Hold the vowel steady.",
  },
  "ʌ": {
    label: "UH vowel — like “cup”",
    example: "cup",
    tip: "Keep lips relaxed and the tongue in a central-to-back, mid position. Jaw moderately open.",
  },
  "ə": {
    label: "Schwa — quick, relaxed “uh” in unstressed syllables",
    example: "about (first “a”)",
    tip: "Relax your mouth and tongue. Make a very short, neutral “uh” sound—usually only in unstressed syllables.",
  },

  "ɝ": {
    label: "Stressed ER — like “bird”",
    example: "bird",
    tip: "Keep your tongue in an R-shaped position (bunched or slightly curled back) while voicing the vowel. Hold it steady.",
  },
  "ɚ": {
    label: "Unstressed ER — like the end of “teacher”",
    example: "teacher (end)",
    tip: "Use the same R-shaped tongue as /ɝ/, but make it shorter and unstressed.",
  },

  /* -------------------- DIPHTHONGS -------------------- */

  "eɪ": {
    label: "AY diphthong — “day”",
    example: "day",
    tip: "Start with the “day-start” vowel and glide upward toward a short /ɪ/. The movement is smooth and quick.",
  },
  "aɪ": {
    label: "I diphthong — “my”",
    example: "my",
    tip: "Start with an open mouth and then glide up toward /ɪ/ as the mouth narrows slightly.",
  },
  "ɔɪ": {
    label: "OY diphthong — “boy”",
    example: "boy",
    tip: "Start with rounded lips and a back vowel feeling, then glide to /ɪ/ as the lips spread a bit.",
  },
  "aʊ": {
    label: "OW diphthong — “now”",
    example: "now",
    tip: "Start open and unrounded, then glide toward /ʊ/ with more lip rounding near the end.",
  },
  "oʊ": {
    label: "OH diphthong — “go”",
    example: "go",
    tip: "Start with rounded “go-start” vowel and glide toward /ʊ/. Keep the motion smooth.",
  },
};

/* Mirror common alternate spellings/affricate tie-bars into canonical keys */
(() => {
  const AP = articulatorPlacement;

  [
    ["t͡ʃ", "tʃ"],
    ["d͡ʒ", "dʒ"],
    ["ʧ", "tʃ"],
    ["ʤ", "dʒ"],
  ].forEach(([from, to]) => {
    if (AP[from] && !AP[to]) AP[to] = AP[from];
    if (AP[to] && !AP[from]) AP[from] = AP[to];
  });
})();

/** Safe accessor (works with Azure codes, IPA, tie-bars, etc.). */
export function getArticulatorPlacement(symbol) {
  return articulatorPlacement[norm(symbol)] || null;
}

/* =========================================================================
   Per-phoneme coaching details (extra “coach notes”)
   - Still plain-ish, but can include “common mix-ups”.
   - Mapped by canonical IPA via norm().
   ========================================================================= */

const phonemeDetails = {
  // Consonants
  p: { tip: articulatorPlacement.p.tip, mistake: "Often loses the little puff and sounds too soft.", ipa: "/p/ (pie)" },
  b: { tip: articulatorPlacement.b.tip, mistake: "Often loses voicing and sounds like /p/.", ipa: "/b/ (buy)" },
  t: { tip: articulatorPlacement.t.tip, mistake: "May sound too weak or turn into a tap in casual speech.", ipa: "/t/ (tea)" },
  d: { tip: articulatorPlacement.d.tip, mistake: "May lose voicing and sound like /t/.", ipa: "/d/ (do)" },
  k: { tip: articulatorPlacement.k.tip, mistake: "May be too far forward and sound like /t/.", ipa: "/k/ (cat)" },
  g: { tip: articulatorPlacement.g.tip, mistake: "May lose voicing and sound like /k/.", ipa: "/g/ (go)" },

  m: { tip: articulatorPlacement.m.tip, mistake: "Nasal airflow gets blocked (turns into /b/).", ipa: "/m/ (me)" },
  n: { tip: articulatorPlacement.n.tip, mistake: "Tongue placement drifts and it becomes /ŋ/ in the wrong places.", ipa: "/n/ (no)" },
  "ŋ": { tip: articulatorPlacement["ŋ"].tip, mistake: "Added extra /g/ sound (“sing-guh”).", ipa: "/ŋ/ (sing)" },

  f: { tip: articulatorPlacement.f.tip, mistake: "Airflow too weak; turns into /p/ or /h/.", ipa: "/f/ (fine)" },
  v: { tip: articulatorPlacement.v.tip, mistake: "Loses voicing and becomes /f/.", ipa: "/v/ (vine)" },

  "θ": { tip: articulatorPlacement["θ"].tip, mistake: "Tongue stays inside; it becomes /t/ or /s/.", ipa: "/θ/ (think)" },
  "ð": { tip: articulatorPlacement["ð"].tip, mistake: "Tongue stays inside; it becomes /d/ or /z/.", ipa: "/ð/ (this)" },

  s: { tip: articulatorPlacement.s.tip, mistake: "Becomes voiced /z/ when it should be unvoiced.", ipa: "/s/ (see)" },
  z: { tip: articulatorPlacement.z.tip, mistake: "Loses voicing and becomes /s/.", ipa: "/z/ (zoo)" },

  "ʃ": { tip: articulatorPlacement["ʃ"].tip, mistake: "Tongue too far forward; sounds like /s/.", ipa: "/ʃ/ (shoe)" },
  "ʒ": { tip: articulatorPlacement["ʒ"].tip, mistake: "Loses voicing and becomes /ʃ/.", ipa: "/ʒ/ (measure)" },

  h: { tip: articulatorPlacement.h.tip, mistake: "Gets dropped entirely at the start of words.", ipa: "/h/ (he)" },

  "tʃ": { tip: articulatorPlacement["tʃ"].tip, mistake: "Missing the stop part; turns into /ʃ/.", ipa: "/tʃ/ (chair)" },
  "dʒ": { tip: articulatorPlacement["dʒ"].tip, mistake: "Missing the stop part; turns into /ʒ/.", ipa: "/dʒ/ (judge)" },

  "ɹ": { tip: articulatorPlacement["ɹ"].tip, mistake: "Tongue touches the roof (creates friction) or becomes a tap/trill.", ipa: "/ɹ/ (red)" },
  l: { tip: articulatorPlacement.l.tip, mistake: "Tongue tip doesn’t lift; vowel takes over and /l/ disappears.", ipa: "/l/ (let)" },

  w: { tip: articulatorPlacement.w.tip, mistake: "Lip rounding is missing; sounds like /v/ or a plain vowel.", ipa: "/w/ (we)" },
  j: { tip: articulatorPlacement.j.tip, mistake: "Glide is too weak and disappears.", ipa: "/j/ (yes)" },

  "ɾ": { tip: articulatorPlacement["ɾ"].tip, mistake: "Held too long and sounds like /d/.", ipa: "/ɾ/ (water, AmE)" },
  "ʔ": { tip: articulatorPlacement["ʔ"].tip, mistake: "Used too often where a clear /t/ is expected.", ipa: "/ʔ/ (uh-oh)" },

  "ʍ": { tip: articulatorPlacement["ʍ"].tip, mistake: "Becomes voiced /w/ (many accents do this; it’s not always wrong).", ipa: "/ʍ/ (which, some speakers)" },

  "ɳ": { tip: articulatorPlacement["ɳ"].tip, mistake: "Tongue is not curled back enough; it becomes /n/.", ipa: "/ɳ/ (non-English in many cases)" },

  // Vowels
  i: { tip: articulatorPlacement.i.tip, mistake: "Becomes too relaxed and shifts toward /ɪ/.", ipa: "/i/ (see)" },
  "ɪ": { tip: articulatorPlacement["ɪ"].tip, mistake: "Too tense and becomes /i/.", ipa: "/ɪ/ (sit)" },
  e: { tip: articulatorPlacement.e.tip, mistake: "Glide is missing; can sound flat or too open.", ipa: "/e/ (day-start)" },
  "ɛ": { tip: articulatorPlacement["ɛ"].tip, mistake: "Jaw too open and drifts toward /æ/.", ipa: "/ɛ/ (bed)" },
  "æ": { tip: articulatorPlacement["æ"].tip, mistake: "Too closed; drifts toward /ɛ/.", ipa: "/æ/ (cat)" },
  "ɑ": { tip: articulatorPlacement["ɑ"].tip, mistake: "Lips round too much; drifts toward /ɔ/.", ipa: "/ɑ/ (father)" },
  "ɔ": { tip: articulatorPlacement["ɔ"].tip, mistake: "Often merges with /ɑ/ depending on accent.", ipa: "/ɔ/ (thought)" },
  o: { tip: articulatorPlacement.o.tip, mistake: "Glide is missing; can sound flat.", ipa: "/o/ (go-start)" },
  "ʊ": { tip: articulatorPlacement["ʊ"].tip, mistake: "Becomes too tense and turns into /u/.", ipa: "/ʊ/ (book)" },
  u: { tip: articulatorPlacement.u.tip, mistake: "Tongue too low; sounds like /ʊ/.", ipa: "/u/ (food)" },
  "ʌ": { tip: articulatorPlacement["ʌ"].tip, mistake: "Turns into schwa /ə/ when stressed.", ipa: "/ʌ/ (cup)" },
  "ə": { tip: articulatorPlacement["ə"].tip, mistake: "Made too long or too strong (schwa should be quick).", ipa: "/ə/ (about)" },
  "ɝ": { tip: articulatorPlacement["ɝ"].tip, mistake: "R-color is missing; sounds like a plain vowel.", ipa: "/ɝ/ (bird)" },
  "ɚ": { tip: articulatorPlacement["ɚ"].tip, mistake: "R-color is missing; becomes plain schwa.", ipa: "/ɚ/ (teacher, end)" },

  // Diphthongs
  "eɪ": { tip: articulatorPlacement["eɪ"].tip, mistake: "Glide is missing; can sound too short.", ipa: "/eɪ/ (day)" },
  "aɪ": { tip: articulatorPlacement["aɪ"].tip, mistake: "Doesn’t rise enough; sounds too flat.", ipa: "/aɪ/ (my)" },
  "ɔɪ": { tip: articulatorPlacement["ɔɪ"].tip, mistake: "Glide is weak; sounds like a plain vowel.", ipa: "/ɔɪ/ (boy)" },
  "aʊ": { tip: articulatorPlacement["aʊ"].tip, mistake: "Second part is too tense and becomes /u/.", ipa: "/aʊ/ (now)" },
  "oʊ": { tip: articulatorPlacement["oʊ"].tip, mistake: "Glide is missing; sounds too flat.", ipa: "/oʊ/ (go)" },
};

/* Map coaching details by canonical IPA */
export const phonemeDetailsByIPA = Object.create(null);
Object.entries(phonemeDetails).forEach(([k, v]) => {
  phonemeDetailsByIPA[norm(k)] = v;
});

/** Safe accessor (works with Azure codes, IPA, tie-bars, etc.). */
export function getPhonemeDetails(symbol) {
  return phonemeDetailsByIPA[norm(symbol)] || null;
}

/* ---------- Misc ---------- */
export const ytLink = "https://youtu.be/y-k8sDRto9s";

/* =========================================================================
   Suggestions / future upgrades (non-breaking ideas)
   1) Add a “tech side” map:
      - export const articulatorPlacementTech = { ... };
      - same keys (canonical IPA), but with full place/manner jargon.
   2) Add a tiny runtime self-check (dev-only):
      - import { getPhonemeAssetByIPA } and log any IPA that has video but
        missing articulatorPlacement entry (or vice versa).
   3) UI: flip-card tooltip
      - Front: articulatorPlacement (plain)
      - Back: articulatorPlacementTech (technical) + “front-of-mouth” video
   ========================================================================= */
</file>

<file path="src/supabase.js">
import { createClient } from '@supabase/supabase-js';

// Load keys from .env
const SUPABASE_URL = import.meta.env.VITE_SUPABASE_URL;
const SUPABASE_KEY = import.meta.env.VITE_SUPABASE_ANON_KEY;

if (!SUPABASE_URL || !SUPABASE_KEY) {
  console.error('[Lux] Missing Supabase keys in .env');
}

export const supabase = createClient(SUPABASE_URL, SUPABASE_KEY);

/**
 * Returns the Canonical User ID.
 * Priority:
 * 1. Authenticated User ID (if logged in)
 * 2. Guest ID (from localStorage)
 * 3. Null (creates new Guest ID upstream)
 */
export async function getCanonicalUID() {
  const { data } = await supabase.auth.getUser();
  
  if (data?.user?.id) {
    return data.user.id;
  }
  
  // Fallback to Guest ID
  if (window.LUX_USER_ID) {
    return window.LUX_USER_ID;
  }
  
  return null;
}
</file>

<file path="ui/auth-dom.js">
import { supabase } from "../src/supabase.js";
import { API_BASE } from "/src/api/util.js";

export function initAuthUI() {
  renderAuthButton();
  handleAuthStateChange();
}

// 1. Render Top-Right Button
function renderAuthButton() {
  if (document.getElementById("lux-auth-btn")) return;

  const btn = document.createElement("button");
  btn.id = "lux-auth-btn";
  
btn.style.cssText = `
  position: fixed; top: 16px; right: 16px;
  z-index: 900; padding: 8px 16px;
  background: #fff; border: 1px solid #cbd5e1; border-radius: 20px;
  color: #475569; font-size: 0.85rem; font-weight: 700;
  cursor: pointer; box-shadow: 0 2px 5px rgba(0,0,0,0.05);
  transition: all 0.2s; display: flex; align-items: center; gap: 6px;
`;

  
  btn.onmouseover = () => { btn.style.transform = "translateY(-1px)"; btn.style.boxShadow = "0 4px 8px rgba(0,0,0,0.1)"; };
  btn.onmouseout = () => { btn.style.transform = "translateY(0)"; btn.style.boxShadow = "0 2px 5px rgba(0,0,0,0.05)"; };

  btn.textContent = "💾 Save Progress";
  btn.onclick = openLoginModal;
  document.body.appendChild(btn);
}

// 2. Login Modal
function openLoginModal() {
  if (document.getElementById("lux-auth-modal")) return;

  const modal = document.createElement("div");
  modal.id = "lux-auth-modal";
  modal.style.cssText = `
    position: fixed; inset: 0; z-index: 1000;
    background: rgba(0,0,0,0.5); backdrop-filter: blur(3px);
    display: flex; align-items: center; justify-content: center;
    animation: fadeIn 0.2s ease-out;
  `;
  
  if (!document.getElementById("auth-anim")) {
    const s = document.createElement("style");
    s.id = "auth-anim";
    s.textContent = `@keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }`;
    document.head.appendChild(s);
  }

  modal.innerHTML = `
    <div style="background:#fff; padding:24px; border-radius:16px; width:90%; max-width:340px; text-align:center; box-shadow:0 10px 25px rgba(0,0,0,0.2); position:relative;">
      <button id="lux-auth-close" style="position:absolute; top:12px; right:12px; border:none; background:none; font-size:1.2rem; cursor:pointer; color:#94a3b8;">&times;</button>
      
      <h3 style="margin:0 0 8px 0; color:#1e293b; font-size:1.4rem;">Save Your Progress</h3>
      <p style="font-size:0.95em; color:#64748b; margin-bottom:24px; line-height:1.5;">
        Sign in to keep your history safe and access it from any device.
      </p>
      
      <input type="email" id="lux-auth-email" placeholder="name@email.com" 
        style="width:100%; padding:12px; border:1px solid #cbd5e1; border-radius:8px; margin-bottom:16px; font-size:1rem; box-sizing:border-box;">
        
      <button id="lux-auth-submit" style="width:100%; padding:12px; background:#0078d7; color:#fff; border:none; border-radius:8px; font-weight:700; font-size:1rem; cursor:pointer; transition:background 0.2s;">
        Send Magic Link 🪄
      </button>
      
      <div style="margin-top:16px; font-size:0.8rem; color:#94a3b8;">
        We'll email you a login link. No password needed.
      </div>
    </div>
  `;
  
  document.body.appendChild(modal);
  
  document.getElementById("lux-auth-close").onclick = () => modal.remove();
  
  document.getElementById("lux-auth-submit").onclick = async () => {
    const email = document.getElementById("lux-auth-email").value.trim();
    const btn = document.getElementById("lux-auth-submit");
    
    if(!email || !email.includes("@")) return alert("Please enter a valid email address.");
    
    btn.textContent = "Sending...";
    btn.disabled = true;
    btn.style.opacity = "0.7";
    
    const { error } = await supabase.auth.signInWithOtp({ 
        email,
        options: { emailRedirectTo: window.location.origin }
    });
    
    if (error) {
      alert("Login Error: " + error.message);
      btn.textContent = "Try Again";
      btn.disabled = false;
      btn.style.opacity = "1";
    } else {
      modal.querySelector("div").innerHTML = `
        <div style="padding:20px;">
          <div style="font-size:3rem; margin-bottom:16px;">📧</div>
          <h3 style="color:#10b981; margin:0 0 12px 0;">Check your email!</h3>
          <p style="color:#475569; margin-bottom:20px; line-height:1.5;">
            We sent a magic link to <strong>${email}</strong>.<br>
            Click it to log in.
          </p>
          <button onclick="document.getElementById('lux-auth-modal').remove()" 
            style="padding:10px 24px; background:#f1f5f9; border:none; border-radius:8px; color:#475569; font-weight:600; cursor:pointer;">
            Close
          </button>
        </div>
      `;
    }
  };
}

// 3. Auth State Handler + Migration Trigger
function handleAuthStateChange() {
  supabase.auth.onAuthStateChange(async (event, session) => {
    const btn = document.getElementById("lux-auth-btn");
    if (!btn) return;

    if (session?.user) {
      // LOGGED IN
      const email = session.user.email;
      const name = email.split("@")[0];
      const realUid = session.user.id;
      
      btn.textContent = `👤 ${name}`;
      btn.style.borderColor = "#bbf7d0";
      btn.style.background = "#f0fdf4";
      btn.style.color = "#166534";
      
      btn.onclick = () => {
        if(confirm(`Signed in as ${email}.\n\nDo you want to log out?`)) {
          supabase.auth.signOut();
          window.location.reload(); // Hard reload to clear state
        }
      };
      
      // --- THE MIGRATION CHECK ---
      const guestUid = localStorage.getItem("LUX_USER_ID");
      
      // If we have a guest ID, and it's NOT the same as our new Real ID, migrate!
      if (guestUid && guestUid !== realUid) {
          console.log("[Auth] Migrating guest history...", guestUid, "->", realUid);
          await migrateHistory(guestUid, realUid);
      }

      // Update global ID to the Real ID
      window.LUX_USER_ID = realUid;
      localStorage.setItem("LUX_USER_ID", realUid); // Persist the Real ID

      // Refresh Dashboard
      if (window.refreshDashboard) window.refreshDashboard();
      else {
          import('../features/dashboard/index.js').then(mod => {
              if (mod.refreshHistory) mod.refreshHistory();
          });
      }
      
    } else {
      // LOGGED OUT / GUEST
      btn.textContent = "💾 Save Progress";
      btn.style.borderColor = "#cbd5e1";
      btn.style.background = "#fff";
      btn.style.color = "#475569";
      btn.onclick = openLoginModal;
    }
  });
}

// 4. Migration API Call
async function migrateHistory(guestUid, userUid) {
    try {
        const res = await fetch(`${API_BASE}/api/migrate`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ guestUid, userUid })
        });
        const data = await res.json();
        console.log("[Auth] Migration result:", data);
    } catch (e) {
        console.error("[Auth] Migration failed:", e);
    }
}
</file>

<file path="ui/ui-arrow-trail.css">
.lux-arrow-trail{
  display: inline-flex;
  gap: 6px;
  margin-left: 6px;
  vertical-align: middle;
  user-select: none;
  white-space: nowrap;
  position: relative;
}
/* Click affordance */
.lux-arrow-trail,
.lux-arrow-trail .lux-arrow,
.lux-arrow-trail .lux-arrow-glyph{
  cursor: pointer;
}


.lux-arrow{
  display: inline-block;
  will-change: transform, opacity;
  transform: translateY(0) scale(1);
}

/* Main sweep (always running) */
.lux-arrow-trail.is-animating .lux-arrow{
  animation: luxArrowHead var(--luxTrailDur, 2.8s) linear infinite;
  animation-delay: var(--luxDelay, 0s);
}

/* Inner glyph so hover wave can animate translateY without fighting the sweep */
.lux-arrow-glyph{
  display: inline-block;
  will-change: transform;
  transform: translateY(0);
}

/* Hover-only wave (left→right ripple) */
.lux-arrow-trail:hover .lux-arrow-glyph{
  animation: luxArrowWave var(--luxWaveDur, 1.4s) ease-in-out infinite;
  animation-delay: var(--luxWaveDelay, 0s);
}

/* Last arrow baseline emphasis (STATIC only — no extra animation => no flash) */
.lux-arrow.is-last{
  opacity: 0.45 !important;
}

/* When the last arrow “launches”, we hide its in-trail copy */
.lux-arrow.is-launched{
  visibility: hidden !important;
}

/* The flying arrow (fixed to viewport so getBoundingClientRect coords are easy) */
.lux-arrow-fly{
  position: fixed;
  left: 0;
  top: 0;
  transform: translate(-50%, -50%);
  pointer-events: none;
  user-select: none;
  z-index: 9999;
  will-change: transform, opacity;
  opacity: 0.95;
}

/* Faint pop ring at landing point */
.lux-arrow-pop{
  position: fixed;
  left: 0;
  top: 0;
  width: 10px;
  height: 10px;
  transform: translate(-50%, -50%);
  border-radius: 999px;
  border: 2px solid rgba(0,0,0,0.18);
  pointer-events: none;
  z-index: 9999;
  animation: luxPopRing 520ms ease-out forwards;
  will-change: transform, opacity;
  opacity: 0.8;
}

@keyframes luxArrowHead{
  0%   { opacity: 0.22; transform: translateY(0) scale(1); }
  35%  { opacity: 0.78; transform: translateY(-0.5px) scale(1.03); }
  70%  { opacity: 0.28; transform: translateY(0) scale(1); }
  100% { opacity: 0.22; transform: translateY(0) scale(1); }
}

@keyframes luxArrowWave{
  0%,100% { transform: translateY(0); }
  50%     { transform: translateY(-2px); }
}

@keyframes luxPopRing{
  0%   { opacity: 0.65; transform: translate(-50%, -50%) scale(0.6); }
  70%  { opacity: 0.25; transform: translate(-50%, -50%) scale(2.4); }
  100% { opacity: 0;    transform: translate(-50%, -50%) scale(3.0); }
}

/* Respect reduced motion */
@media (prefers-reduced-motion: reduce){
  .lux-arrow-trail.is-animating .lux-arrow,
  .lux-arrow-trail:hover .lux-arrow-glyph{
    animation: none !important;
  }
}
</file>

<file path="ui/ui-arrow-trail.js">
// ui/ui-arrow-trail.js
export function initArrowTrail(opts = {}) {
  const host = document.querySelector('[data-arrow-trail="tts"]');
  if (!host) return;
  if (host.dataset.init === "yes") return;
  host.dataset.init = "yes";

  // --- Tunables ---
  const count = Number.isFinite(opts.count) ? opts.count : 14;
  const durationSec = Number.isFinite(opts.durationSec) ? opts.durationSec : 2.8;
  const waveDurationSec = Number.isFinite(opts.waveDurationSec) ? opts.waveDurationSec : 1.4;

  // "Leaf drift" timing: duration depends on distance
  const flyMsBase = Number.isFinite(opts.flyMsBase) ? opts.flyMsBase : 1400;
  const flyMsPerPx = Number.isFinite(opts.flyMsPerPx) ? opts.flyMsPerPx : 1.1;
  const flyMsMin = Number.isFinite(opts.flyMsMin) ? opts.flyMsMin : 1800;
  const flyMsMax = Number.isFinite(opts.flyMsMax) ? opts.flyMsMax : 3600;

  const landHoldMs = Number.isFinite(opts.landHoldMs) ? opts.landHoldMs : 900;

  // Strongest option: provide a single selector that points to the TTS handle/tab
  // (works if it's the SAME element in open/closed and just moves)
  const targetSelector = opts.targetSelector || null;

  // If you DO have separate handles for open/closed:
  const closedSel = opts.ttsClosedSelector || null;
  const openSel = opts.ttsOpenSelector || null;

  // Optional small adjustment once target is correct
  const offsetX = Number.isFinite(opts.targetOffsetX) ? opts.targetOffsetX : 0;
  const offsetY = Number.isFinite(opts.targetOffsetY) ? opts.targetOffsetY : 0;

  const debug = !!opts.debug;

  const prefersReducedMotion =
    typeof window !== "undefined" &&
    window.matchMedia &&
    window.matchMedia("(prefers-reduced-motion: reduce)").matches;

  host.innerHTML = "";

  for (let i = 0; i < count; i++) {
    const outer = document.createElement("span");
    outer.className = "lux-arrow";

    const inner = document.createElement("span");
    inner.className = "lux-arrow-glyph";
    inner.textContent = "→";

    outer.appendChild(inner);
    host.appendChild(outer);
  }

  const arrows = Array.from(host.querySelectorAll(".lux-arrow"));
  const n = arrows.length || 1;

  // Phase-lock sweep
  host.style.setProperty("--luxTrailDur", `${durationSec}s`);
  const step = durationSec / n;

  // Phase-lock hover wave
  host.style.setProperty("--luxWaveDur", `${waveDurationSec}s`);
  const waveStep = waveDurationSec / n;

  arrows.forEach((outer, i) => {
    outer.style.setProperty("--luxDelay", `${i * step}s`);

    const inner = outer.querySelector(".lux-arrow-glyph");
    if (inner) inner.style.setProperty("--luxWaveDelay", `${i * waveStep}s`);

    const base = 0.22 + (i / Math.max(1, n - 1)) * 0.16;
    outer.style.opacity = String(base);
  });

  const last = arrows[arrows.length - 1];
  if (last) last.classList.add("is-last");
  host.classList.add("is-animating");

  // --- Hover-triggered launch ---
  let hoverTimer = null;
  let launchedThisHover = false;
  let inFlight = false;

  // NEW: auto-run once on page load / init
  let autoTimer = null;
  let autoHasRun = false;

  let flyEl = null;
  let flyAnim = null;
  let lastLaunchedEl = null;

  let debugDot = null;

  host.addEventListener("mouseenter", () => {
    if (prefersReducedMotion) return;
    if (inFlight) return;

    launchedThisHover = false;
    clearTimeout(hoverTimer);

    const lastArrow = host.querySelector(".lux-arrow.is-last");
    if (!lastArrow) return;

    // When the wave reaches the last arrow (approx peak)
    const peakSec = ((n - 1) * waveStep) + (waveDurationSec * 0.5);
    hoverTimer = window.setTimeout(() => {
      if (!host.matches(":hover")) return;
      if (launchedThisHover) return;
      launchedThisHover = true;
      launchLastArrow(lastArrow);
    }, Math.max(0, peakSec * 1000));
  });

  host.addEventListener("mouseleave", () => {
    clearTimeout(hoverTimer);
    hoverTimer = null;
    launchedThisHover = false;

    // NEW: optional tidy cleanup for the one-shot timer
    if (autoTimer) { clearTimeout(autoTimer); autoTimer = null; }

    cleanupFlight();
  });

  // --- Click-triggered launch (click ANY arrow => launch last arrow) ---
  host.addEventListener("click", (e) => {
    if (prefersReducedMotion) return;
    if (inFlight) return;

    // Only trigger when the click lands on an arrow (or its inner glyph)
    const hit = e.target && e.target.closest ? e.target.closest(".lux-arrow") : null;
    if (!hit) return;

    // If you do NOT want this click to also toggle/open something else upstream,
    // keep these. If you *do* want parent click handlers to run, delete these two lines.
    e.preventDefault();
    e.stopPropagation();

    // Cancel pending hover/auto launches so we don't double-fire
    clearTimeout(hoverTimer);
    hoverTimer = null;
    launchedThisHover = true;

    if (autoTimer) { clearTimeout(autoTimer); autoTimer = null; }
    autoHasRun = true;

    const lastArrow = host.querySelector(".lux-arrow.is-last");
    if (!lastArrow) return;

    launchLastArrow(lastArrow);
  });

  // NEW: Auto-run once after init, even without hover
  if (!prefersReducedMotion) {
    const autoRunMs = Number.isFinite(opts.autoRunMs) ? opts.autoRunMs : 7000;
    const autoRunOnce = opts.autoRunOnce !== false; // default true

    if (autoRunOnce && !autoHasRun) {
      autoTimer = window.setTimeout(() => {
        if (inFlight) return;

        const lastArrow = host.querySelector(".lux-arrow.is-last");
        if (!lastArrow) return;

        autoHasRun = true;
        launchLastArrow(lastArrow);
      }, autoRunMs);
    }
  }

  function cleanupFlight() {
    inFlight = false;

    // NEW: tidy cleanup for the one-shot timer
    if (autoTimer) { clearTimeout(autoTimer); autoTimer = null; }

    if (flyAnim) {
      try { flyAnim.cancel(); } catch {}
      flyAnim = null;
    }
    if (flyEl && flyEl.parentNode) {
      flyEl.parentNode.removeChild(flyEl);
      flyEl = null;
    }
    if (lastLaunchedEl) {
      lastLaunchedEl.classList.remove("is-launched");
      lastLaunchedEl = null;
    }
    if (debugDot && debugDot.parentNode) {
      debugDot.parentNode.removeChild(debugDot);
      debugDot = null;
    }
  }

  function isVisible(el) {
    if (!el) return false;
    const rects = el.getClientRects();
    if (!rects || rects.length === 0) return false;
    const cs = window.getComputedStyle(el);
    if (cs.display === "none" || cs.visibility === "hidden" || Number(cs.opacity) === 0) return false;
    return true;
  }

  function pickVisible(sel) {
    if (!sel) return null;
    const el = document.querySelector(sel);
    return isVisible(el) ? el : null;
  }

  function clamp(v, lo, hi) {
    return Math.max(lo, Math.min(hi, v));
  }

  function parseRGB(rgbStr) {
    // "rgb(r, g, b)" or "rgba(r, g, b, a)"
    const m = rgbStr && rgbStr.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/i);
    if (!m) return null;
    return { r: Number(m[1]), g: Number(m[2]), b: Number(m[3]) };
  }

  function scoreCandidate(el, startX, startY) {
    if (!isVisible(el)) return -Infinity;

    const r = el.getBoundingClientRect();
    if (r.width < 10 || r.height < 10) return -Infinity;

    const cs = window.getComputedStyle(el);
    let score = 0;

    // Prefer fixed/sticky UI handles
    if (cs.position === "fixed") score += 40;
    if (cs.position === "sticky") score += 20;

    // Prefer near the right edge (tabs on the right)
    const distRight = Math.abs(window.innerWidth - r.right);
    score += Math.max(0, 60 - distRight);

    // Prefer roughly aligned vertically with the arrow trail
    const midY = r.top + r.height / 2;
    score += Math.max(0, 30 - Math.abs(midY - startY) * 0.08);

    // Prefer ids/classes suggesting tab/peek/tts
    const tag = `${el.id || ""} ${(el.className && String(el.className)) || ""}`.toLowerCase();
    if (tag.includes("tts")) score += 30;
    if (tag.includes("tab") || tag.includes("peek") || tag.includes("handle") || tag.includes("drawer")) score += 18;

    // Prefer bluish background (your tab/handle is blue)
    const bg = cs.backgroundColor;
    const rgb = parseRGB(bg);
    if (rgb && rgb.b > 140 && (rgb.b > rgb.r + 20) && (rgb.b > rgb.g + 20)) score += 22;

    // Slight preference for “pill-like” sizes
    const area = r.width * r.height;
    if (area > 1200 && area < 60000) score += 10;

    return score;
  }

  function findBestTarget(startX, startY) {
    // 1) Explicit selector wins
    const explicit = pickVisible(targetSelector);
    if (explicit) return explicit;

    // 2) open/closed selectors (if provided)
    const openEl = pickVisible(openSel);
    if (openEl) return openEl;

    const closedEl = pickVisible(closedSel);
    if (closedEl) return closedEl;

    // 3) Heuristic scan: look for TTS-ish, tab-ish, and fixed elements
    const candidates = new Set();

    const root = document.querySelector("#tts-controls");
    if (root) {
      root.querySelectorAll("*").forEach((el) => candidates.add(el));
    }

    // Broad scan of likely suspects (cheap enough, UI is small)
    document.querySelectorAll(
      '[id*="tts"], [class*="tts"], [data-tts], [aria-label*="TTS"], [aria-label*="text"], [title*="TTS"], [class*="peek"], [class*="tab"], [class*="handle"]'
    ).forEach((el) => candidates.add(el));

    let best = null;
    let bestScore = -Infinity;
    for (const el of candidates) {
      const s = scoreCandidate(el, startX, startY);
      if (s > bestScore) {
        bestScore = s;
        best = el;
      }
    }
    return best;
  }

  function getTipPoint(el) {
    const r = el.getBoundingClientRect();

    // If we're targeting the TTS handle pill, always land on its INNER rounded tip.
    // For a right-side pill, the "tip" is its LEFT edge.
    if (el.matches && el.matches("button.lux-tts-tab")) {
      let x = r.left + 1 + offsetX;              // leftmost pixel-ish
      let y = r.top + r.height / 2 + offsetY;    // vertical center
      return { x, y };
    }

    // We want the "point" / rounded end of the tab.
    // Your TTS handle is a pill near the RIGHT edge, with the rounded end on the LEFT (inner) side.
    // The previous edgePad=10 was too strict, so it fell back to center.
    const edgePad = 70; // <-- bigger threshold so we treat "near right edge" as right-edge UI

    let x = r.left + (r.width / 2);
    let y = r.top + (r.height / 2);

    const distRight = Math.abs(window.innerWidth - r.right);
    const distLeft  = Math.abs(r.left);

    if (distRight < edgePad) {
      // Right-edge handle: target the INNER rounded tip (left edge)
      x = r.left + Math.min(8, r.width * 0.12);
      y = r.top + r.height / 2;
    } else if (distLeft < edgePad) {
      // Left-edge handle: target its inner tip (right edge)
      x = r.right - Math.min(8, r.width * 0.12);
      y = r.top + r.height / 2;
    } else {
      // Fallback center
      x = r.left + r.width / 2;
      y = r.top + r.height / 2;
    }

    // Optional fine-tune from initArrowTrail({...})
    x += offsetX;
    y += offsetY;

    const margin = 8;
    x = clamp(x, margin, window.innerWidth - margin);
    y = clamp(y, margin, window.innerHeight - margin);

    return { x, y };
  }

  function showDebugDot(x, y) {
    if (!debug) return;
    if (debugDot && debugDot.parentNode) debugDot.parentNode.removeChild(debugDot);

    debugDot = document.createElement("div");
    debugDot.style.position = "fixed";
    debugDot.style.left = `${x}px`;
    debugDot.style.top = `${y}px`;
    debugDot.style.width = "8px";
    debugDot.style.height = "8px";
    debugDot.style.borderRadius = "999px";
    debugDot.style.transform = "translate(-50%, -50%)";
    debugDot.style.background = "rgba(255, 0, 0, 0.55)";
    debugDot.style.zIndex = "9999";
    debugDot.style.pointerEvents = "none";
    document.body.appendChild(debugDot);
  }

  function launchLastArrow(lastArrowEl) {
    if (inFlight) return;

    const glyph = lastArrowEl.querySelector(".lux-arrow-glyph") || lastArrowEl;
    const startRect = glyph.getBoundingClientRect();

    const startX = startRect.left + (startRect.width / 2);
    const startY = startRect.top + (startRect.height / 2);

    const targetEl = findBestTarget(startX, startY);
    if (!targetEl) return;

    const { x: endX, y: endY } = getTipPoint(targetEl);

    showDebugDot(endX, endY);

    // Hide in-trail copy
    lastArrowEl.classList.add("is-launched");
    lastLaunchedEl = lastArrowEl;

    // Create flying arrow clone
    flyEl = document.createElement("span");
    flyEl.className = "lux-arrow-fly";
    flyEl.textContent = "→";
    flyEl.style.left = `${startX}px`;
    flyEl.style.top = `${startY}px`;
    document.body.appendChild(flyEl);

    inFlight = true;

    const dx = endX - startX;
    const dy = endY - startY;

    const len = Math.max(1, Math.hypot(dx, dy));

    // Perpendicular unit vector for swirly drift
    const px = (-dy / len);
    const py = (dx / len);

    // Gentle swirl amplitude
    const amp = clamp(len * 0.14, 22, 64);

    // Final rotation aims at target
    const finalDeg = Math.atan2(dy, dx) * 180 / Math.PI;

    // Build a multi-keyframe “leaf drift” path.
    // Two oscillations that decay as it approaches the destination.
    const frames = [];
    const steps = 16; // more steps => smoother drift
    const freq = 2.1;

    // --- NEW: per-launch randomness (subtle) ---
    const rand = (min, max) => min + Math.random() * (max - min);

    // Slightly vary the path each time
    const freqJ = freq + rand(-0.35, 0.35);          // frequency jitter
    const ampJ  = amp * rand(0.85, 1.15);            // amplitude jitter
    const phase = rand(0, Math.PI * 2);              // phase offset
    const floatJ = rand(6, 14);                      // float intensity
    const gust = rand(0.85, 1.15);                   // duration wobble feel

    // Distance-based duration => "leaf drift" (slow)
    const flyMs = clamp((flyMsBase + len * flyMsPerPx) * gust, flyMsMin, flyMsMax);

    for (let i = 0; i <= steps; i++) {
      const t = i / steps;

      // Decay toward end (0..1)
      const decay = (1 - t);

      // Side-to-side drift (perpendicular)
      const wobble = Math.sin((t * Math.PI * 2) * freqJ + phase) * ampJ * decay;

      // A tiny vertical float (feels like wind)
      const float = Math.cos((t * Math.PI * 2) * (freqJ * 0.8) + phase * 0.6) * floatJ * decay;

      const x = dx * t + px * wobble;
      const y = dy * t + py * wobble + float;

      const rot = finalDeg * t;
      const sc = 1 + (0.06 * decay);

      const op = 0.95 - (0.10 * t);

      frames.push({
        transform: `translate(-50%, -50%) translate(${x}px, ${y}px) rotate(${rot}deg) scale(${sc})`,
        opacity: op
      });
    }

    flyAnim = flyEl.animate(frames, {
      duration: flyMs,
      easing: "ease-in-out",
      fill: "forwards"
    });

    flyAnim.onfinish = () => {
      window.setTimeout(() => {
        if (!flyEl) return;

        // Pop ring
        const pop = document.createElement("div");
        pop.className = "lux-arrow-pop";
        pop.style.left = `${endX}px`;
        pop.style.top = `${endY}px`;
        document.body.appendChild(pop);

        // Fade out arrow
        flyEl.animate(
          [{ opacity: 0.85 }, { opacity: 0.0 }],
          { duration: 280, easing: "ease-out", fill: "forwards" }
        );

        window.setTimeout(() => {
          if (pop.parentNode) pop.parentNode.removeChild(pop);
          cleanupFlight();
        }, 560);
      }, landHoldMs);
    };
  }
}
</file>

<file path="ui/ui-ripple-filter.js">
// ui/ui-ripple-filter.js
// SVG displacement ripple for any element with [data-lux-ripple]
// No external images. No GSAP.

const SVG_NS = "http://www.w3.org/2000/svg";

function ensureHiddenSvgHost() {
  let host = document.getElementById("luxRippleSvgHost");
  if (host) return host;

  host = document.createElementNS(SVG_NS, "svg");
  host.setAttribute("id", "luxRippleSvgHost");
  host.setAttribute("aria-hidden", "true");
  host.setAttribute("focusable", "false");
  host.style.position = "absolute";
  host.style.width = "0";
  host.style.height = "0";
  host.style.overflow = "hidden";

  const defs = document.createElementNS(SVG_NS, "defs");
  host.appendChild(defs);

  document.body.prepend(host);
  return host;
}

function makeFilter(defs, id) {
  const filter = document.createElementNS(SVG_NS, "filter");
  filter.setAttribute("id", id);
  filter.setAttribute("x", "-20%");
  filter.setAttribute("y", "-20%");
  filter.setAttribute("width", "140%");
  filter.setAttribute("height", "140%");
  filter.setAttribute("color-interpolation-filters", "sRGB");

  // Built-in noise source (replaces feImage)
  const turb = document.createElementNS(SVG_NS, "feTurbulence");
  turb.setAttribute("type", "fractalNoise");
  turb.setAttribute("baseFrequency", "0.012 0.02");
  turb.setAttribute("numOctaves", "1");
  turb.setAttribute("seed", String(Math.floor(Math.random() * 9999)));
  turb.setAttribute("result", "noise");

  const disp = document.createElementNS(SVG_NS, "feDisplacementMap");
  disp.setAttribute("in", "SourceGraphic");
  disp.setAttribute("in2", "noise");
  disp.setAttribute("scale", "0");
  disp.setAttribute("xChannelSelector", "R");
  disp.setAttribute("yChannelSelector", "G");
  disp.setAttribute("result", "displaced");

  filter.appendChild(turb);
  filter.appendChild(disp);
  defs.appendChild(filter);

  return { filter, turb, disp };
}

function easeOutCubic(t) {
  return 1 - Math.pow(1 - t, 3);
}

function lerp(a, b, t) {
  return a + (b - a) * t;
}

function attachRipple(el) {
  const host = ensureHiddenSvgHost();
  const defs = host.querySelector("defs");

  const id = `luxRipple_${Math.random().toString(16).slice(2)}`;
  const { turb, disp } = makeFilter(defs, id);

  // Apply SVG filter to this element only
  el.style.filter = `url(#${id})`;

  let raf = 0;
  let animating = false;
  let start = 0;

  function stop() {
    if (raf) cancelAnimationFrame(raf);
    raf = 0;
    animating = false;
    disp.setAttribute("scale", "0");
  }

  function play() {
    if (animating) return;
    animating = true;
    start = performance.now();

    const DURATION = 520;      // ms
    const PEAK = 18;           // max displacement scale
    const BF0 = 0.010;         // base frequency low
    const BF1 = 0.030;         // base frequency high

    const tick = (now) => {
      const t = Math.min(1, (now - start) / DURATION);
      const e = easeOutCubic(t);

      // Make a "pulse": up then down
      // sin(pi*t) gives 0->1->0
      const pulse = Math.sin(Math.PI * e);

      const scale = PEAK * pulse;
      disp.setAttribute("scale", scale.toFixed(2));

      // Slightly vary turbulence for a livelier ripple
      const bf = lerp(BF0, BF1, pulse);
      turb.setAttribute("baseFrequency", `${bf.toFixed(3)} ${(bf * 1.6).toFixed(3)}`);

      if (t < 1) {
        raf = requestAnimationFrame(tick);
      } else {
        stop();
      }
    };

    raf = requestAnimationFrame(tick);
  }

  // Hover/focus triggers
  el.addEventListener("pointerenter", play);
  el.addEventListener("focus", play);

  // If you want it to stop immediately on leave/blur:
  el.addEventListener("pointerleave", () => {
    // let it finish naturally, or uncomment to snap off:
    // stop();
  });
  el.addEventListener("blur", () => {
    // stop();
  });
}

export function bootRippleButtons(root = document) {
  const els = Array.from(root.querySelectorAll("[data-lux-ripple]"));
  els.forEach(attachRipple);
}
</file>

<file path="ui/ui-shell-typing.js">
// ui/ui-shell-typing.js
// Rotating placeholder + one-time typewriter prompt
// Exported API: initUI()

export function initUI() {
  const refInput = document.getElementById("referenceText");
  const typingEl = document.getElementById("typewriterMsg");
  if (!refInput || !typingEl) return;

  // If we've already wired this once, bail (prevents duplicate typewriter)
  if (typingEl.dataset.typingAttached === "true") return;
  typingEl.dataset.typingAttached = "true"; // <— signal to other modules

  // Rotating placeholder messages
  const messages = [
    "Type something, then practice saying it",
    "Select a sound designed option",
    "Read how to make the sounds in the results",
    "Watch videos for correct tongue and lip placement",
    "Read the A.I. feedback analysis",
    "See a detailed video lesson!",
  ];
  let idx = 0;

  function rotate() {
    refInput.setAttribute("placeholder", messages[idx]);
    idx = (idx + 1) % messages.length;
  }
  const rotateTimer = setInterval(rotate, 3500);
  rotate();

  // One-time typewriter prompt
  const TYPE_LINE =
    "Here you can type whatever you want to practice saying, then press Record⬇️, or you can select a passage above ↖️";

  function typeWriter(i = 0) {
    if (i === 0) typingEl.textContent = ""; // ensure fresh start
    if (i < TYPE_LINE.length) {
      typingEl.textContent += TYPE_LINE.charAt(i);
      setTimeout(() => typeWriter(i + 1), 35);
    }
  }

  function onFirstFocus() {
    clearInterval(rotateTimer);
    refInput.removeEventListener("focus", onFirstFocus);
    typingEl.classList.remove("hidden");
    typingEl.style.opacity = "1";
    typeWriter();
    refInput.classList.add("placeholder-fade");
    setTimeout(() => refInput.setAttribute("placeholder", ""), 500);
  }

  function fadePrompt() {
    if (typingEl.style.opacity !== "0") {
      typingEl.style.opacity = "0";
      setTimeout(() => typingEl.classList.add("hidden"), 600);
    }
  }

  refInput.addEventListener("focus", onFirstFocus, { once: true });
  refInput.addEventListener("input", fadePrompt);

  // ---- NEW: auto-switch passage to "Write your own" on first focus --------
  (function ensureCustomWhenTyping() {
    const sel = document.getElementById("passageSelect");
    if (!sel) return;

    // Ensure there is a visible "custom" option
    if (!sel.querySelector('option[value="custom"]')) {
      const opt = document.createElement("option");
      opt.value = "custom";
      opt.textContent = "Write your own";
      sel.appendChild(opt);
    }

    const goCustom = () => {
      if (sel.value !== "custom") {
        sel.value = "custom";
        sel.dispatchEvent(new Event("change", { bubbles: true }));
      }
    };
    // Attach once, same timing as typewriter kick-off
    refInput.addEventListener("focus", goCustom, { once: true });
  })();
}
</file>

<file path="ui/warp-core.js">
// ui/warp-core.js — core warp overlay helpers (tiny + reusable)
const KEY = "luxWarpNext";

function reducedMotion(){
  return window.matchMedia && window.matchMedia("(prefers-reduced-motion: reduce)").matches;
}

export function ensureWarpOverlay(){
  if (document.getElementById("lux-warp")) return;
  const el = document.createElement("div");
  el.id = "lux-warp";
  document.body.appendChild(el);
}

function show(cls){
  const el = document.getElementById("lux-warp");
  el.classList.remove("is-in", "is-out");
  el.classList.add("is-on", cls);
  el.style.opacity = ""; // let animation run
  el.style.display = "block";
}

function hide(){
  const el = document.getElementById("lux-warp");
  el.classList.remove("is-on", "is-in", "is-out");
  el.style.display = "none";
  el.style.opacity = "0";
}

export function warpOut(outMs = 220){
  ensureWarpOverlay();
  if (reducedMotion()) return Promise.resolve();
  show("is-out");
  return new Promise((r) => setTimeout(r, outMs));
}

export function warpIn(inMs = 260){
  ensureWarpOverlay();
  if (reducedMotion()) { hide(); return Promise.resolve(); }
  show("is-in");
  return new Promise((r) => setTimeout(() => { hide(); r(); }, inMs));
}

export async function warpSwap(fn, { outMs = 220, inMs = 260 } = {}){
  await warpOut(outMs);
  fn();
  await warpIn(inMs);
}

export async function warpGo(url, { outMs = 220 } = {}){
  sessionStorage.setItem(KEY, "1");
  await warpOut(outMs);
  window.location.href = url;
}

export function warpInIfNeeded({ inMs = 260 } = {}){
  ensureWarpOverlay();
  const should = sessionStorage.getItem(KEY) === "1";
  if (should) sessionStorage.removeItem(KEY);
  if (should) warpIn(inMs);
}
</file>

<file path="ui/warp-nav.js">
// ui/warp-nav.js — intercept same-origin <a> navigations + warp them
import { warpGo, warpInIfNeeded, ensureWarpOverlay } from "./warp-core.js";

ensureWarpOverlay();
warpInIfNeeded();

document.addEventListener("click", (e) => {
  const a = e.target.closest && e.target.closest("a[href]");
  if (!a) return;

  // Let modified clicks / new tabs behave normally
  if (e.defaultPrevented || e.button !== 0) return;
  if (e.metaKey || e.ctrlKey || e.shiftKey || e.altKey) return;
  if (a.target && a.target !== "_self") return;
  if (a.hasAttribute("download")) return;

  // Same-origin only
  let url;
  try { url = new URL(a.href, window.location.href); } catch { return; }
  if (url.origin !== window.location.origin) return;

  // Don’t warp pure hash jumps
  if (url.pathname === location.pathname && url.search === location.search && url.hash) return;

  e.preventDefault();
  warpGo(url.href);
}, true);
</file>

<file path="ui/warp.css">
/* ui/warp.css — Edge Year-in-Review-ish warp
   Goals:
   - No diagonal “band” streaks
   - Soft bloom + center push
   - Subtle radial motion lines (very faint)
   - Transform/opacity driven (less choppy)
*/

#lux-warp{
  position: fixed;
  inset: 0;
  z-index: 999999;
  pointer-events: none;
  opacity: 0;
  display: none;
  isolation: isolate;
  will-change: opacity, transform;
}

#lux-warp::before,
#lux-warp::after{
  content: "";
  position: absolute;
  inset: -20%;
  transform: translateZ(0);
  will-change: opacity, transform;
}

/* Layer 1: soft Edge-like bloom / haze */
#lux-warp::before{
  background:
    radial-gradient(circle at 50% 50%, rgba(255,255,255,0.28), rgba(255,255,255,0) 54%),
    radial-gradient(circle at 24% 30%, rgba(0,120,215,0.18), rgba(0,0,0,0) 62%),
    radial-gradient(circle at 78% 70%, rgba(124,77,255,0.16), rgba(0,0,0,0) 66%),
    radial-gradient(circle at 62% 34%, rgba(255,159,10,0.10), rgba(0,0,0,0) 60%);
  opacity: 0;
  filter: saturate(1.08);
}

/* Layer 2: subtle radial “warp” spokes (NOT diagonal stripes)
   We create faint spokes via repeating-conic-gradient,
   then fade them with a radial mask so they only show mid-screen.
*/
#lux-warp::after{
  background:
    repeating-conic-gradient(
      from 0deg,
      rgba(255,255,255,0) 0deg 6deg,
      rgba(255,255,255,0.20) 6deg 6.6deg,
      rgba(255,255,255,0) 6.6deg 12deg
    );
  opacity: 0;
  /* Fade center + fade edges (Edge-like subtlety) */
  -webkit-mask: radial-gradient(circle at 50% 50%,
    rgba(0,0,0,0) 0%,
    rgba(0,0,0,0.9) 24%,
    rgba(0,0,0,0.8) 62%,
    rgba(0,0,0,0) 86%
  );
  mask: radial-gradient(circle at 50% 50%,
    rgba(0,0,0,0) 0%,
    rgba(0,0,0,0.9) 24%,
    rgba(0,0,0,0.8) 62%,
    rgba(0,0,0,0) 86%
  );
  mix-blend-mode: screen;
}

#lux-warp.is-on{ display:block; }

#lux-warp.is-out{
  animation: luxWarpOut 200ms cubic-bezier(.18,.9,.2,1) both;
}
#lux-warp.is-in{
  animation: luxWarpIn 240ms cubic-bezier(.2,.8,.2,1) both;
}

/* OUT: quick brighten + slight zoom forward */
#lux-warp.is-out::before{
  animation: luxBloomOut 200ms cubic-bezier(.18,.9,.2,1) both;
}
#lux-warp.is-out::after{
  animation: luxSpokesOut 200ms cubic-bezier(.18,.9,.2,1) both;
}

/* IN: settle back down */
#lux-warp.is-in::before{
  animation: luxBloomIn 240ms cubic-bezier(.2,.8,.2,1) both;
}
#lux-warp.is-in::after{
  animation: luxSpokesIn 240ms cubic-bezier(.2,.8,.2,1) both;
}

@keyframes luxWarpOut{
  0%   { opacity:0; transform: scale(1); }
  100% { opacity:1; transform: scale(1.02); }
}
@keyframes luxWarpIn{
  0%   { opacity:1; transform: scale(1.02); }
  100% { opacity:0; transform: scale(1); }
}

@keyframes luxBloomOut{
  0%   { opacity:0; transform: scale(0.995); }
  100% { opacity:0.92; transform: scale(1.03); }
}
@keyframes luxBloomIn{
  0%   { opacity:0.92; transform: scale(1.03); }
  100% { opacity:0; transform: scale(1.00); }
}

/* Spokes: very faint “speed” feel */
@keyframes luxSpokesOut{
  0%   { opacity:0; transform: scale(0.96); }
  100% { opacity:0.55; transform: scale(1.22); }
}
@keyframes luxSpokesIn{
  0%   { opacity:0.55; transform: scale(1.22); }
  100% { opacity:0; transform: scale(1.02); }
}

@media (prefers-reduced-motion: reduce){
  #lux-warp, #lux-warp::before, #lux-warp::after{ animation: none !important; }
}
</file>

<file path="api/assess.js">
// api/assess.js  (frontend helper)
import { API_BASE, dbg, jsonOrThrow } from "./util.js";
import AudioInspector from "../features/recorder/audio-inspector.js";

const ASSESS_URL = `${API_BASE}/api/assess`;

export async function assessPronunciation({ audioBlob, text, firstLang }) {
  const t = (text ?? "").trim();
  const audioBytes = audioBlob?.size ?? 0;

  // --- Front-end guard: skip if no audio (type-only sends, etc.)
  if (!audioBlob || audioBytes === 0) {
    dbg("SKIP", ASSESS_URL, { reason: "no_audio", textLen: t.length });
    return null; // keep it simple: "no assessment"
  }

  const fd = new FormData();
  fd.append("audio", audioBlob, "recording.webm");
  fd.append("text", t);
  if (firstLang) fd.append("firstLang", firstLang);

  dbg("POST", ASSESS_URL, { audioBytes, textLen: t.length, firstLang });

  // ✅ Inspector: note upload details right before fetch
  AudioInspector.noteUpload({
    endpoint: ASSESS_URL,
    name: "recording.webm",
    blob: audioBlob,
    text: t,
  });

  const resp = await fetch(ASSESS_URL, { method: "POST", body: fd });
  return jsonOrThrow(resp);
}
</file>

<file path="features/convo/convo-layout.js">
// features/convo/convo-layout.js
// Builds the convo UI skeleton and returns DOM handles.
// No event wiring here — index.js remains the orchestrator.

export function buildConvoLayout({ root, el, mode, sessionId }) {
  // --- Layout (single stage) ---
  root.innerHTML = "";
  root.dataset.mode = mode || "intro";
  root.dataset.side = "left";

  const atmo = el("div", "lux-atmo");
  atmo.innerHTML = `
    <div class="lux-atmo-layer a"></div>
    <div class="lux-atmo-layer b"></div>

    <div class="lux-scene-cards" aria-hidden="true">
      <div class="lux-scene-card c1"></div>
      <div class="lux-scene-card c2"></div>
      <div class="lux-scene-card c3"></div>
      <div class="lux-scene-card c4"></div>
      <div class="lux-scene-card c5"></div>
      <div class="lux-scene-card c6"></div>
      <div class="lux-scene-card c7"></div>
      <div class="lux-scene-card c8"></div>
      <div class="lux-scene-card c9"></div>
      <div class="lux-scene-card c10"></div>
      <div class="lux-scene-card c11"></div>
    </div>

    <div class="lux-atmo-fog"></div>
  `;

  const ui = el("div", "lux-ui");

  // Intro overlay
  const intro = el("div", "lux-intro");
  const hero = el("div", "lux-heroCard");

  // NOTE: build hero sub as nodes so we can wrap underline spans
  const heroSub = el("div", "lux-heroSub");
  heroSub.append(
    "Pick a dialogue. Record your reply. We assess each turn silently and give you a ",
    el("span", "lux-uline u1", "session report"),
    " at the end. Then take your results to the ",
    el("span", "lux-uline u2", "Practice Skills"),
    " page to review them in detail."
  );

  hero.append(el("div", "lux-heroTitle", "AI Conversations"), heroSub);

  const heroNext = el("button", "lux-heroNext", "Next");
  hero.append(heroNext);
  intro.append(hero);

  // Picker overlay (Edge deck)
  const picker = el("div", "lux-picker");

  // Return link (ONLY appears in picker mode because it lives inside .lux-picker)
  const pickerToplinks = el("div", "lux-toplinks");
  const pickerHome = el("a", "lux-toplink lux-navpill", "Practice Skills");
  pickerHome.href = "./index.html";
  pickerHome.setAttribute("data-lux-ripple", "");
  pickerToplinks.append(pickerHome);

  const deck = el("div", "lux-deck");
  const deckActive = el("div", "lux-deck-card is-active");
  const deckPreview = el("div", "lux-deck-card is-preview");
  deck.append(deckActive, deckPreview);

  const thumbs = el("div", "lux-thumbs");

  /* NEW: picker knobs row */
  const pickerKnobsRow = el("div", "lux-pickerKnobsRow");
  const pickerKnobsBtn = el("button", "btn ghost", "Knobs");
  const pickerKnobsSummary = el("div", "lux-pickerKnobsSummary", "");
  pickerKnobsRow.append(pickerKnobsBtn, pickerKnobsSummary);

  const nav = el("div", "lux-deckNav");
  const backBtn = el("button", "lux-navArrow", "← Back");
  const nextBtn = el("button", "lux-navNext", "Next →");
  nav.append(backBtn, nextBtn);

  /* IMPORTANT: insert knobs row between thumbs and nav */
  picker.append(pickerToplinks, deck, thumbs, pickerKnobsRow, nav);

  // Chat panel (single centered)
  const chatWrap = el("div", "lux-chatwrap");

  // NEW: Chat mode top links (pill ABOVE the convo panel)
  const chatToplinks = el("div", "lux-toplinks lux-toplinks-chat");
  const chatHomePill = el("a", "lux-toplink lux-navpill", "Practice Skills");
  chatHomePill.href = "./index.html";
  chatHomePill.setAttribute("data-lux-ripple", "");
  chatHomePill.setAttribute("data-lux-ripple", "");
  chatToplinks.append(chatHomePill);

  const mid = el("div", "lux-panel lux-chat");

  const midHd = el("div", "lux-hd");
  const titleWrap = el("div");
  const title = el("div", "lux-title", "AI Conversation");
  const sub = el("div", "lux-sub", `Session: ${sessionId}`);
  titleWrap.append(title, sub);

  const actions = el("div", "lux-actions");

  const scenBtn = el("button", "btn ghost", "Scenarios");
  const knobsBtn = el("button", "btn ghost", "Knobs");
  const endBtn = el("button", "btn danger", "End Session");
  actions.append(scenBtn, knobsBtn, endBtn);

  midHd.append(titleWrap, actions);

  const msgs = el("div", "lux-msgs");
  const sugs = el("div", "lux-sugs");
  const sugsNote = el("div", "lux-sugsNote");
  const coachBar = el("div", "lux-coachbar");

  const compose = el("div", "lux-compose");
  const input = document.createElement("textarea");
  input.className = "lux-in";
  input.placeholder = "Type or click a suggestion, then record your reply…";

  const talkBtn = el("button", "btn primary", "🎙 Record");
  compose.append(input, talkBtn);

  mid.append(midHd, coachBar, msgs, sugsNote, sugs, compose);

  // =========================================================
  // Stage wrapper (anchors docked knobs + local scrim to the chat box)
  // =========================================================
  const stage = el("div", "lux-convoStage");
  stage.id = "convoStage";
  stage.append(mid);

  // Local scrim (dims ONLY the convo box area)
  const scrim = el("button", "lux-knobsScrim");
  scrim.type = "button";
  scrim.setAttribute("aria-label", "Close scene knobs");
  stage.append(scrim);

  // Dock host (lives to the RIGHT of the convo box)
  const knobsDock = el("div", "lux-knobsDock");
  knobsDock.id = "convoKnobsDock";
  stage.append(knobsDock);

  // NEW: include chatToplinks ABOVE the stage (outside the panel)
  chatWrap.append(chatToplinks, stage);

  // Knobs drawer
  const drawer = el("div", "lux-drawer");
  const drawerHd = el("div", "lux-drawerHd");
  drawerHd.append(el("div", "lux-title", "Scene knobs"));
  const closeDrawer = el("button", "btn ghost", "Close");
  drawerHd.append(closeDrawer);

  const drawerBody = el("div", "lux-body k");
  const toneSel = mkSelect(el, "Tone", ["friendly", "neutral", "playful", "formal", "flirty"]);
  const stressSel = mkSelect(el, "Stress", ["low", "medium", "high"]);
  const paceSel = mkSelect(el, "Pace", ["slow", "normal", "fast"]);
  drawerBody.append(toneSel.wrap, stressSel.wrap, paceSel.wrap);
  drawerBody.append(
    el(
      "div",
      "lux-sub",
      "Feedback stays hidden during the conversation. We log each spoken turn silently, then summarize at the end."
    )
  );

  drawer.append(drawerHd, drawerBody);

  // Dock the drawer to the convo box (not viewport)
  knobsDock.append(drawer);

  // Progress panel host (ONLY visible in chat mode via CSS)
  const convoProgress = el("div", "lux-convo-progress");
  convoProgress.id = "convoProgress";

  // =========================================================
  // AI Coach: always visible (no button), placed between chat + progress
  // Move existing #aiCoachDrawer (from convo.html) into this stack.
  // Fallback: move #aiFeedbackSection if drawer not present (older markup).
  // =========================================================
  const aiCoachDrawer = document.getElementById("aiCoachDrawer");
  const aiCoachSection = document.getElementById("aiFeedbackSection");
  const aiCoachEl = aiCoachDrawer || aiCoachSection;

  if (aiCoachEl) {
    aiCoachEl.style.display = ""; // remove inline display:none if present
    aiCoachEl.style.marginTop = ""; // let CSS handle spacing
  }

  // IMPORTANT: append progress AFTER chatWrap so it sits under the chat panel
  if (aiCoachEl) ui.append(intro, picker, chatWrap, aiCoachEl, convoProgress);
  else ui.append(intro, picker, chatWrap, convoProgress);

  root.append(atmo, ui);

  return {
    atmo,
    ui,
    intro,
    heroNext,
    picker,
    deckActive,
    deckPreview,
    thumbs,
    pickerKnobsBtn,
    pickerKnobsSummary,
    backBtn,
    nextBtn,
    chatWrap,
    mid,
    stage,
    knobsDock,
    scenBtn,
    knobsBtn,
    endBtn,
    msgs,
    sugs,
    sugsNote,
    coachBar,
    input,
    talkBtn,
    drawer,
    closeDrawer,
    scrim,
    convoProgress,
    toneSel,
    stressSel,
    paceSel,
  };
}

function mkSelect(el, label, options) {
  const wrap = el("div");
  const lab = el("label", null, label);
  const sel = document.createElement("select");
  options.forEach((o) => {
    const opt = document.createElement("option");
    opt.value = o;
    opt.textContent = o;
    sel.append(opt);
  });
  wrap.append(lab, sel);
  return { wrap, sel };
}
</file>

<file path="features/convo/index.js">
// features/convo/index.js
import { SCENARIOS } from "./scenarios.js";
import { assessPronunciation } from "../../api/assess.js";
import { convoReport } from "../../api/convo-report.js";
import { saveAttempt } from "/src/api/index.js";
import { warpSwap } from "../../ui/warp-core.js";

import { convoTurnWithUi } from "./convo-api.js";
import { createConvoModeController } from "./convo-modes.js";
import { buildConvoLayout } from "./convo-layout.js";

import { consumeNextActivityPlan } from "../next-activity/next-activity.js";

import { initSceneAtmo } from "./scene-atmo.js";
import { wirePickerDeck } from "./picker-deck.js";
import { wireConvoFlow } from "./convo-flow.js";

import {
  applyMediaSizingVars,
  uid,
  newSessionId,
  el,
  showConvoReportOverlay,
} from "./convo-shared.js";

import { mountAICoachAlwaysOn } from "../../ui/ui-ai-ai-logic.js";
import { highlightHtml, stripMarks } from "./convo-highlight.js";
import { createConvoCoach } from "./convo-coach.js";

import { mountAudioModeSwitch } from "../recorder/audio-mode-switch.js";

export function bootConvo() {
  const root = document.getElementById("convoApp");
  if (!root) return;

  // Prevent duplicate listeners on hot reload
  if (root.dataset.luxBooted === "1") return;
  root.dataset.luxBooted = "1";

  const KNOBS_KEY = "lux_knobs_v1";
  const KNOBS_DEFAULTS = { tone: "friendly", stress: "low", pace: "normal" };

  function loadKnobs() {
    try {
      const raw = localStorage.getItem(KNOBS_KEY);
      if (!raw) return { ...KNOBS_DEFAULTS };
      const parsed = JSON.parse(raw);
      return { ...KNOBS_DEFAULTS, ...(parsed || {}) };
    } catch {
      return { ...KNOBS_DEFAULTS };
    }
  }

  function saveKnobs(knobs) {
    try {
      localStorage.setItem(KNOBS_KEY, JSON.stringify(knobs));
    } catch {}
  }

  function knobsSummaryText(knobs) {
    const cap = (s) => (s ? s.charAt(0).toUpperCase() + s.slice(1) : "");
    return `Tone: ${cap(knobs.tone)} • Stress: ${cap(knobs.stress)} • Pace: ${cap(knobs.pace)}`;
  }

  const state = {
    sessionId: newSessionId(),
    scenarioIdx: 0,
    mode: "intro", // intro | picker | chat
    knobsOpen: false,
    knobs: loadKnobs(),

    messages: [], // {role:"user"|"assistant", content:string}
    turns: [], // {turn, userText, azureResult, attemptId?}

    isRecording: false,
    stream: null,
    recorder: null,
    chunks: [],

    busy: false,

    // Next practice (optional)
    nextActivity: null,
    coach: { startTipShown: false, replyTipShown: false, typeTipShown: false },
  };

  const next = consumeNextActivityPlan();
  if (next && next.kind === "ai_conversation") {
    state.nextActivity = next;

    // Choose a base scenario for variety (keeps passageKey pretty: convo:doctor, etc.)
    state.scenarioIdx = Math.floor(Math.random() * SCENARIOS.length);
  }

  const view = buildConvoLayout({
    root,
    el,
    mode: state.mode,
    sessionId: state.sessionId,
  });

  // ✅ Audio Mode Switch (Normal / Pro) on AI Conversations
  mountAudioModeSwitch({ scope: "convo" });

  const {
    atmo,
    intro,
    heroNext,
    deckActive,
    deckPreview,
    thumbs,
    pickerKnobsBtn,
    pickerKnobsSummary,
    backBtn,
    nextBtn,
    scenBtn,
    knobsBtn,
    endBtn,
    msgs,
    sugs,
    sugsNote,
    coachBar,
    input,
    talkBtn,
    closeDrawer,
    scrim,
    stage,
    toneSel,
    stressSel,
    paceSel,
  } = view;

  const { applySceneVisuals, setParallaxEnabled } = initSceneAtmo({
    root,
    atmo,
    state,
    scenarios: SCENARIOS,
  });

  // Coach controller (after coachBar + input exist)
  const coach = createConvoCoach({ state, coachBar, input, el });
  coach.wireTypeTip();

  function render() {
    // Ensure the AI Coach shell exists as soon as we enter chat mode.
    if (state.mode === "chat") {
      mountAICoachAlwaysOn(() => {
        const t = state.turns?.length ? state.turns[state.turns.length - 1] : null;
        return t
          ? { azureResult: t.azureResult, referenceText: t.userText, firstLang: "universal" }
          : null;
      });
    }
  }

  function setKnobs(open) {
    state.knobsOpen = !!open;
    stage.classList.toggle("knobs-open", state.knobsOpen);

    // If opening, ensure drawer UI reflects current state
    if (state.knobsOpen) {
      toneSel.sel.value = state.knobs.tone;
      stressSel.sel.value = state.knobs.stress;
      paceSel.sel.value = state.knobs.pace;
    }
  }

  // Mode controller (extracted)
  const modeCtl = createConvoModeController({
    root,
    state,
    setParallaxEnabled,
    setKnobs,
    render,
  });

  const { normalizeMode, setMode } = modeCtl;
  modeCtl.wirePopstate({ warpSwap });

  function warpToPicker() {
    // intro -> picker gets the warp treatment
    if (state.mode !== "intro") return setMode("picker");
    warpSwap(() => setMode("picker"), { outMs: 200, inMs: 240 });
  }

  // Intro click => picker (Edge-like “push”)
  intro.addEventListener("click", warpToPicker);
  heroNext.addEventListener("click", (e) => {
    e.stopPropagation();
    warpToPicker();
  });

  // Chat header buttons
  scenBtn.addEventListener("click", () =>
    warpSwap(() => setMode("picker"), { outMs: 170, inMs: 220 })
  );
  knobsBtn.addEventListener("click", () => setKnobs(!state.knobsOpen));

  if (pickerKnobsBtn) {
    pickerKnobsBtn.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation(); // IMPORTANT: don't advance deck / trigger other clicks
      setKnobs(true);
    });
  }

  closeDrawer.addEventListener("click", () => setKnobs(false));
  scrim.addEventListener("click", () => setKnobs(false));
  document.addEventListener("keydown", (e) => {
    if (e.key === "Escape") setKnobs(false);
  });

  // Initialize drawer selects from stored knobs
  toneSel.sel.value = state.knobs.tone;
  stressSel.sel.value = state.knobs.stress;
  paceSel.sel.value = state.knobs.pace;

  // Picker summary (if present)
  function renderPickerKnobsSummary() {
    if (!pickerKnobsSummary) return;
    pickerKnobsSummary.textContent = knobsSummaryText(state.knobs);
  }
  renderPickerKnobsSummary();

  toneSel.sel.addEventListener("change", () => {
    state.knobs.tone = toneSel.sel.value;
    saveKnobs(state.knobs);
    renderPickerKnobsSummary();
  });

  stressSel.sel.addEventListener("change", () => {
    state.knobs.stress = stressSel.sel.value;
    saveKnobs(state.knobs);
    renderPickerKnobsSummary();
  });

  paceSel.sel.addEventListener("change", () => {
    state.knobs.pace = paceSel.sel.value;
    saveKnobs(state.knobs);
    renderPickerKnobsSummary();
  });

  // Helpers (for rendering / highlight inputs)
  function getWordBank() {
    return (state.nextActivity?.targets?.words || [])
      .map((x) => x?.word || x)
      .filter(Boolean)
      .map((x) => String(x).trim())
      .filter(Boolean);
  }

  function getFocusIpa() {
    return state.nextActivity?.targets?.phoneme?.ipa || "";
  }

  // --- Chat rendering ---
  function renderMessages() {
    msgs.innerHTML = "";
    const focusIpa = getFocusIpa();
    const wb = getWordBank();

    for (const m of state.messages) {
      const bubble = el("div", "msg " + (m.role === "user" ? "user" : "assistant"));
      bubble.innerHTML = highlightHtml(m.content, {
        wordBank: wb,
        focusIpa,
        autoBlue: m.role !== "user",
      });
      msgs.append(bubble);
    }
    msgs.scrollTop = msgs.scrollHeight;
  }

  function renderSuggestions(list) {
    sugs.innerHTML = "";
    const focusIpa = getFocusIpa();
    const wb = getWordBank();

    (list || []).forEach((t) => {
      const raw = stripMarks(t);
      const b = el("button", "sug");
      b.dataset.raw = raw;
      b.innerHTML = highlightHtml(t, { wordBank: wb, focusIpa, autoBlue: true });
      b.addEventListener("click", () => {
        input.value = raw;
        input.focus();
      });
      sugs.append(b);
    });

    // Tiny, always-light label (not overwhelming)
    if (state.nextActivity && (list || []).length) {
      const t = coach.targetsInline(state.nextActivity);
      sugsNote.textContent = t
        ? `Suggested replies are tuned to: ${t}`
        : "Suggested replies are tuned to your targets.";
    } else {
      sugsNote.textContent = "";
    }

    coach.noteSuggestionsRendered(list);
  }

  // --- Convo flow (extracted) ---
  const { startScenario } = wireConvoFlow({
    SCENARIOS,
    state,
    root,
    input,
    talkBtn,
    endBtn,
    renderMessages,
    renderSuggestions,
    convoTurn: convoTurnWithUi,
    assessPronunciation,
    saveAttempt,
    uid,
    convoReport,
    showConvoReportOverlay,
  });

  if (state.nextActivity) {
    // Ensure we’re in chat mode and start immediately
    warpSwap(() => setMode("chat", { replace: true, push: false }), { outMs: 120, inMs: 160 })
      .then(() => startScenario())
      .catch((e) => console.error("[NextPractice] auto-start failed", e));
  }

  async function beginScenario() {
    await warpSwap(() => setMode("chat"), { outMs: 200, inMs: 240 });
    await startScenario(); // fetch opening line + suggested replies
  }

  // --- Picker deck (extracted) ---
  const { renderDeck } = wirePickerDeck({
    scenarios: SCENARIOS,
    state,
    thumbs,
    deckActive,
    deckPreview,
    backBtn,
    nextBtn,
    el,
    applyMediaSizingVars,
    applySceneVisuals,
    onBeginScenario: beginScenario,
  });

  // boot
  applySceneVisuals();
  renderDeck();

  // If a Next Practice plan was stored, consume it once and keep in memory for this session.
  try {
    const plan = consumeNextActivityPlan();
    if (plan) state.nextActivity = plan;
  } catch (_) {}

  // Initial mode: hash (if present) wins, otherwise intro.
  const initialMode =
    normalizeMode(history.state?.luxConvo ? history.state.mode : location.hash) || "intro";

  setMode(initialMode, { replace: true, push: false });

  // If we landed directly in chat (e.g., from "Generate my next practice"),
  // show the start tip immediately.
  if (state.mode === "chat" && state.nextActivity) {
    coach.maybeShowStartTip();
  }
}
</file>

<file path="features/features/08-selfpb-peekaboo.js">
// features/features/08-selfpb-peekaboo.js
// LAZY LOADER: Creates the tab immediately, but loads the heavy UI/WaveSurfer only on click.

(() => {
  const OPEN_CLASS = "lux-sp-open";
  const PANEL_SEL = ".lux-sp-panel";
  const BODY_SEL = ".lux-sp-body";
  const HOST_ID = "selfpb-lite";
  const CSS_HREF = "./features/features/selfpb-peekaboo.css";

  let isLoaded = false;
  let isLoading = false;

  // 1) Ensure Panel CSS (Lightweight)
  (function ensureCSS() {
    const has = [...document.styleSheets].some((ss) =>
      (ss.href || "").includes("selfpb-peekaboo.css")
    );
    if (!has) {
      const link = document.createElement("link");
      link.rel = "stylesheet";
      link.href = CSS_HREF;
      document.head.appendChild(link);
    }
  })();

  // 2) Build Panel Shell + Tab (Runs immediately)
  function buildShell() {
    if (document.querySelector(PANEL_SEL)) return;

    const panel = document.createElement("aside");
    panel.className = "lux-sp-panel";
    panel.setAttribute("role", "complementary");
    panel.setAttribute("aria-label", "Self Playback");

    panel.innerHTML = `
      <button class="lux-sp-tab" type="button" aria-expanded="false" aria-controls="${HOST_ID}">
        <span class="lux-sp-tab-inner">
          <span class="lux-sp-tab-label">Self Playback</span>
          <span class="lux-sp-tab-icon">◀</span>
        </span>
      </button>
      <div class="lux-sp-body">
        <div id="sp-loading-placeholder" style="padding:20px; text-align:center; color:#666; display:none;">
           Loading Waveforms... 🌊
        </div>
      </div>
    `;
    document.body.appendChild(panel);

    // Wire the click to the Lazy Loader
    const tab = panel.querySelector(".lux-sp-tab");
    tab.addEventListener("click", handleToggle);
  }

  // 3) The Lazy Load Handler
  async function handleToggle() {
    const panel = document.querySelector(PANEL_SEL);
    const tab = panel.querySelector(".lux-sp-tab");
    const loader = document.getElementById("sp-loading-placeholder");

    // If already open, just close it
    if (document.documentElement.classList.contains(OPEN_CLASS)) {
      close();
      return;
    }

    // If not loaded yet, load the heavy stuff
    if (!isLoaded) {
      if (isLoading) return; // Prevent double-clicks
      isLoading = true;

      // Show spinner
      if (loader) loader.style.display = "block";
      tab.style.opacity = "0.7";

      try {
        console.log("[Lux] Lazy-loading Self Playback...");

        // ✅ 1) Ensure inner controls CSS only when opened (FIXED PATH)
        (function ensureInnerCSS() {
          const href = "/features/features/self-playback.css";
          const has = [...document.styleSheets].some((ss) =>
            (ss.href || "").includes("self-playback.css")
          );
          if (!has) {
            const link = document.createElement("link");
            link.rel = "stylesheet";
            link.href = href;
            document.head.appendChild(link);
          }
        })();

        // ✅ 2) Lazy-load WaveSurfer ONLY now (FIXED PATH)
        await (async function ensureWaveSurfer() {
          const has = [...document.scripts].some((s) =>
            (s.src || "").includes("wavesurfer-7.8.11.min.js")
          );
          if (has) return;

          const src = "/vendor/wavesurfer-7.8.11.min.js";

          await new Promise((resolve, reject) => {
            const script = document.createElement("script");
            script.src = src;
            script.async = true;
            script.onload = resolve;
            script.onerror = reject;
            document.head.appendChild(script);
          });
        })();

        // ✅ 3) Now import the heavy UI
const module = await import("./selfpb/ui-GOLD.js");

        // Mount the heavy UI
        if (module && module.mountSelfPlaybackLite) {
          module.mountSelfPlaybackLite();
        }

        // Move the new host into our panel
        const host = document.getElementById(HOST_ID);
        const body = panel.querySelector(BODY_SEL);

        if (host && body) {
          host.removeAttribute("style"); // Remove fixed positioning from the lite module
          host.dataset.luxHidden = "0";

          // Ensure we don't duplicate if something weird happened
          if (!body.contains(host)) {
            body.appendChild(host);
          }
        }

        // Hydrate audio if recording already happened (nudge the waveform)
        const audioEl = document.getElementById("playbackAudio");
        if (audioEl && audioEl.src) {
          audioEl.dispatchEvent(new Event("loadedmetadata"));
        }

        isLoaded = true;
      } catch (e) {
        console.error("Failed to load Self Playback:", e);
        alert("Could not load audio tools. Please refresh.");
      } finally {
        isLoading = false;
        if (loader) loader.style.display = "none";
        tab.style.opacity = "1";
      }
    }

    open();
  }

  // 4) State Helpers
  function open() {
    document.documentElement.classList.add(OPEN_CLASS);
    const tab = document.querySelector(".lux-sp-tab");
    if (tab) tab.setAttribute("aria-expanded", "true");
  }

  function close() {
    document.documentElement.classList.remove(OPEN_CLASS);
    const tab = document.querySelector(".lux-sp-tab");
    if (tab) tab.setAttribute("aria-expanded", "false");
  }

  // Expose control API
  window.luxSP = Object.assign(window.luxSP || {}, {
    open,
    close,
    toggle: handleToggle,
  });

  // 5) Boot the Shell
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", buildShell);
  } else {
    buildShell();
  }
})();
</file>

<file path="features/harvard/index.js">
// features/harvard/index.js
import { setPassage, updatePartsInfoTip } from "../passages/index.js";
import { ensureHarvardPassages } from "../../src/data/index.js";

function pad2(n) {
  return String(n).padStart(2, "0");
}
function clamp(n, lo, hi) {
  return Math.max(lo, Math.min(hi, n));
}
function harvardKey(n) {
  return `harvard${pad2(n)}`;
}

export function wireHarvardPicker() {
  const num = document.getElementById("harvardNum");
  const prev = document.getElementById("harvardPrev");
  const next = document.getElementById("harvardNext");
  const load = document.getElementById("harvardLoad");
  const rnd = document.getElementById("harvardRandom");
  const out = document.getElementById("harvardLoaded");

  if (!num || !prev || !next || !load || !rnd) return;

  const loadLabel = load?.textContent || "Load";

  async function apply(raw) {
    const n = clamp(parseInt(raw, 10) || 1, 1, 72);

    if (num) num.value = String(n);
    try {
      localStorage.setItem("LUX_HARVARD_LAST", String(n));
    } catch {}

    // ✅ Lazy-load the big dataset ONLY when Harvard is actually requested
    try {
      if (load) {
        load.disabled = true;
        load.textContent = "Loading…";
      }
      await ensureHarvardPassages();
    } catch (e) {
      console.error("[Harvard] Failed to lazy-load Harvard lists", e);
      return;
    } finally {
      if (load) {
        load.disabled = false;
        load.textContent = loadLabel;
      }
    }

    setPassage(harvardKey(n));
    updatePartsInfoTip();

    if (out) out.textContent = `Loaded: Harvard List ${pad2(n)}`;
  }

  // restore last used
  try {
    const last = localStorage.getItem("LUX_HARVARD_LAST");
    if (last) num.value = String(clamp(parseInt(last, 10) || 1, 1, 72));
  } catch {}

  load.addEventListener("click", () => apply(num.value));
  num.addEventListener("keydown", (e) => {
    if (e.key === "Enter") apply(num.value);
  });

  prev.addEventListener("click", () =>
    apply((parseInt(num.value, 10) || 1) - 1)
  );
  next.addEventListener("click", () =>
    apply((parseInt(num.value, 10) || 1) + 1)
  );

  rnd.addEventListener("click", () => {
    const n = Math.floor(Math.random() * 72) + 1;
    apply(n);
  });
}
</file>

<file path="features/interactions/metric-modal/index.js">
// features/interactions/metric-modal/index.js
export { initMetricScoreModals, setMetricModalData } from "./events.js";
</file>

<file path="features/interactions/ph-hover/tooltip-video.js">
// features/interactions/ph-hover/tooltip-video.js
// Tooltip-side video controls (sound/loop/speed/play/stop/both + tile click behavior)

export function initTooltipVideoControls(globalTooltipEl, { openVideoFocusModal } = {}) {
  const sideVid = globalTooltipEl?.querySelector("#lux-global-video-side");
  const frontVid = globalTooltipEl?.querySelector("#lux-global-video-front");

  const tileSide = globalTooltipEl?.querySelector('.lux-ph-vidTile[data-vid="side"]');
  const tileFront = globalTooltipEl?.querySelector('.lux-ph-vidTile[data-vid="front"]');

  const btnSide = globalTooltipEl?.querySelector("#lux-ph-play-side");
  const btnFront = globalTooltipEl?.querySelector("#lux-ph-play-front");
  const btnBoth = globalTooltipEl?.querySelector("#lux-ph-play-both");
  const btnStop = globalTooltipEl?.querySelector("#lux-ph-stop");
  const btnExpand = globalTooltipEl?.querySelector("#lux-ph-expand");
  const btnSound = globalTooltipEl?.querySelector("#lux-ph-sound");
  const btnLoop = globalTooltipEl?.querySelector("#lux-ph-loop");
  const speedSel = globalTooltipEl?.querySelector("#lux-ph-speed");

  if (!sideVid && !frontVid) return;

  // Expand: if user hovers anywhere on the control podium for 2s, nudge-grow Expand once
  const podium = globalTooltipEl?.querySelector(".lux-ph-vidControls");
  if (podium && btnExpand) {
    let hoverTimer = null;

    const cancel = () => {
      if (hoverTimer) clearTimeout(hoverTimer);
      hoverTimer = null;
    };

    podium.addEventListener("mouseenter", () => {
      cancel();
      hoverTimer = setTimeout(() => {
        if (!btnExpand.isConnected) return;

        // retrigger animation reliably
        btnExpand.classList.remove("lux-expand-attn");
        void btnExpand.offsetWidth; // reflow
        btnExpand.classList.add("lux-expand-attn");
      }, 2000);
    });

    podium.addEventListener("mouseleave", () => {
      cancel();
      btnExpand.classList.remove("lux-expand-attn");
    });

    btnExpand.addEventListener("animationend", (e) => {
      if (e.animationName === "luxExpandAttention") {
        btnExpand.classList.remove("lux-expand-attn");
      }
    });
  }

  // Default sound ON
  let soundOn = true;

  // Default loop OFF
  let loopOn = false;

  function applySound() {
    const txt = soundOn ? "🔊" : "🔇";
    if (btnSound) {
      btnSound.textContent = txt;
      btnSound.setAttribute("data-sound", soundOn ? "1" : "0");
    }
    for (const v of [sideVid, frontVid]) {
      if (!v) continue;
      v.muted = !soundOn;
      v.volume = 1.0;
    }
  }

  function applyLoop() {
    for (const v of [sideVid, frontVid]) {
      if (!v) continue;
      v.loop = loopOn;
    }
    if (btnLoop) {
      btnLoop.textContent = loopOn ? "Repeat On" : "Repeat Off";
      btnLoop.setAttribute("data-loop", loopOn ? "1" : "0");
    }
  }

  function applySpeed() {
    const rate = parseFloat(speedSel?.value || "1");
    for (const v of [sideVid, frontVid]) {
      if (!v) continue;
      v.playbackRate = rate;
    }
  }

  async function gesturePlay(v, { restart = true } = {}) {
    if (!v) return;
    try {
      if (restart) v.currentTime = 0;
    } catch (_) {}

    // Pressing play should auto-unmute (unless user turned sound off)
    v.muted = soundOn ? false : true;
    v.volume = 1.0;

    try {
      await v.play();
    } catch (_) {
      // Fallback: browsers may block sound
      try {
        v.muted = true;
        await v.play();
      } catch (_) {}
    }
  }

  function stopAll() {
    for (const v of [sideVid, frontVid]) {
      if (!v) continue;
      try {
        v.pause();
      } catch (_) {}
      try {
        v.currentTime = 0;
      } catch (_) {}
    }
  }

  function bindTile(v, tile) {
    if (!v || !tile) return;

    const syncClass = () => {
      tile.classList.toggle("is-playing", !v.paused);
    };

    v.addEventListener("play", syncClass);
    v.addEventListener("pause", syncClass);
    v.addEventListener("ended", syncClass);
    syncClass();

    tile.addEventListener("click", async (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (v.paused) await gesturePlay(v, { restart: false });
      else v.pause();
    });
  }

  bindTile(sideVid, tileSide);
  bindTile(frontVid, tileFront);

  btnSound?.addEventListener("click", (e) => {
    e.preventDefault();
    e.stopPropagation();
    soundOn = !soundOn;
    applySound();
  });

  btnLoop?.addEventListener("click", (e) => {
    e.preventDefault();
    e.stopPropagation();
    loopOn = !loopOn;
    applyLoop();
  });

  speedSel?.addEventListener("change", applySpeed);

  btnSide?.addEventListener("click", async (e) => {
    e.preventDefault();
    e.stopPropagation();
    await gesturePlay(sideVid, { restart: true });
  });

  btnFront?.addEventListener("click", async (e) => {
    e.preventDefault();
    e.stopPropagation();
    await gesturePlay(frontVid, { restart: true });
  });

  btnBoth?.addEventListener("click", async (e) => {
    e.preventDefault();
    e.stopPropagation();

    // Restart both to sync “as close as possible”
    try {
      if (sideVid) sideVid.currentTime = 0;
    } catch (_) {}
    try {
      if (frontVid) frontVid.currentTime = 0;
    } catch (_) {}

    applySound();
    applySpeed();

    await Promise.all([
      sideVid ? gesturePlay(sideVid, { restart: false }) : Promise.resolve(),
      frontVid ? gesturePlay(frontVid, { restart: false }) : Promise.resolve(),
    ]);
  });

  btnStop?.addEventListener("click", (e) => {
    e.preventDefault();
    e.stopPropagation();
    stopAll();
  });

  btnExpand?.addEventListener("click", (e) => {
    e.preventDefault();
    e.stopPropagation();

    const sideSrc = sideVid?.getAttribute("src");
    const frontSrc = frontVid?.getAttribute("src");

    openVideoFocusModal?.({ sideSrc, frontSrc });
  });

  // Apply initial states
  applySound();
  applyLoop();
  applySpeed();
}
</file>

<file path="features/interactions/score-collapse.js">
// ui/interactions/score-collapse.js
export function initScoreErrorCollapse() {
  const box = document.getElementById("prettyResult");
  if (!box || box.dataset.collapseInit) return;
  box.dataset.collapseInit = "yes";
  box.addEventListener("click", (e) => {
    const toggleButton = e.target.closest("button.lux-col-toggle");
    if (toggleButton) {
      const table = toggleButton.closest("table");
      const col = toggleButton.dataset.col;
      if (!table || !col) return;
      if (col === "word") table.classList.toggle("collapsed-word");
      if (col === "phoneme") table.classList.toggle("collapsed-phoneme");
      return;
    }
    const cell = e.target.closest("td,th");
    const table = cell && cell.closest("table");
    if (!cell || !table || !Number.isInteger(cell.cellIndex)) return;

    const hasSyllables = !!table.querySelector("#syllableHeader");
    const scoreIdx = hasSyllables ? 2 : 1;
    const errorIdx = hasSyllables ? 3 : 2;

    if (cell.cellIndex === scoreIdx) table.classList.toggle("collapsed-score");
    else if (cell.cellIndex === errorIdx) table.classList.toggle("collapsed-error");
  });
}
</file>

<file path="features/my-words/library-modal.js">
// features/my-words/library-modal.js

import { mountMyWordsPanel } from "./panel.js";

export function createMyWordsLibraryModal({ store, getAttempts, onSendToInput } = {}) {
  let overlay = null;
  let panel = null;

  function ensure() {
    if (overlay) return;

    overlay = document.createElement("div");
    overlay.className = "lux-mw-modal";

    const card = document.createElement("div");
    card.className = "lux-mw-modal-card";
    overlay.appendChild(card);

    document.body.appendChild(overlay);

    panel = mountMyWordsPanel({
      store,
      getAttempts,
      onSendToInput,
      mode: "library",
      maxPreview: Infinity,
      mountTo: card,
      asModal: true,
    });

    overlay.addEventListener("click", (e) => {
      if (e.target === overlay) close();
    });

    document.addEventListener("keydown", (e) => {
      if (e.key === "Escape" && overlay.classList.contains("is-open")) close();
    });
  }

  function open() {
    ensure();
    overlay.classList.add("is-open");
    panel?.render?.();
    panel?.focusSearch?.();
  }

  function close() {
    if (!overlay) return;
    overlay.classList.remove("is-open");
  }

  return { open, close };
}
</file>

<file path="features/my-words/normalize.js">
// features/my-words/normalize.js

/**
 * Mild normalization for de-dupe + search.
 * IMPORTANT: keep it conservative (do NOT strip punctuation aggressively).
 */
export function normalizeText(s) {
  return String(s || "")
    .trim()
    .replace(/\s+/g, " ")
    .toLowerCase();
}

export function splitLines(raw) {
  return String(raw || "")
    .split(/\r?\n/)
    .map((l) => l.trim())
    .filter(Boolean);
}
</file>

<file path="features/progress/attempt-detail/header.js">
// features/progress/attempt-detail/header.js
// Builds the header element for Attempt Details modal (Session Report top area).

import { esc, getColorConfig, mean } from "../progress-utils.js";

export function buildAttemptDetailHeader({
  title,
  mode,
  attemptsCount,
  tsMin,
  tsMax,
  fmtDateTime,
  sid,
  isNoSess,
  dayGroup,
  pronAvg,
  list,
  attemptMetric,
  confidenceLabel,
  confidenceHint,
  nextActions,
  isConvo,
} = {}) {
  const bigScoreColor = getColorConfig(pronAvg).color;

  // Scores (session averages)
  const accAvg = mean((list || []).map((a) => attemptMetric(a, "acc")));
  const fluAvg = mean((list || []).map((a) => attemptMetric(a, "flu")));
  const compAvg = mean((list || []).map((a) => attemptMetric(a, "comp")));
  const prosAvg = mean((list || []).map((a) => attemptMetric(a, "pros")));

  const fmtRoundPct = (v) =>
    v == null || !Number.isFinite(+v) ? "—" : `${Math.round(+v)}%`;

  // New: overall aggregate circle for the modal
  const overallAgg = mean([accAvg, fluAvg, compAvg, prosAvg, pronAvg]);
  const overallColor = getColorConfig(overallAgg).color;

  const tileKV = (label, val) => `
    <div class="lux-scoreTile">
      <div class="lux-scoreTile-label">${esc(label)}</div>
      <div class="lux-scoreTile-value">${fmtRoundPct(val)}</div>
    </div>
  `;

  function pillKV(label, val) {
    return `
      <div style="background:#f8fafc; padding:8px; border-radius:8px; text-align:center;">
        <div style="font-size:0.75rem; color:#64748b; text-transform:uppercase; font-weight:700;">${esc(
          label
        )}</div>
        <div style="font-weight:800; color:#334155;">${val}</div>
      </div>
    `;
  }

  const header = document.createElement("div");
  header.innerHTML = `
    <div style="text-align:center; margin-bottom: 14px;">
      <h3 style="margin:0; color:#1e293b; font-size:1.25rem;">Session Report</h3>
      <div style="margin-top:6px; font-weight:900; color:#334155;">${esc(title)}</div>
      <p style="margin:6px 0 0; color:#64748b; font-size:0.92rem;">
        ${esc(mode)} · ${attemptsCount} attempt${attemptsCount === 1 ? "" : "s"}
      </p>

      <div style="margin-top:10px; display:flex; gap:10px; justify-content:center; flex-wrap:wrap;">
<button id="luxPracticeAgainBtn" data-lux-generate-next
  style="border:1px solid #cbd5e1; background:#fff; padding:8px 12px; border-radius:10px; font-weight:900; cursor:pointer; color:#0f172a;">
  ✨ Generate my next practice
</button>

        ${
          isConvo
            ? `<button id="luxChooseScenarioBtn"
                style="border:1px solid #e2e8f0; background:#f8fafc; padding:8px 12px; border-radius:10px; font-weight:900; cursor:pointer; color:#334155;">
                🗂️ Choose scenario
              </button>`
            : ``
        }
      </div>

      <p style="margin:6px 0 0; color:#64748b; font-size:0.9rem;">
        ${esc(fmtDateTime(tsMin))} → ${esc(fmtDateTime(tsMax))}
      </p>

      <p style="margin:6px 0 0; color:#64748b; font-size:0.9rem; font-weight:900;">
        Confidence: ${esc(confidenceLabel)}
        <span style="color:#94a3b8; font-weight:800;">· ${esc(confidenceHint)}</span>
      </p>

      <p style="margin:6px 0 0; color:#94a3b8; font-size:0.85rem; font-weight:800;">
        ${
          sid
            ? isNoSess
              ? `Grouped by day (no session id): ${esc(dayGroup)}`
              : `Session: ${esc(sid)}`
            : ""
        }
      </p>
    </div>

    <div class="lux-scoreSummary lux-scoreSummary--pyramid" style="margin-bottom:14px;">
      <div class="lux-scoreMain">
        <div class="lux-scoreMainLabel">Overall</div>
        <div class="lux-scoreRing" style="--lux-score-ring:${overallColor};">
          ${fmtRoundPct(overallAgg)}
        </div>
      </div>

      <div class="lux-scorePyramid">
        <div class="lux-scoreRow lux-scoreRow-mid">
          ${tileKV("Prosody", prosAvg)}
          ${tileKV("Pronunciation", pronAvg)}
        </div>
        <div class="lux-scoreRow lux-scoreRow-bottom">
          ${tileKV("Accuracy", accAvg)}
          ${tileKV("Fluency", fluAvg)}
          ${tileKV("Completeness", compAvg)}
        </div>
      </div>
    </div>

    <div style="border-top:1px solid #e2e8f0; padding-top: 12px;">
      <h4 style="margin:0 0 10px 0; font-size:0.95rem; color:#334155;">✅ What to do next</h4>
      <ul style="margin:0; padding-left:18px; color:#475569; line-height:1.55;">
        ${(nextActions || []).map((x) => `<li style="margin-bottom:6px;">${x}</li>`).join("")}
      </ul>
    </div>
  `;

  const againBtn = header.querySelector("#luxPracticeAgainBtn");
  const chooseBtn = header.querySelector("#luxChooseScenarioBtn");

  return { header, againBtn, chooseBtn };
}
</file>

<file path="features/progress/rollups.js">
// features/progress/rollups.js
// Pure rollups: attempts -> totals + trouble sounds/words + trend + session summaries.

import { norm } from "../../src/data/phonemes/core.js";

function num(x) {
  const n = Number(x);
  return Number.isFinite(n) ? n : null;
}

function pickAzure(attempt) {
  return (
    attempt?.azureResult ||
    attempt?.azure_result ||
    attempt?.azure ||
    attempt?.result ||
    null
  );
}

function pickSummary(attempt) {
  return attempt?.summary || attempt?.summary_json || attempt?.sum || null;
}

function pickPassageKey(attempt) {
  return attempt?.passage_key || attempt?.passageKey || attempt?.passage || "";
}

function pickSessionId(attempt) {
  return attempt?.session_id || attempt?.sessionId || "";
}

function pickTS(attempt) {
  return (
    attempt?.ts ||
    attempt?.created_at ||
    attempt?.createdAt ||
    attempt?.time ||
    Date.now()
  );
}

function localDayKey(ts) {
  const d = new Date(ts);
  // "en-CA" gives YYYY-MM-DD in most browsers
  try {
    return d.toLocaleDateString("en-CA");
  } catch (_) {}
  const y = d.getFullYear();
  const m = String(d.getMonth() + 1).padStart(2, "0");
  const da = String(d.getDate()).padStart(2, "0");
  return `${y}-${m}-${da}`;
}

function daysAgoFrom(tsNum) {
  if (!tsNum) return 999;
  const d = Math.floor((Date.now() - tsNum) / (24 * 60 * 60 * 1000));
  return Number.isFinite(d) ? Math.max(0, d) : 999;
}

// Constitutional priority: error_rate × exposure × persistence × recency
function priorityFromFull({ avg, count, daysSeen, lastTS }) {
  const a = Number.isFinite(avg) ? avg : 0;
  const c = Number.isFinite(count) ? count : 0;
  const ds = Number.isFinite(daysSeen) ? daysSeen : 0;

  const errorRate = Math.max(0, Math.min(1, (100 - a) / 100)); // 0..1
  const exposure = Math.log1p(Math.max(0, c)); // grows slowly
  const persistence = Math.min(1, ds / 5); // 1.0 at 5 days
  const recency = 0.3 + 0.7 * Math.exp(-daysAgoFrom(lastTS) / 14); // never hits 0

  return errorRate * exposure * persistence * recency;
}

export function getAttemptScore(attempt) {
  const sum = pickSummary(attempt);
  if (sum && sum.pron != null) {
    const v = num(sum.pron);
    if (v != null) return v;
  }
  const az = pickAzure(attempt);
  const v = num(az?.NBest?.[0]?.PronScore);
  return v != null ? v : 0;
}

export function computeRollups(attempts = [], opts = {}) {
  const windowDays = Number(opts.windowDays || 30);

  // Optional thresholds (dashboard defaults stay strict; modal can loosen)
  const minWordCountRaw = Number(opts.minWordCount);
  const minPhonCountRaw = Number(opts.minPhonCount);

  const minWordCount = Number.isFinite(minWordCountRaw)
    ? Math.max(1, Math.floor(minWordCountRaw))
    : 2;
  const minPhonCount = Number.isFinite(minPhonCountRaw)
    ? Math.max(1, Math.floor(minPhonCountRaw))
    : 3;

  const phon = new Map(); // ipa -> {ipa,count,sum,examples:Set,days:Set,lastTS,lowCount}
  const words = new Map(); // word -> {word,count,sum,days:Set,lastTS}
  const byDay = new Map(); // day -> {count,sum}
  const sessions = new Map(); // sessionId -> {count,sumScore,tsMin,tsMax,passageKey,hasAI}
  const byPassage = new Map(); // passageKey -> {count,sumScore,lastTS}

  const phonDays = new Map(); // ipa -> Set(dayKey)
  const wordDays = new Map(); // word -> Set(dayKey)

  // Plan A: metric-specific trend capture (Prosody later)
  const METRICS = [
    ["acc", "Accuracy"],
    ["flu", "Fluency"],
    ["comp", "Completeness"],
    ["pron", "Pronunciation"],
  ];
  const byDayMetric = Object.fromEntries(METRICS.map(([k]) => [k, new Map()])); // k -> Map(dayKey -> {count,sum})
  const seriesMetric = Object.fromEntries(METRICS.map(([k]) => [k, []])); // k -> [{ts,v}]

  let lastTS = 0;
  let scoreSum = 0;
  let scoreCount = 0;

  for (const a of attempts) {
    const ts = pickTS(a);
    const tsNum = +new Date(ts);
    lastTS = Math.max(lastTS, tsNum);
    const score = getAttemptScore(a);

    scoreSum += score;
    scoreCount += 1;

    // Trend (overall)
    const day = localDayKey(ts);
    const dayAgg = byDay.get(day) || { count: 0, sum: 0 };
    dayAgg.count += 1;
    dayAgg.sum += score;
    byDay.set(day, dayAgg);

    // Sessions
    const sid = pickSessionId(a) || `nosess:${day}`;
    const pk = pickPassageKey(a);
    const sum = pickSummary(a);
    const hasAI = !!(
      sum &&
      sum.ai_feedback &&
      sum.ai_feedback.sections &&
      sum.ai_feedback.sections.length
    );

    // metric trends: acc / flu / comp / pron
    for (const [k] of METRICS) {
      const v = num(sum?.[k]);
      if (v == null) continue;

      const aggM = byDayMetric[k].get(day) || { count: 0, sum: 0 };
      aggM.count += 1;
      aggM.sum += v;
      byDayMetric[k].set(day, aggM);

      seriesMetric[k].push({ ts: tsNum, v });
    }

    // Snapshot: most-practiced passage across these attempts
    const pAgg = byPassage.get(pk) || {
      passageKey: pk,
      count: 0,
      sumScore: 0,
      lastTS: 0,
    };
    pAgg.count += 1;
    pAgg.sumScore += score;
    pAgg.lastTS = Math.max(pAgg.lastTS, +new Date(ts));
    byPassage.set(pk, pAgg);

    const sAgg = sessions.get(sid) || {
      sessionId: sid,
      passageKey: pk,
      count: 0,
      sumScore: 0,
      tsMin: +new Date(ts),
      tsMax: +new Date(ts),
      hasAI: false,
    };
    sAgg.count += 1;
    sAgg.sumScore += score;
    sAgg.tsMin = Math.min(sAgg.tsMin, +new Date(ts));
    sAgg.tsMax = Math.max(sAgg.tsMax, +new Date(ts));
    sAgg.passageKey = sAgg.passageKey || pk;
    sAgg.hasAI = sAgg.hasAI || hasAI;
    sessions.set(sid, sAgg);

    // Word + phoneme details
    // Prefer Azure word/phoneme arrays if present; otherwise use compact backend summary (summary.words / summary.lows).
    const az = pickAzure(a);
    const nb = az?.NBest?.[0];
    const W = Array.isArray(nb?.Words) ? nb.Words : [];

    if (W.length) {
      // --- Original path: full Azure detail available ---
      for (const w of W) {
        const word = String(w?.Word || "").trim().toLowerCase();
        if (!word) continue;

        const wScore = num(w?.AccuracyScore);
        if (wScore != null) {
          const wAgg =
            words.get(word) || {
              word,
              count: 0,
              sum: 0,
              days: new Set(),
              lastTS: 0,
            };
          wAgg.count += 1;
          wAgg.sum += wScore;
          wAgg.days.add(day);
          wAgg.lastTS = Math.max(wAgg.lastTS, tsNum);
          words.set(word, wAgg);

          const wd = wordDays.get(word) || new Set();
          wd.add(day);
          wordDays.set(word, wd);
        }

        const P = Array.isArray(w?.Phonemes) ? w.Phonemes : [];
        for (const p of P) {
          const raw = String(p?.Phoneme || p?.phoneme || "").trim();
          if (!raw) continue;

          const ipa = norm(raw);
          if (!ipa) continue;

          const pScore = num(p?.AccuracyScore);
          if (pScore == null) continue;

          const pAgg =
            phon.get(ipa) || {
              ipa,
              count: 0,
              sum: 0,
              examples: new Set(),
              days: new Set(),
              lastTS: 0,
              lowCount: 0,
            };

          pAgg.count += 1;
          pAgg.sum += pScore;

          if (pScore < 80) pAgg.lowCount += 1;
          pAgg.days.add(day);
          pAgg.lastTS = Math.max(pAgg.lastTS, tsNum);

          // keep a few example words
          if (word && pAgg.examples.size < 4) pAgg.examples.add(word);

          phon.set(ipa, pAgg);

          const pd = phonDays.get(ipa) || new Set();
          pd.add(day);
          phonDays.set(ipa, pd);
        }
      }
    } else {
      // --- Fallback path: compact summary-only attempts (normal for /api/user-recent) ---
      // Words: summary.words is [[word, avgScore, count], ...]
      const sumWords = Array.isArray(sum?.words) ? sum.words : [];
      for (const t of sumWords) {
        if (!Array.isArray(t)) continue;
        const word = String(t[0] || "").trim().toLowerCase();
        const avg = num(t[1]);
        const cntRaw = Number(t[2]);
        const cnt = Number.isFinite(cntRaw) && cntRaw > 0 ? cntRaw : 1;
        if (!word || avg == null) continue;

        const wAgg =
          words.get(word) || {
            word,
            count: 0,
            sum: 0,
            days: new Set(),
            lastTS: 0,
          };
        wAgg.count += cnt;
        wAgg.sum += avg * cnt;
        wAgg.days.add(day);
        wAgg.lastTS = Math.max(wAgg.lastTS, tsNum);
        words.set(word, wAgg);

        const wd = wordDays.get(word) || new Set();
        wd.add(day);
        wordDays.set(word, wd);
      }

      // Phonemes: prefer summary.stats.phonemes if it ever exists; otherwise use summary.lows [[phoneme, score], ...]
      const phStats = sum?.stats?.phonemes;
      if (phStats && typeof phStats === "object") {
        for (const [rawIpa, v] of Object.entries(phStats)) {
          const ipa =
            norm(String(rawIpa || "").trim()) || String(rawIpa || "").trim();
          const occ = Number(v?.occ);
          const avg = num(v?.avg);
          if (!ipa || !Number.isFinite(occ) || occ <= 0 || avg == null) continue;

          const pAgg =
            phon.get(ipa) || {
              ipa,
              count: 0,
              sum: 0,
              examples: new Set(),
              days: new Set(),
              lastTS: 0,
              lowCount: 0,
            };

          pAgg.count += occ;
          pAgg.sum += avg * occ;

          const low = Number(v?.low);
          if (Number.isFinite(low) && low > 0) pAgg.lowCount += low;

          pAgg.days.add(day);
          pAgg.lastTS = Math.max(pAgg.lastTS, tsNum);

          phon.set(ipa, pAgg);

          const pd = phonDays.get(ipa) || new Set();
          pd.add(day);
          phonDays.set(ipa, pd);
        }
      } else {
        const lows = Array.isArray(sum?.lows) ? sum.lows : [];
        for (const p of lows) {
          if (!Array.isArray(p)) continue;
          const raw = String(p[0] || "").trim();
          const pScore = num(p[1]);
          if (!raw || pScore == null) continue;

          const ipa = norm(raw) || raw;

          const pAgg =
            phon.get(ipa) || {
              ipa,
              count: 0,
              sum: 0,
              examples: new Set(),
              days: new Set(),
              lastTS: 0,
              lowCount: 0,
            };

          pAgg.count += 1;
          pAgg.sum += pScore;
          if (pScore < 80) pAgg.lowCount += 1;

          pAgg.days.add(day);
          pAgg.lastTS = Math.max(pAgg.lastTS, tsNum);

          phon.set(ipa, pAgg);

          const pd = phonDays.get(ipa) || new Set();
          pd.add(day);
          phonDays.set(ipa, pd);
        }
      }
    }
  }

  // Snapshot: best day (highest avg) + most-practiced passage
  let bestDayKey = null;
  let bestDayScore = null;

  for (const [day, agg] of byDay.entries()) {
    if (!agg || !agg.count) continue;
    const avg = agg.sum / agg.count;
    if (bestDayScore == null || avg > bestDayScore) {
      bestDayScore = avg;
      bestDayKey = day;
    }
  }

  let bestDayTS = null;
  if (bestDayKey) {
    const [yy, mm, dd] = String(bestDayKey)
      .split("-")
      .map((x) => Number(x));
    if (yy && mm && dd) bestDayTS = +new Date(yy, mm - 1, dd);
  }

  let topPassageKey = null;
  let topPassageCount = 0;

  for (const v of byPassage.values()) {
    if ((v.count || 0) > topPassageCount) {
      topPassageCount = v.count || 0;
      topPassageKey = v.passageKey || null;
    }
  }

  // Build trouble lists (worst avg first), with basic “seen enough” guard.
  const troublePhonemesAll = Array.from(phon.values())
    .map((x) => {
      const avg = x.count ? x.sum / x.count : 0;
      const days = phonDays.get(x.ipa)?.size || 1;
      return {
        ipa: x.ipa,
        count: x.count,
        avg,
        days,
        priority: priorityFromFull({
          avg,
          count: x.count,
          daysSeen: days,
          lastTS: x.lastTS,
        }),
        examples: Array.from(x.examples || []).slice(0, 3),
      };
    })
    .filter((x) => x.count >= minPhonCount)
    .sort(
      (a, b) => b.priority - a.priority || a.avg - b.avg || b.count - a.count
    );

  const troubleWordsAll = Array.from(words.values())
    .map((x) => {
      const avg = x.count ? x.sum / x.count : 0;
      const days = wordDays.get(x.word)?.size || 1;
      return {
        word: x.word,
        count: x.count,
        avg,
        days,
        priority: priorityFromFull({
          avg,
          count: x.count,
          daysSeen: days,
          lastTS: x.lastTS,
        }),
      };
    })
    .filter((x) => x.count >= minWordCount)
    .sort(
      (a, b) => b.priority - a.priority || a.avg - b.avg || b.count - a.count
    );

  // Trend points (last windowDays) — overall score
  const now = new Date();
  const days = [];
  for (let i = windowDays - 1; i >= 0; i--) {
    const d = new Date(now.getTime() - i * 24 * 60 * 60 * 1000);
    const k = localDayKey(d);
    const agg = byDay.get(k);
    days.push({
      day: k,
      avg: agg ? agg.sum / agg.count : null,
    });
  }

  // Build metric rollups: { acc:{label,trend[],avg7,avg30,last,bestDay}, ... }
  const buildMetric = (k, label) => {
    const pts = [];
    const nowMs = Date.now();

    for (let i = windowDays - 1; i >= 0; i--) {
      const d = new Date(nowMs - i * 86400000);
      const key = localDayKey(d);
      const agg = byDayMetric[k].get(key);
      const avg = agg && agg.count ? agg.sum / agg.count : null;
      pts.push({ day: key, avg });
    }

    const vals30 = pts.map((p) => num(p.avg)).filter((v) => v != null);
    const avg30 = vals30.length
      ? vals30.reduce((a, b) => a + b, 0) / vals30.length
      : null;

    const vals7 = pts
      .slice(-7)
      .map((p) => num(p.avg))
      .filter((v) => v != null);
    const avg7 = vals7.length
      ? vals7.reduce((a, b) => a + b, 0) / vals7.length
      : null;

    let bestDay = null;
    for (const p of pts) {
      const v = num(p.avg);
      if (v == null) continue;
      if (!bestDay || v > bestDay.avg) bestDay = { day: p.day, avg: v };
    }

    const series = (seriesMetric[k] || [])
      .slice()
      .sort((a, b) => (b.ts || 0) - (a.ts || 0));
    const last = series.length ? num(series[0].v) : null;

    return {
      label,
      trend: pts.map((p) => ({ avg: p.avg ?? null })),
      avg7,
      avg30,
      last,
      bestDay,
    };
  };

  const metrics = Object.fromEntries(
    METRICS.map(([k, label]) => [k, buildMetric(k, label)])
  );

  const sessionArr = Array.from(sessions.values())
    .map((s) => ({
      ...s,
      avgScore: s.count ? s.sumScore / s.count : 0,
    }))
    .sort((a, b) => b.tsMax - a.tsMax);

  return {
    totals: {
      attempts: attempts.length,
      sessions: sessions.size,
      lastTS: lastTS || null,
      avgScore: scoreCount ? scoreSum / scoreCount : 0,

      // Snapshot
      bestDayTS,
      bestDayScore,
      topPassageKey,
      topPassageCount,
    },
    trouble: {
      phonemesAll: troublePhonemesAll,
      wordsAll: troubleWordsAll,
    },
    trend: days,
    metrics, // ✅ NEW STRUCTURE
    sessions: sessionArr,
  };
}
</file>

<file path="features/progress/wordcloud/attempt-utils.js">
// features/progress/wordcloud/attempt-utils.js
// Wordcloud attempt helpers (recents list + labels)
// ✅ extracted from index.js to shrink controller file

import { pickTS, pickAzure, pickSummary, pickPassageKey } from "../attempt-pickers.js";
import { titleFromPassageKey } from "../render/format.js";
import { lower } from "./compute.js";

// ---------- Action Sheet helpers ----------
export function attemptOverallScore(a) {
  const sum = pickSummary(a) || {};
  if (sum.pron != null) return Number(sum.pron) || 0;
  const az = pickAzure(a);
  return Number(az?.NBest?.[0]?.PronScore) || 0;
}
export function attemptWhen(a) {
  const ts = pickTS(a);
  return ts ? new Date(ts).toLocaleString() : "";
}
export function attemptTitle(a) {
  const pk = pickPassageKey(a);
  return titleFromPassageKey(pk);
}
export function findRecentAttemptsForWord(attempts, word, limit = 6) {
  const needle = lower(word);
  if (!needle) return [];

  const out = [];
  const list = Array.isArray(attempts) ? attempts.slice() : [];
  list.sort((a, b) => +new Date(pickTS(b) || 0) - +new Date(pickTS(a) || 0));

  for (const a of list) {
    if (out.length >= limit) break;

    const az = pickAzure(a);
    const W = az?.NBest?.[0]?.Words || [];
    if (!Array.isArray(W) || !W.length) continue;

    const found = W.some((w) => lower(w?.Word) === needle);
    if (!found) continue;

    out.push({
      attempt: a,
      title: attemptTitle(a),
      when: attemptWhen(a),
      score: attemptOverallScore(a),
    });
  }
  return out;
}
export function findRecentAttemptsForPhoneme(attempts, ipa, limit = 6) {
  const needle = String(ipa || "").trim();
  if (!needle) return [];

  const out = [];
  const list = Array.isArray(attempts) ? attempts.slice() : [];
  list.sort((a, b) => +new Date(pickTS(b) || 0) - +new Date(pickTS(a) || 0));

  for (const a of list) {
    if (out.length >= limit) break;

    const az = pickAzure(a);
    const W = az?.NBest?.[0]?.Words || [];
    if (!Array.isArray(W) || !W.length) continue;

    let found = false;
    for (const w of W) {
      const P = Array.isArray(w?.Phonemes) ? w.Phonemes : [];
      if (P.some((p) => String(p?.Phoneme || "").trim() === needle)) {
        found = true;
        break;
      }
    }
    if (!found) continue;

    out.push({
      attempt: a,
      title: attemptTitle(a),
      when: attemptWhen(a),
      score: attemptOverallScore(a),
    });
  }
  return out;
}
</file>

<file path="features/progress/wordcloud/compute.js">
// features/progress/wordcloud/compute.js
import { pickTS, pickAzure } from "../attempt-pickers.js";

export function clamp(n, a, b) {
  return Math.max(a, Math.min(b, n));
}

export function lower(s) {
  return String(s || "").trim().toLowerCase();
}

export function log1p(n) {
  return Math.log(1 + Math.max(0, Number(n || 0)));
}

export function idFromItem(mode, x) {
  if (mode === "phonemes") return String(x?.ipa ?? x?.text ?? "").trim();
  return String(x?.word ?? x?.text ?? "").trim();
}

export function filterAttemptsByRange(attempts, rangeKey, winDays = 14, posDays = 0) {
  const list = Array.isArray(attempts) ? attempts : [];
  if (rangeKey === "all") return list;

  const now = Date.now();

  if (rangeKey === "today") {
    const d = new Date();
    d.setHours(0, 0, 0, 0);
    const start = +d;
    return list.filter((a) => +new Date(pickTS(a) || 0) >= start);
  }

  if (rangeKey === "timeline") {
    const end = now - posDays * 24 * 60 * 60 * 1000;
    const start = end - winDays * 24 * 60 * 60 * 1000;

    return list.filter((a) => {
      const ts = +new Date(pickTS(a) || 0);
      return ts >= start && ts <= end;
    });
  }

  const days = rangeKey === "7d" ? 7 : 30;
  const start = now - days * 24 * 60 * 60 * 1000;

  return list.filter((a) => +new Date(pickTS(a) || 0) >= start);
}

export function computeLastSeenMap(mode, attempts, idsWanted) {
  const want = new Set((idsWanted || []).map((x) => lower(x)));
  const seen = new Map();
  if (!want.size) return seen;

  const list = Array.isArray(attempts) ? attempts.slice() : [];
  list.sort((a, b) => +new Date(pickTS(b) || 0) - +new Date(pickTS(a) || 0));

  for (const a of list) {
    if (seen.size >= want.size) break;

    const ts = +new Date(pickTS(a) || 0);
    if (!ts) continue;

    const az = pickAzure(a);
    const W = az?.NBest?.[0]?.Words || [];
    if (!Array.isArray(W) || !W.length) continue;

    if (mode === "words") {
      for (const w of W) {
        const word = lower(w?.Word);
        if (!word || !want.has(word)) continue;
        if (!seen.has(word)) seen.set(word, ts);
      }
    } else {
      for (const w of W) {
        const P = Array.isArray(w?.Phonemes) ? w.Phonemes : [];
        if (!P.length) continue;

        for (const p of P) {
          const ipa = lower(p?.Phoneme);
          if (!ipa || !want.has(ipa)) continue;
          if (!seen.has(ipa)) seen.set(ipa, ts);
        }
      }
    }
  }

  return seen;
}

export function persistentScore(x) {
  const days = Number(x?.days || 0);
  const count = Number(x?.count || 0);
  const avg = Number(x?.avg || 0);
  const bad = clamp((100 - avg) / 100, 0, 1);
  return Math.pow(days + 1, 1.2) * Math.pow(count + 1, 0.65) * (0.35 + bad);
}

export function smartTop3(mode, pool) {
  const items = Array.isArray(pool) ? pool.slice() : [];
  if (!items.length) return [];

  const minCount = mode === "phonemes" ? 3 : 2;
  const candidates = items.filter((x) => Number(x.count || 0) >= minCount);
  if (!candidates.length) return items.slice(0, 3);

  const counts = candidates.map((x) => log1p(x.count || 0));
  const days = candidates.map((x) => log1p(x.days || 0));
  const recs = candidates.map((x) => Number(x.lastSeenTS || 0));

  const maxC = Math.max(1e-6, ...counts);
  const maxD = Math.max(1e-6, ...days);
  const maxR = Math.max(1, ...recs);

  const score = (x) => {
    const diff = clamp((100 - Number(x.avg || 0)) / 100, 0, 1);
    const freq = clamp(log1p(x.count || 0) / maxC, 0, 1);
    const pers = clamp(log1p(x.days || 0) / maxD, 0, 1);
    const rec  = clamp(Number(x.lastSeenTS || 0) / maxR, 0, 1);

    return 0.45 * diff + 0.25 * pers + 0.2 * freq + 0.1 * rec;
  };

  candidates.sort((a, b) => score(b) - score(a));

  const out = [];
  const seen = new Set();
  for (const x of candidates) {
    const id = lower(idFromItem(mode, x));
    if (!id || seen.has(id)) continue;
    seen.add(id);
    out.push(x);
    if (out.length >= 3) break;
  }

  return out;
}
</file>

<file path="features/progress/wordcloud/data-loader.js">
/**
 * features/progress/wordcloud/data-loader.js
 *
 * Commit 15: "The API Wrapper"
 * Isolates communication with backend and refresh scheduling.
 *
 * Owns:
 * - ensureData(force) -> fetches attempts via uid and mutates stable attemptsAll ref
 * - startAutoRefresh({ rootId, onRefresh, intervalMs }) -> periodically triggers redraw
 */

import { fetchHistory } from "/src/api/index.js";
import { ensureUID } from "/api/identity.js";

export const DEFAULT_AUTO_REFRESH_MS = 10 * 60 * 1000;

export function createWordcloudDataLoader({ attemptsAll }) {
  if (!attemptsAll) throw new Error("[wc/data] attemptsAll is required");

  /**
   * ✅ MINIMAL FIX (ONLY HERE)
   * Mutate the existing attemptsAll array so render.js always sees the same reference.
   */
  async function ensureData(force = false) {
    if (attemptsAll.length && !force) return;

    const uid = ensureUID();
    const next = await fetchHistory(uid);

    attemptsAll.length = 0;
    attemptsAll.push(...(next || []));

    console.log(
      "[wc] history attempts:",
      attemptsAll?.length,
      attemptsAll?.[0]
    );
  }

  /**
   * Periodically refresh the view (draw) if the page is still mounted.
   * Returns a stop() function.
   */
  function startAutoRefresh({
    rootId,
    onRefresh,
    intervalMs = DEFAULT_AUTO_REFRESH_MS,
  }) {
    if (!rootId) throw new Error("[wc/data] startAutoRefresh requires rootId");
    if (typeof onRefresh !== "function")
      throw new Error("[wc/data] startAutoRefresh requires onRefresh()");

    const timer = setInterval(() => {
      if (document.getElementById(rootId)) onRefresh();
    }, intervalMs);

    return () => clearInterval(timer);
  }

  return {
    ensureData,
    startAutoRefresh,
  };
}
</file>

<file path="features/progress/wordcloud/dom.js">
// features/progress/wordcloud/dom.js
// Centralized DOM grabber for the Word Cloud page.
// This maps 1:1 to the IDs/classes used in:
//   features/progress/wordcloud/index.js

export function getWordcloudDom(root) {
  if (!root) throw new Error("[wordcloud/dom] root is required");

  const $ = (sel) => root.querySelector(sel);
  const $$ = (sel) => Array.from(root.querySelectorAll(sel));

  const dom = {
    // Root
    root,

    // Main shell + canvas area
    shell: $("#luxWcShell"),
    canvas: $("#luxWcCanvas") || $("canvas"),

    // Meta text blocks
    meta: $("#luxWcMeta"),
    sub: $("#luxWcSub"),

    // Loading overlay (center canvas)
    overlay: $("#luxWcOverlay"),
    overlayTitle: $("#luxWcOverlayTitle"),
    overlaySub: $("#luxWcOverlaySub"),

    // Top controls
    btnTheme: $("#luxWcThemeToggle"),

    // Mode pills + sort/range buttons (data attributes)
    pills: $$(".lux-wc-pill"),
    sortBtns: $$("[data-sort]"),
    rangeBtns: $$("[data-range]"),

    // Toggles / mix
    btnCluster: $("#luxWcCluster"),
    mixView: $("#luxWcMixView"),
    mixSmart: $("#luxWcMixSmart"),

    // Strips + helper hint
    targetsStrip: $("#luxWcTargets"),
    savedStrip: $("#luxWcSaved"),
    coachHint: $("#luxWcCoachHint"),

    // Timeline controls
    timelineRow: $("#luxWcTimelineRow"),
    winSlider: $("#luxWcWin"),
    posSlider: $("#luxWcPos"),
    winVal: $("#luxWcWinVal"),
    posVal: $("#luxWcPosVal"),
    btnReplay: $("#luxWcReplay"),

    // Convenience accessors (optional)
    $,
    $$,
  };

  // Optional: quick missing-element diagnostics (helps when template changes)
  dom.missing = () => {
    const required = [
      ["shell", dom.shell],
      ["canvas", dom.canvas],
      ["meta", dom.meta],
      ["sub", dom.sub],
      ["overlay", dom.overlay],
      ["btnTheme", dom.btnTheme],
      ["btnCluster", dom.btnCluster],
      ["mixView", dom.mixView],
      ["mixSmart", dom.mixSmart],
      ["targetsStrip", dom.targetsStrip],
      ["savedStrip", dom.savedStrip],
      ["coachHint", dom.coachHint],
      ["timelineRow", dom.timelineRow],
      ["winSlider", dom.winSlider],
      ["posSlider", dom.posSlider],
      ["winVal", dom.winVal],
      ["posVal", dom.posVal],
      ["btnReplay", dom.btnReplay],
    ];

    return required.filter(([, el]) => !el).map(([name]) => name);
  };

  return dom;
}
</file>

<file path="features/progress/wordcloud/labels.js">
// features/progress/wordcloud/labels.js

export function rangeLabel(r) {
  if (r === "today") return "Today";
  if (r === "7d") return "7 days";
  if (r === "30d") return "30 days";
  if (r === "timeline") return "Timeline";
  return "All time";
}

export function sortLabel(s) {
  if (s === "freq") return "Frequent";
  if (s === "diff") return "Difficult";
  if (s === "recent") return "Recent";
  if (s === "persist") return "Persistent";
  return "Priority";
}

export function mixLabel(m) {
  return m === "smart" ? "Smart Mix" : "View-based";
}
</file>

<file path="features/progress/wordcloud/libs.js">
// features/progress/wordcloud/libs.js
// Loads vendor scripts ONLY when this page opens.

function ensureScript(src, id) {
  return new Promise((resolve) => {
    if (document.getElementById(id)) return resolve(true);

    const s = document.createElement("script");
    s.id = id;
    s.src = src;
    s.async = true;

    s.onload = () => resolve(true);
    s.onerror = () => resolve(false);

    document.head.appendChild(s);
  });
}

/**
 * EXPECTED vendor files (you add them):
 * - /public/vendor/d3.v7.min.js
 * - /public/vendor/d3.layout.cloud.js
 */
export async function ensureWordCloudLibs() {
  const ok1 = await ensureScript("/vendor/d3.v7.min.js", "lux-d3");
  const ok2 = await ensureScript("/vendor/d3.layout.cloud.js", "lux-d3-cloud");

  // d3 must exist, cloud must exist
  const d3Ok = !!window.d3;
  const cloudOk = !!(window.d3?.layout?.cloud || window.cloud);

  return ok1 && ok2 && d3Ok && cloudOk;
}
</file>

<file path="features/progress/wordcloud/plan.js">
/**
 * features/progress/wordcloud/plan.js
 *
 * ✅ COMMIT 12D
 * Extract “Next Activity Plan build” logic out of index.js
 *
 * Owns:
 *  - buildCloudPlan(model, state)            (sheet selection -> plan)
 *  - buildCloudTop3Plan(model, mode, top3)   (Top 3 -> plan)
 *  - buildCloudCoachQuickPlan(model)        (coach quick -> plan)
 */

import { buildNextActivityPlanFromModel } from "../../next-activity/next-activity.js";
import { lower } from "./compute.js";

/**
 * Build a Next Activity Plan for a specific cloud selection.
 * Used by the sheet controller when user taps an item.
 *
 * @param {object} model  - rollups model (ctx.refs.lastModel)
 * @param {object} state  - { kind: "word"|"phoneme", id, avg, count, days, priority }
 * @returns {object|null} next activity plan JSON or null
 */
export function buildCloudPlan(model, state) {
  const base = buildNextActivityPlanFromModel(model, {
    source: "cloud",
    maxWords: 6,
  });
  if (!base) return null;

  if (state?.kind === "word") {
    const target = {
      word: String(state.id || "").trim(),
      avg: Number(state.avg) || null,
      count: Number(state.count) || null,
      days: Number(state.days) || null,
      priority: Number(state.priority) || null,
    };

    const rest = (base.targets?.words || []).filter(
      (w) => lower(w?.word) !== lower(target.word)
    );

    base.targets.words = [target, ...rest].slice(0, 6);
  }

  if (state?.kind === "phoneme") {
    base.targets.phoneme = {
      ipa: String(state.id || "").trim(),
      avg: Number(state.avg) || null,
      count: Number(state.count) || null,
      days: Number(state.days) || null,
      priority: Number(state.priority) || null,
    };
  }

  return base;
}

/**
 * Build a Next Activity Plan from the “Top 3” strip selection.
 *
 * For WORD mode: inject chosen top words into plan.targets.words (front-loaded).
 * For PHONEME mode: choose best[0] as plan.targets.phoneme.
 *
 * @param {object} model
 * @param {"words"|"phonemes"} mode
 * @param {Array<object>} top
 * @returns {object|null}
 */
export function buildCloudTop3Plan(model, mode, top) {
  const base = buildNextActivityPlanFromModel(model, {
    source: "cloud-top3",
    maxWords: 6,
  });
  if (!base) return null;

  const list = Array.isArray(top) ? top : [];
  if (!list.length) return base;

  if (mode === "words") {
    const chosen = list
      .map((x) => ({
        word: String(x?.word || "").trim(),
        avg: Number(x?.avg || 0) || null,
        count: Number(x?.count || 0) || null,
        days: Number(x?.days || 0) || null,
        priority: Number(x?.priority || 0) || null,
      }))
      .filter((x) => x.word);

    const rest = (base.targets?.words || []).filter(
      (w) => !chosen.some((c) => lower(c.word) === lower(w?.word))
    );

    base.targets.words = [...chosen, ...rest].slice(0, 6);
    return base;
  }

  // phonemes
  const best = list[0];
  base.targets.phoneme = {
    ipa: String(best?.ipa || "").trim(),
    avg: Number(best?.avg || 0) || null,
    count: Number(best?.count || 0) || null,
    days: Number(best?.days || 0) || null,
    priority: Number(best?.priority || 0) || null,
  };

  return base;
}

/**
 * Coach quick path:
 * Your prior behavior was “save the base plan as-is” (no injection).
 * Keep that behavior here.
 *
 * @param {object} model
 * @returns {object|null}
 */
export function buildCloudCoachQuickPlan(model) {
  return (
    buildNextActivityPlanFromModel(model, {
      source: "cloud-top3",
      maxWords: 6,
    }) || null
  );
}
</file>

<file path="features/progress/wordcloud/sheet-controller.js">
// features/progress/wordcloud/sheet-controller.js

/**
 * COMMIT 12C — Extract “action sheet controller” out of index.js
 * Owns:
 * - createCloudActionSheet({ ... })
 * - openSheetForId()
 * - onSelect(hit) -> opens sheet
 */

import { createCloudActionSheet } from "./action-sheet.js";

export function createWordcloudSheetController({
  ctx,
  attemptsAll,
  getState,              // () => S snapshot
  strips,                // strips controller (for onStoreChange refresh)
  requestDraw,           // () => draw(false)

  // behavior + dependencies
  buildCloudPlan,        // (state) => plan
  saveNextActivityPlan,  // (plan) => void
  goToConvo,             // () => void

  openDetailsModal,      // (attempt, score, dateStr, meta) => void
  attemptOverallScore,   // (attempt) => number
  attemptWhen,           // (attempt) => string

  findRecentAttemptsForWord,
  findRecentAttemptsForPhoneme,

  filterAttemptsByRange,
  idFromItem,
  lower,
}) {
  const sheet = createCloudActionSheet({
    onGenerate: (state) => {
      const plan = buildCloudPlan(state);
      if (!plan) return;
      saveNextActivityPlan(plan);
      goToConvo();
    },

    onOpenAttempt: (attempt) => {
      if (!attempt) return;
      const score = attemptOverallScore(attempt);
      const dateStr = attemptWhen(attempt) || "—";
      openDetailsModal(attempt, score, dateStr, {
        sid: "",
        list: [attempt],
        session: null,
      });
    },

    onStoreChange: () => {
      strips?.renderSavedStrip?.();
      requestDraw?.();
    },
  });

  function openSheetForId(id) {
    const S = getState();

    // ✅ CORRECT ORDER: (allAttempts, range, timelineWin, timelinePos)
    const attemptsInRange = filterAttemptsByRange(
      attemptsAll,
      S.range,
      S.timelineWin,
      S.timelinePos
    );

    const hitItem = (ctx.refs.lastPool || []).find(
      (x) => lower(idFromItem(S.mode, x)) === lower(id)
    );

    const kind = S.mode === "phonemes" ? "phoneme" : "word";
    const title = kind === "phoneme" ? `/${id}/` : id;

    const avg = hitItem ? Number(hitItem.avg || 0) : 0;
    const count = hitItem ? Number(hitItem.count || 0) : 0;

    const recents =
      kind === "word"
        ? findRecentAttemptsForWord(attemptsInRange, id, 6)
        : findRecentAttemptsForPhoneme(attemptsInRange, id, 6);

    sheet.open({
      kind,
      id,
      title,
      avg,
      count,
      days: hitItem?.days ?? null,
      priority: hitItem?.priority ?? null,
      examples: Array.isArray(hitItem?.examples) ? hitItem.examples : [],
      recents,
    });
  }

  function openFromHit(hit) {
    const S = getState();

    // ✅ CORRECT ORDER: (allAttempts, range, timelineWin, timelinePos)
    const attemptsRange = filterAttemptsByRange(
      attemptsAll,
      S.range,
      S.timelineWin,
      S.timelinePos
    );

    const metaObj = hit?.meta || {};
    const isPh = S.mode === "phonemes" || metaObj.ipa != null;

    const kind = isPh ? "phoneme" : "word";
    const id = isPh
      ? String(metaObj.ipa || hit.text || "").trim()
      : String(metaObj.word || hit.text || "").trim();

    const title = kind === "phoneme" ? `/${id}/` : id;

    const recents =
      kind === "word"
        ? findRecentAttemptsForWord(attemptsRange, id, 6)
        : findRecentAttemptsForPhoneme(attemptsRange, id, 6);

    sheet.open({
      kind,
      id,
      title,
      avg: Number(metaObj.avg ?? hit.avg ?? 0) || 0,
      count: Number(metaObj.count ?? hit.count ?? 0) || 0,
      days: metaObj.days ?? null,
      priority: metaObj.priority ?? null,
      examples: Array.isArray(metaObj.examples) ? metaObj.examples : [],
      recents,
    });
  }

  return {
    openSheetForId,
    openFromHit,
  };
}
</file>

<file path="features/progress/wordcloud/state-store.js">
// features/progress/wordcloud/state-store.js
// LocalStorage state + saved lists for Wordcloud

export const STATE_KEY = "lux.cloud.state.v3";
export const THEME_KEY = "lux.cloud.theme.v1";
export const FAV_KEY   = "lux.cloud.favs.v1";
export const PIN_KEY   = "lux.cloud.pins.v1";

function lower(s) {
  return String(s || "").trim().toLowerCase();
}

export function readState() {
  try {
    const raw = localStorage.getItem(STATE_KEY);
    return raw ? JSON.parse(raw) : {};
  } catch (_) {
    return {};
  }
}

export function writeState(next) {
  try {
    localStorage.setItem(STATE_KEY, JSON.stringify(next || {}));
  } catch (_) {}
}

function readSaved(key) {
  try {
    const raw = localStorage.getItem(key);
    const obj = raw ? JSON.parse(raw) : {};
    return {
      words: Array.isArray(obj.words) ? obj.words : [],
      phonemes: Array.isArray(obj.phonemes) ? obj.phonemes : [],
    };
  } catch (_) {
    return { words: [], phonemes: [] };
  }
}

function writeSaved(key, next) {
  try {
    localStorage.setItem(key, JSON.stringify(next));
  } catch (_) {}
}

export function savedListForMode(key, mode) {
  const s = readSaved(key);
  return mode === "phonemes" ? s.phonemes : s.words;
}

export function addManySaved(key, mode, ids) {
  const s = readSaved(key);
  const list = mode === "phonemes" ? s.phonemes : s.words;

  const add = [];
  const seen = new Set(list.map(lower));

  for (const id of ids) {
    const v = String(id || "").trim();
    if (!v) continue;

    const k = lower(v);
    if (seen.has(k)) continue;

    seen.add(k);
    add.push(v);
  }

  const merged = [...add, ...list].slice(0, 30);
  if (mode === "phonemes") s.phonemes = merged;
  else s.words = merged;

  writeSaved(key, s);
}
</file>

<file path="features/progress/wordcloud/url-state.js">
// features/progress/wordcloud/url-state.js

export function readUrlState() {
  const p = new URLSearchParams(window.location.search);
  const out = {};

  if (p.has("mode")) out.mode = p.get("mode");
  if (p.has("sort")) out.sort = p.get("sort");
  if (p.has("range")) out.range = p.get("range");
  if (p.has("q")) out.q = p.get("q") || "";
  if (p.has("theme")) out.theme = p.get("theme");
  if (p.has("cluster")) out.cluster = p.get("cluster");
  if (p.has("mix")) out.mix = p.get("mix");
  if (p.has("win")) out.win = p.get("win");
  if (p.has("pos")) out.pos = p.get("pos");

  return out;
}

export function writeUrlState({
  mode,
  sort,
  range,
  q,
  theme,
  clusterMode,
  mix,
  win,
  pos,
}) {
  const p = new URLSearchParams();

  p.set("mode", mode);
  p.set("sort", sort);
  p.set("range", range);
  if (q) p.set("q", q);

  p.set("theme", theme);
  p.set("cluster", clusterMode ? "1" : "0");
  p.set("mix", mix);

  if (range === "timeline") {
    p.set("win", String(win || 14));
    p.set("pos", String(pos || 0));
  }

  const next = `${window.location.pathname}?${p.toString()}`;
  window.history.replaceState(null, "", next);
}
</file>

<file path="features/recorder/audio-inspector.js">
// features/recorder/audio-inspector.js
// Tiny Audio Pipeline Inspector (Lux)
// Enable with:  ?audioDebug=1
// or in console: localStorage.setItem("luxAudioInspector","1"); location.reload();

const LS_KEY = "luxAudioInspector";

function isEnabled() {
  try {
    const qs = new URLSearchParams(location.search);
    if (qs.has("audioDebug")) return true;
    return localStorage.getItem(LS_KEY) === "1";
  } catch {
    return false;
  }
}

function fmtBytes(n) {
  const num = Number(n || 0);
  if (!Number.isFinite(num) || num <= 0) return "0 B";
  const units = ["B", "KB", "MB", "GB"];
  let i = 0;
  let v = num;
  while (v >= 1024 && i < units.length - 1) { v /= 1024; i++; }
  return `${v.toFixed(v >= 10 || i === 0 ? 0 : 1)} ${units[i]}`;
}

async function probeBlobDurationSeconds(blob) {
  // Uses <audio> metadata (works reliably with webm/opus)
  try {
    return await new Promise((resolve) => {
      const el = document.createElement("audio");
      el.preload = "metadata";
      el.onloadedmetadata = () => {
        const d = Number(el.duration);
        try { URL.revokeObjectURL(el.src); } catch {}
        resolve(Number.isFinite(d) ? d : null);
      };
      el.onerror = () => {
        try { URL.revokeObjectURL(el.src); } catch {}
        resolve(null);
      };
      el.src = URL.createObjectURL(blob);
    });
  } catch {
    return null;
  }
}

function safeJson(obj) {
  try { return JSON.stringify(obj, null, 2); } catch { return String(obj); }
}

function clampStr(s, max = 140) {
  const x = String(s || "");
  return x.length <= max ? x : x.slice(0, max - 1) + "…";
}

function supportedMimeSnapshot() {
  const types = [
    "audio/webm;codecs=opus",
    "audio/webm",
    "audio/ogg;codecs=opus",
    "audio/ogg",
    "audio/wav",
  ];

  const out = {};
  if (!window.MediaRecorder || typeof MediaRecorder.isTypeSupported !== "function") {
    out._mediaRecorder = "missing";
    return out;
  }

  for (const t of types) out[t] = MediaRecorder.isTypeSupported(t);
  return out;
}

function ensureCss() {
  if (document.getElementById("luxAudioInspectorCSS")) return;

  const style = document.createElement("style");
  style.id = "luxAudioInspectorCSS";
  style.textContent = `
  .lux-audio-inspector {
    position: fixed;
    right: 14px;
    bottom: 14px;
    width: min(440px, calc(100vw - 28px));
    max-height: min(62vh, 520px);
    overflow: hidden;
    z-index: 999999;
    border-radius: 16px;
    border: 1px solid rgba(255,255,255,0.16);
    background: rgba(15, 23, 42, 0.86);
    box-shadow: 0 16px 40px rgba(0,0,0,0.40);
    backdrop-filter: blur(14px);
    color: rgba(255,255,255,0.92);
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
  }
  .lux-audio-inspector * { box-sizing: border-box; }
  .lux-audio-inspector__top {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 10px;
    padding: 10px 12px;
    border-bottom: 1px solid rgba(255,255,255,0.12);
  }
  .lux-audio-inspector__title {
    font-size: 12px;
    font-weight: 700;
    letter-spacing: 0.02em;
    opacity: 0.95;
  }
  .lux-audio-inspector__btns {
    display: flex;
    align-items: center;
    gap: 6px;
  }
  .lux-audio-inspector__btn {
    font-size: 12px;
    padding: 6px 9px;
    border-radius: 10px;
    border: 1px solid rgba(255,255,255,0.14);
    background: rgba(255,255,255,0.06);
    color: rgba(255,255,255,0.92);
    cursor: pointer;
  }
  .lux-audio-inspector__btn:hover {
    background: rgba(255,255,255,0.10);
  }
  .lux-audio-inspector__body {
    padding: 10px 12px;
    overflow: auto;
    max-height: calc(min(62vh, 520px) - 46px);
  }
  .lux-audio-inspector__pre {
    margin: 0;
    font-size: 11px;
    line-height: 1.25rem;
    white-space: pre-wrap;
    word-break: break-word;
  }
  `;
  document.head.appendChild(style);
}

function ensurePanel() {
  let root = document.getElementById("luxAudioInspector");
  if (root) return root;

  ensureCss();

  root = document.createElement("div");
  root.id = "luxAudioInspector";
  root.className = "lux-audio-inspector";
  root.innerHTML = `
  <div class="lux-audio-inspector__top">
    <div class="lux-audio-inspector__title">🎙️ Audio Pipeline Inspector</div>
    <div class="lux-audio-inspector__btns">
      <button class="lux-audio-inspector__btn" data-act="mode">Mode: ?</button>
      <button class="lux-audio-inspector__btn" data-act="copy">Copy</button>
      <button class="lux-audio-inspector__btn" data-act="hide">Hide</button>
    </div>
  </div>
  <div class="lux-audio-inspector__body">
    <pre class="lux-audio-inspector__pre" id="luxAudioInspectorPre"></pre>
  </div>
`;

  root.querySelector('[data-act="hide"]')?.addEventListener("click", () => {
    root.remove();
  });

  root.querySelector('[data-act="copy"]')?.addEventListener("click", async () => {
    const pre = root.querySelector("#luxAudioInspectorPre");
    const text = pre?.textContent || "";
    try {
      await navigator.clipboard.writeText(text);
    } catch {
      // ignore
    }
  });

  root.querySelector('[data-act="mode"]')?.addEventListener("click", () => {
    const cur = (localStorage.getItem("luxAudioMode") || "normal").toLowerCase();
    const next = cur === "pro" ? "normal" : "pro";
    localStorage.setItem("luxAudioMode", next);

    // ✅ Reload so next getUserMedia uses new constraints
    location.reload();
  });

  document.body.appendChild(root);
  return root;
}

const state = {
  enabled: false,
  // last stream/recorder info
  scope: null, // "practice" | "convo"
  device: null,
  trackSettings: null,
  trackConstraints: null,
  recorderMimeType: null,
  // last blob
  blobType: null,
  blobSize: null,
  blobDuration: null,
  // last upload
  uploadEndpoint: null,
  uploadName: null,
  uploadType: null,
  uploadSize: null,
  uploadTextLen: null,
  // constants (backend policy)
  backendConversion: {
    from: "audio/webm (MediaRecorder blob)",
    to: "audio/wav PCM s16 16kHz mono (ffmpeg: -ar 16000 -ac 1 -f wav -sample_fmt s16)",
    azureHeader: "Content-Type: audio/wav; codecs=audio/pcm; samplerate=16000",
    granularity: "Phoneme (Pronunciation-Assessment header)",
  },
};

function render() {
  if (!state.enabled) return;

  const root = ensurePanel();
  const pre = root.querySelector("#luxAudioInspectorPre");
  if (!pre) return;

  const mode = (localStorage.getItem("luxAudioMode") || "normal").toLowerCase() === "pro"
    ? "pro"
    : "normal";

  const modeBtn = root.querySelector('[data-act="mode"]');
  if (modeBtn) modeBtn.textContent = `Mode: ${mode.toUpperCase()}`;

  const lines = [];

  lines.push(`Scope: ${state.scope || "-"}`);
  lines.push(`Audio Mode: ${mode.toUpperCase()}`);
  lines.push("");
  lines.push(`Page: ${clampStr(location.pathname + location.search, 120)}`);
  lines.push(`UA: ${clampStr(navigator.userAgent, 180)}`);
  lines.push("");

  lines.push("== Browser Recording (source) ==");
  lines.push(`MediaRecorder: ${window.MediaRecorder ? "yes" : "no"}`);
  lines.push(`Recorder mimeType: ${state.recorderMimeType || "-"}`);
  lines.push("Supported mimeTypes:");
  lines.push(safeJson(supportedMimeSnapshot()));
  lines.push("");

  lines.push("== Microphone / Track ==");
  lines.push(`Device: ${state.device || "-"}`);
  lines.push("Track settings:");
  lines.push(state.trackSettings ? safeJson(state.trackSettings) : "-");
  lines.push("Track constraints:");
  lines.push(state.trackConstraints ? safeJson(state.trackConstraints) : "-");
  lines.push("");

  lines.push("== Last Captured Blob (what you recorded) ==");
  lines.push(`Blob type: ${state.blobType || "-"}`);
  lines.push(`Blob size: ${state.blobSize != null ? fmtBytes(state.blobSize) : "-"}`);
  lines.push(`Blob duration: ${state.blobDuration != null ? `${state.blobDuration.toFixed(2)}s` : "-"}`);
  lines.push("");

  lines.push("== Upload (what you send to backend) ==");
  lines.push(`Endpoint: ${state.uploadEndpoint || "-"}`);
  lines.push(`Name: ${state.uploadName || "-"}`);
  lines.push(`Type: ${state.uploadType || "-"}`);
  lines.push(`Size: ${state.uploadSize != null ? fmtBytes(state.uploadSize) : "-"}`);
  lines.push(`Text length: ${state.uploadTextLen != null ? state.uploadTextLen : "-"}`);
  lines.push("");

  lines.push("== Backend Conversion (what Azure receives) ==");
  lines.push(`Convert: ${state.backendConversion.from}`);
  lines.push(`      -> ${state.backendConversion.to}`);
  lines.push(`Azure:  ${state.backendConversion.azureHeader}`);
  lines.push(`Assess: ${state.backendConversion.granularity}`);
  lines.push("");

  pre.textContent = lines.join("\n");
}

async function inferDeviceLabel(stream) {
  try {
    const track = stream?.getAudioTracks?.()?.[0];
    if (!track) return null;

    // Track label is often the nicest
    if (track.label) return track.label;

    // fallback: enumerate devices and match deviceId
    const settings = track.getSettings?.() || {};
    const deviceId = settings.deviceId;
    if (!deviceId || !navigator.mediaDevices?.enumerateDevices) return null;

    const devices = await navigator.mediaDevices.enumerateDevices();
    const hit = devices.find(d => d.kind === "audioinput" && d.deviceId === deviceId);
    return hit?.label || null;
  } catch {
    return null;
  }
}

const AudioInspector = {
  enable() {
    state.enabled = true;
    try { localStorage.setItem(LS_KEY, "1"); } catch {}
    render();
  },

  disable() {
    state.enabled = false;
    try { localStorage.removeItem(LS_KEY); } catch {}
    const el = document.getElementById("luxAudioInspector");
    if (el) el.remove();
  },

  init() {
    state.enabled = isEnabled();
    if (state.enabled) render();
  },

  // Call this when you have the stream
  async noteStream(stream, scope = null) {
    if (!state.enabled) return;
    state.scope = scope || state.scope || "-";

    try {
      const track = stream?.getAudioTracks?.()?.[0];
      state.trackSettings = track?.getSettings?.() || null;
      state.trackConstraints = track?.getConstraints?.() || null;
      state.device = await inferDeviceLabel(stream);
    } catch {
      // ignore
    }

    render();
  },

  // Call this when you create MediaRecorder
  noteRecorder(recorder) {
    if (!state.enabled) return;
    try {
      state.recorderMimeType = recorder?.mimeType || null;
    } catch {
      // ignore
    }
    render();
  },

  // Call this when recording stops and you create the blob
  async noteBlob(blob) {
    if (!state.enabled) return;
    try {
      state.blobType = blob?.type || null;
      state.blobSize = blob?.size ?? null;
      state.blobDuration = await probeBlobDurationSeconds(blob);
    } catch {
      // ignore
    }
    render();
  },

  // Call this where you upload the blob
  noteUpload({ endpoint, name, blob, text }) {
    if (!state.enabled) return;
    try {
      state.uploadEndpoint = endpoint || null;
      state.uploadName = name || null;
      state.uploadType = blob?.type || null;
      state.uploadSize = blob?.size ?? null;
      state.uploadTextLen = typeof text === "string" ? text.length : null;
    } catch {
      // ignore
    }
    render();
  },
};

// Auto-init on import
try { AudioInspector.init(); } catch {}

export default AudioInspector;
</file>

<file path="features/recorder/audio-mode-core.js">
// features/recorder/audio-mode-core.js
// Shared state helpers for Audio Mode (NORMAL / PRO)

export const AUDIO_MODES = {
  NORMAL: "NORMAL",
  PRO: "PRO",
};

const KEY = "luxAudioMode";

/**
 * Convert "NORMAL"/"PRO" -> html dataset value: "normal"/"pro"
 */
function toDatasetValue(mode) {
  return mode === AUDIO_MODES.PRO ? "pro" : "normal";
}

/**
 * Ensure <html data-lux-audio-mode="normal|pro">
 * (your CSS targets this)
 */
export function initAudioModeDataset(mode) {
  const html = document.documentElement;
  if (!html) return;

  html.setAttribute("data-lux-audio-mode", toDatasetValue(mode));
}

/**
 * Read from localStorage (defaults to NORMAL)
 */
export function getAudioMode() {
  try {
    const raw = localStorage.getItem(KEY);
    if (raw === AUDIO_MODES.PRO) return AUDIO_MODES.PRO;
    return AUDIO_MODES.NORMAL;
  } catch {
    return AUDIO_MODES.NORMAL;
  }
}

/**
 * Store to localStorage + update dataset
 */
export function setAudioMode(mode) {
  const safe = mode === AUDIO_MODES.PRO ? AUDIO_MODES.PRO : AUDIO_MODES.NORMAL;

  try {
    localStorage.setItem(KEY, safe);
  } catch {
    // ignore storage failures (private mode etc.)
  }

  initAudioModeDataset(safe);
  return safe;
}
</file>

<file path="features/results/rows.js">
/* ============================================================================
   CANONICAL ROW BUILDER (WORDS + PHONEMES)
   ---------------------------------------------------------------------------
   - REFACTORED: No longer generates internal tooltips/videos.
   - PURE LAYOUT: Generates "dumb" chips with data-ipa attributes.
   - This fixes the "White Space" bug by removing hidden DOM bloat.
============================================================================ */

import { norm } from "../../src/data/phonemes/core.js";
import { buildYouglishUrl } from "../../helpers/core.js";
import { scoreClass } from "../../core/scoring/index.js";

// Logic import
import { calculateWordStats } from "./rows-logic.js";
import { renderSyllableStrip } from "./syllables.js";

// View helper imports
import { renderProsodyRibbon } from "./deps.js";

export function buildRows(words, timings, med) {
  return (words || [])
    .map((word, i) => {
      // 1. Calculate Stats
      const { 
        penalty, 
        adjScore, 
        errText, 
        rawScore 
      } = calculateWordStats(word, i, timings, med);

      // 2. Render Components
      const ribbon =
        typeof renderProsodyRibbon === "function"
          ? renderProsodyRibbon(i, words, timings, med)
          : "";

      const syllablesHtml = renderSyllableStrip(word);

      // 3. Render Phonemes (CLEAN VERSION)
      // We do NOT render .tooltiptext or <video> here anymore.
      // We just render the trigger chip with data attributes.
      const phonemesHtml = (word.Phonemes || [])
        .map((ph) => {
          // Normalize the IPA symbol so the chips system can find it later
          const ipaRaw = ph.Phoneme;
          const ipaNorm = norm(ipaRaw);
          
          // Color class based on score
          const colorCls = scoreClass(ph.AccuracyScore);
          
          // Note: We use 'phoneme-chip' for styling.
          // We DO NOT add 'tooltip' class here if that class triggers CSS-based popups.
          // The JS-based global hover will handle it.
          return `
          <span 
            class="phoneme-chip ${colorCls}" 
            data-ipa="${ipaNorm}"
            data-score="${ph.AccuracyScore}"
            style="cursor: pointer;"
          >
            ${ipaRaw /* Display the raw symbol from Azure, usually safest */}
            <span style="font-size: 0.8em; opacity: 0.7; margin-left: 2px;">
                (${ph.AccuracyScore}%)
            </span>
          </span>`;
        })
        .join(" "); // Space separated for cleaner wrapping

      // 4. Assemble Row
      return `
        <tr>
          <td class="word-cell">
            ${ribbon}
            <a href="${buildYouglishUrl(word.Word)}" 
               target="_blank" 
               rel="noopener noreferrer"
               title="Hear '${word.Word}' on YouGlish" 
               class="${scoreClass(rawScore)}">
              ${word.Word}
            </a>
          </td>

          <td class="syllable-cell">
            ${syllablesHtml}
          </td>

          <td class="score-cell">${
            word.AccuracyScore !== undefined
              ? `${rawScore}%` +
                (penalty
                  ? ` <span title="Prosody-adjusted">· adj ${adjScore}%</span>`
                  : "")
              : "–"
          }</td>
          <td class="error-cell">${errText || ""}</td>
          <td>
            <div style="display:flex; flex-wrap:wrap; gap:6px; justify-content:center;">
              ${phonemesHtml}
            </div>
          </td>
        </tr>`;
    })
    .join("");
}
</file>

<file path="features/results/syllables.js">
// features/results/syllables.js
// Renders [syllables] with a glowing "expected stress" syllable.
//
// NOTE (Azure): The API provides syllable objects + accuracy,
// but does NOT directly label lexical stress.
// So this v1 highlights a best-guess “expected stress” based on a small override list,
// with a safe default (first syllable) when unknown.

function escapeHtml(s) {
  return String(s ?? "")
    .replaceAll("&", "&amp;")
    .replaceAll("<", "&lt;")
    .replaceAll(">", "&gt;")
    .replaceAll('"', "&quot;")
    .replaceAll("'", "&#039;");
}

// Small “starter lexicon” (easy to expand later)
const EXPECTED_STRESS_OVERRIDES = {
  // common multi-syllable words (index is 0-based)
  computer: 1,     // com-PU-ter
  about: 1,        // a-BOUT
  before: 1,       // be-FORE
  today: 1,        // to-DAY
  hotel: 1,        // ho-TEL (often)
  pocket: 0,       // POCK-et

  // classic stress-shift words (default = noun/adjective stress)
  record: 0,       // RE-cord (noun) vs re-CORD (verb)
  present: 0,      // PRE-sent vs pre-SENT
  contract: 0,     // CON-tract vs con-TRACT
  permit: 0,       // PER-mit vs per-MIT
  protest: 0,      // PRO-test vs pro-TEST
  conduct: 0,      // CON-duct vs con-DUCT
  import: 0,       // IM-port vs im-PORT
  export: 0,       // EX-port vs ex-PORT
  object: 0,       // OB-ject vs ob-JECT
  project: 0,      // PRO-ject vs pro-JECT
  increase: 0,     // IN-crease vs in-CREASE
};

function getExpectedStressIndex(wordText, syllableCount) {
  if (!syllableCount || syllableCount <= 1) return 0;

  const w = String(wordText || "").toLowerCase().replace(/[^a-z']/g, "");
  if (!w) return 0;

  if (w in EXPECTED_STRESS_OVERRIDES) {
    const idx = EXPECTED_STRESS_OVERRIDES[w];
    return Math.max(0, Math.min(syllableCount - 1, idx));
  }

  // Safe default until you add a real stress dictionary
  return 0;
}

function normalizeSyllables(wordObj) {
  // Azure typically returns word.Syllables = [{ Syllable, AccuracyScore, Offset, Duration }, ...]
  const syls = wordObj?.Syllables;
  if (Array.isArray(syls) && syls.length) return syls;

  // Fallback: treat whole word as 1 syllable
  return [{ Syllable: wordObj?.Word || "" }];
}

function getSylText(sylObj) {
  // be defensive about casing
  const raw =
    sylObj?.Syllable ??
    sylObj?.syllable ??
    sylObj?.Text ??
    sylObj?.text ??
    "";

  // If stress markers ever appear (ˈ ˌ), strip them for display
  return String(raw).replace(/[ˈˌ]/g, "");
}

export function renderSyllableStrip(wordObj) {
  const wordText = wordObj?.Word || "";
  const syls = normalizeSyllables(wordObj);

  const stressIdx = getExpectedStressIndex(wordText, syls.length);

  const pieces = syls
    .map((s, i) => {
      const t = getSylText(s);
      const cls = i === stressIdx ? "lux-syl is-stress" : "lux-syl";
      return `<span class="${cls}">${escapeHtml(t)}</span>`;
    })
    .join("");

  const title =
    syls.length > 1
      ? `Expected stress highlighted (v1 heuristic)`
      : `Single-syllable word`;

  return `<div class="lux-sylStrip" title="${escapeHtml(title)}">${pieces}</div>`;
}
</file>

<file path="lux-convo.chat.css">
/* ============================================================
   Chat panel (single centered)
   ============================================================ */
.lux-chatwrap{ width: 100%; }

/* Chat: Practice Skills pill floats above-left of the chat panel */
#convoApp[data-mode="chat"] .lux-toplinks-chat{
  width: min(980px, 94vw);
  margin: 8px auto -6px;     /* slight overlap with panel */
  display: flex;
  justify-content: flex-start;
  position: relative;
  z-index: 80;
}

/* Prevent any stretching weirdness */
#convoApp[data-mode="chat"] .lux-toplinks-chat .lux-navpill{
  align-self: flex-start;
  width: min(420px, 92vw);   /* match your global pill size */
  transform: translateX(-10px);
}

/* NEW: AI Conversations progress panel (only shown in chat mode via the mode-routing rules above)
   - aligns to the same width as the chat box
   - sits directly under the chat panel */
.lux-convo-progress{
  width: 100%;
  margin-top: 14px;
  padding: 0 16px 18px;
  display: flex;            /* safe even when hidden; display gets overridden by mode routing */
  justify-content: center;
}
.lux-convo-progress > *{
  width: min(980px, 94vw);  /* match .lux-chat width */
}

.lux-chat{
  width: min(980px, 94vw);
  height: min(78vh, 760px);
  min-height: 560px;
  display:flex;
  flex-direction: column;
}

/* AI Coach drawer wrapper: match chat width */
#convoApp .lux-ai-drawer{
  width: min(980px, 94vw);
  max-width: none;
  padding: 0;
  margin: 14px auto 0;
}

#convoApp #aiCoachDrawer #aiFeedbackSection{
  width: 100%;
  margin: 0;
}

/* Only show coach in chat mode (prevents it appearing on intro/picker screens) */
#convoApp:not([data-mode="chat"]) #aiCoachDrawer{
  display: none;
}
#convoApp[data-mode="chat"] #aiCoachDrawer{
  display: block;
}



.lux-msgs{
  padding: 14px;
  overflow:auto;
  flex: 1;
}

.msg{
  max-width: 88%;
  padding: 10px 12px;

  border-radius: 14px;
  border: 1px solid rgba(0,0,0,0.08);
  background: var(--convo-tint);

  margin-bottom: 10px;
  line-height: 1.35;
  font-size: 14px;
  color: var(--convo-ink);
}
.msg.assistant{ margin-right:auto; }
.msg.user{
  margin-left:auto;
  background: #e9f1ff;
  border-color: rgba(0,120,215,0.25);
}

/* Suggestions */
.lux-sugs{
  padding: 10px 14px 0;
  display:flex;
  flex-wrap: wrap;
  gap: 8px;
}
.sug{
  border: 1px solid rgba(0,0,0,0.10);
  background: rgba(255,255,255,0.70);
  color: #334155;
  border-radius: 999px;

  padding: 6px 10px;
  cursor:pointer;

  font-size: 12px;
  font-weight: 850;
  line-height: 1.2;
}
.sug:hover{ border-color: rgba(0,120,215,0.25); }

/* Composer */
.lux-compose{
  border-top: 1px solid rgba(0,0,0,0.10);
  padding: 12px;

  display:grid;
  grid-template-columns: 1fr auto;
  gap: 10px;
  align-items: center;
}
#convoApp.is-recording .lux-compose{
  outline: 2px solid rgba(255, 80, 80, 0.7);
  outline-offset: 4px;
}

.lux-in{
  width:100%;
  min-height: 44px;
  resize: vertical;

  border-radius: 0.8rem;
  border: 1px solid rgba(0,0,0,0.18);
  background: #fff;
  color: var(--convo-ink);

  padding: 10px 12px;
  outline:none;

  font-size: 1rem;
  font-weight: 800;
}

/* =========================
   Target highlighting + coach tips
   ========================= */
.lux-hl{
  background: rgba(250, 204, 21, 0.35);
  border-radius: 6px;
  padding: 0 2px;
  font-weight: 900;
}

/* Phoneme-focus injected words */
.lux-hl2{
  background: rgba(59, 130, 246, 0.28);
  border-radius: 6px;
  padding: 0 2px;
  font-weight: 900;
}

/* Double-hit (word-bank + phoneme-focus): blue base + yellow underline */
.lux-hl.lux-hl2{
  background: rgba(59, 130, 246, 0.28);
  box-shadow: inset 0 -2px 0 rgba(250, 204, 21, 0.85);
}

/* Double-hit: word-bank + focus-sound at the same time
   Keep it "never overwhelming": reuse yellow, add a subtle blue inset outline. */
.lux-hl3{
  background: rgba(250, 204, 21, 0.35);
  border-radius: 6px;
  padding: 0 2px;
  font-weight: 900;
  box-shadow: 0 0 0 1px rgba(59, 130, 246, 0.55) inset;
}

.lux-coachbar{
  padding: 10px 14px 0;
}
.lux-coachcard{
  border: 1px solid rgba(255,255,255,0.12);
  background: rgba(15, 23, 42, 0.55);
  border-radius: 14px;
  box-shadow: 0 6px 18px rgba(0,0,0,0.20);
  padding: 10px 12px;
  display:flex;
  gap: 10px;
  align-items:flex-start;
  justify-content: space-between;
  margin-bottom: 10px;
}
.lux-coachcard .lux-coachtext{
  color:#e5e7eb;
  font-size: 13px;
  line-height: 1.25rem;
}
.lux-coachcard .lux-coachtext strong{
  display:block;
  font-size: 13px;
  margin-bottom: 2px;
}
.lux-coachcard .lux-coachmeta{
  color: rgba(229,231,235,0.72);
  font-size: 12px;
  margin-top: 6px;
}
.lux-coachcard .lux-coachbtn{
  white-space: nowrap;
}

.lux-sugsNote{
  padding: 6px 14px 0;
  color: rgba(226,232,240,0.82);
  font-size: 12px;
}

/* Buttons */
.btn{
  border: none;
  background: var(--convo-accent);
  color: #fff;

  border-radius: 0.7rem;
  padding: 10px 14px;

  cursor:pointer;
  font-weight: 850;
  font-size: 0.95rem;
  white-space: nowrap;
}
.btn:hover{ background: var(--convo-accent-hover); }

.btn.ghost{
  background: rgba(255,255,255,0.70);
  color: var(--convo-ink);
  border: 1px solid rgba(0,0,0,0.10);
}
.btn.ghost:hover{ background: rgba(255,255,255,0.92); }

.btn.primary{
  background: var(--convo-accent);
  color: #fff;
}
.btn.danger{
  background: #dc2626;
  color: #fff;
}
.btn.danger:hover{ background: #b91c1c; }


/* Chat typography bump (parity w/ lux-convo.full.css) */
#convoApp[data-mode="chat"] .lux-title{ font-size: 20px; }
#convoApp[data-mode="chat"] .lux-sub{ font-size: 14px; }

#convoApp[data-mode="chat"] .lux-actions .btn{
  font-size: 1.05rem;
  padding: 10px 12px;
}

#convoApp[data-mode="chat"] .msg{
  font-size: 16px;
  line-height: 1.55;
}

#convoApp[data-mode="chat"] .sug{
  font-size: 14px;
  padding: 8px 12px;
}

#convoApp[data-mode="chat"] .lux-in{
  font-size: 1.1rem;
  padding: 12px 12px;
}


/* ============================================================
   Responsive tuning
   ============================================================ */
@media (max-width: 980px){
  #convoApp{
    min-height: auto;
    border-radius: 18px;
  }

  .lux-chat{
    min-height: 520px;
    height: auto;
  }

  .lux-deck{
    height: 420px;
  }
}

@media (max-width: 520px){
  .lux-heroTitle{ font-size: 30px; }
  .lux-deckTitle{ font-size: 24px; }
}
</file>

<file path="lux-layout.ai-feedback.css">
/* lux-layout.ai-feedback.css */

#aiFeedback {
  background: #eef7fe; padding: 1.1em 1em; border: 1px solid #c9e2ff; border-radius: 1em; margin-top: 25px;
  font-size: 1.14em; line-height: 1.68; color: #223; box-shadow: 0 2px 16px rgba(60, 90, 155, 0.06);
}
#aiFeedback h2, #aiFeedback h3, #aiFeedback strong {
  color: #096; display: block; margin-top: 0.7em; margin-bottom: 0.25em; font-size: 1.1em;
  position: relative; overflow: hidden;
}
#aiFeedback h2::after, #aiFeedback h3::after, #aiFeedback strong::after {
  content: ""; position: absolute; bottom: 0; left: 0; height: 2px; width: 100%;
  background: currentColor; transform: scaleX(0); transform-origin: left; transition: transform 1.5s ease;
}
.underline-start::after { transform: scaleX(1); }
#aiFeedback ul { margin: 0.2em 0 1em 1.5em; padding: 0; list-style: disc inside; }
#aiFeedback li { margin: 0.14em 0; }
#aiFeedback em { color: #296aac; }
#prettyResult {
  overflow-x: auto; overflow-y: visible !important; overflow: visible !important;
  max-height: none !important; height: auto !important; padding-bottom: 1.15rem;
}
.en-text.hidden { display: none; }
#aiFeedback h3 { margin-top: 1.25em; padding-bottom: 0.2em; border-bottom: 1px solid #ddd; }
.ai-progress {
  position: relative; height: 4px; margin-top: 8px; background: #cfe5ff; overflow: hidden; border-radius: 2px;
}
.ai-progress::before {
  content: ""; position: absolute; inset: 0; width: 40%;
  background: linear-gradient(90deg, #0078d7 0%, #44a8ff 50%, #0078d7 100%);
  animation: aiLoad 1.2s linear infinite;
}
@keyframes aiLoad {
  from { left: -40%; }
  to { left: 100%; }
}
.toggle-en-btn {
  margin: 0.5em 0; padding: 0.35em 1em; font-size: 0.97em; cursor: pointer;
  background: #f6f6f6; border: 1px solid #ddd; border-radius: 6px; font-weight: 600; color: #222;
  transition: background 0.18s;
}
.toggle-en-btn:hover { background: #e0e0e0; }
</file>

<file path="lux-layout.messaging.css">
/* lux-layout.messaging.css */

#userMsg {
  background: #e7f2fb;
  color: #134e6f;
  padding: 1em 0.7em;
  border-radius: 0.7em;
  opacity: 0;
  transform: translateY(-40px);
  transition: opacity 0.7s ease,
    transform 0.7s cubic-bezier(0.47, 1.64, 0.41, 0.8);
  pointer-events: none; /* don't block clicks while hidden */
}
#userMsg.show {
  opacity: 1;
  transform: translateY(0);
  pointer-events: auto; /* allow database tracking click once visible */
}
#userMsg ol {
  margin: 0;
  padding-left: 1.2em;
}
#userMsg li {
  margin-bottom: 0.5em;
  font-size: 1.09em;
  line-height: 1.5;
}

#suggested-section {
  margin: 32px 0 18px;
  padding: 12px 0;
  font-size: 1.25em;
  background: #f3faff;
  border-radius: 0.8em;
  font-weight: 700;
  box-shadow: 0 2px 8px rgba(40, 120, 255, 0.09);
}

.raw-data-section {
  background: #f3f3f3;
  margin: 1em auto;
  padding: 15px;
  border-radius: 6px;
  font-size: 1.16em;
  max-width: 96vw;
  max-height: 340px;
  overflow: auto;
  display: none;
  text-align: left;
}

.show-raw-link {
  cursor: pointer;
  color: #0083ff;
  text-decoration: underline;
  font-size: 1.12em;
  margin-left: 8px;
}

.btn-group {
  display: flex;
  justify-content: center;
  gap: 12px;
  margin-bottom: 1.3em;
}

/* ✅ Scope button styling ONLY to the messaging button group
   (prevents Word Cloud + the whole app from inheriting white button text) */
.btn-group button {
  font-size: 1.25rem;
  padding: 1rem 2.2rem;
  border: none;
  border-radius: 0.7rem;
  background: #0078d7;
  color: #fff;
  cursor: pointer;
  transition: background 0.15s;
}
.btn-group button:disabled {
  background: #ccc;
  cursor: not-allowed;
}

/* ============================================================
   REMOVED DUPLICATE BLOCKS HERE:
   (Record buttons, Score Table, Word Chips, Tooltips)
   These are now correctly handled by features-1.css
   ============================================================ */

/* Duplicate results-collapse block removed as requested */
</file>

<file path="lux-layout.scrollbar.css">
/* lux-layout.scrollbar.css */

/* ============================================================
   CUSTOM SCROLLBAR (Sleek Blue/Grey)
   ============================================================ */
/* Webkit (Chrome, Safari, Edge) */
.custom-scrollbar::-webkit-scrollbar {
  width: 6px;
  height: 6px; /* Horizontal scrollbar height */
}

.custom-scrollbar::-webkit-scrollbar-track {
  background: #f1f5f9; /* Light slate grey track */
  border-radius: 4px;
}

.custom-scrollbar::-webkit-scrollbar-thumb {
  background: #cbd5e1; /* Soft blue-grey thumb */
  border-radius: 4px;
  transition: background 0.2s;
}

.custom-scrollbar::-webkit-scrollbar-thumb:hover {
  background: #94a3b8; /* Darker on hover */
}

/* Firefox */
.custom-scrollbar {
  scrollbar-width: thin;
  scrollbar-color: #cbd5e1 #f1f5f9;
}
</file>

<file path="lux-layout.top-banner.css">
/* lux-layout.top-banner.css */

/* ============================================================
   Top-of-viewport Tips Banner (fixed; tab remains clickable)
   ============================================================ */
.lux-top-banner{
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  z-index: var(--z-modal);     /* below drawers (900), above content */
  pointer-events: none;        /* wrapper never blocks the viewport */
}

/* The sliding panel */
.lux-top-banner-panel{
  pointer-events: auto;
  transform: translateY(-110%);
  transition: transform 420ms cubic-bezier(0.22, 1.0, 0.36, 1.0);
}

/* Reveal after delay */
.lux-top-banner.is-revealed:not(.is-collapsed) .lux-top-banner-panel{
  transform: translateY(0);
}

/* Collapsed always hides the panel */
.lux-top-banner.is-collapsed .lux-top-banner-panel{
  transform: translateY(-110%);
}

/* Center align to Lux page width */
.lux-top-banner-inner{
  max-width: 1280px;
  margin: 0 auto;
  padding: 10px 10px 0;
  box-sizing: border-box;
}

/* Always-visible center stub handle (hangs off the panel edge) */
.lux-banner-handle{
  position: fixed;
  left: 50%;
  top: var(--lux-banner-handle-top, 16px);
  transform: translate(-50%, -50%);
  z-index: var(--z-modal);
  pointer-events: auto;

  border: 1px solid rgba(0,0,0,0.10);
  border-radius: 999px;
  padding: 7px 14px;

  background: #e8f2ff; /* should match/feel like the blue box */
  color: #0b2a44;

  font-weight: 800;
  font-size: 13px;
  cursor: pointer;

  box-shadow: 0 10px 20px rgba(0,0,0,0.14);
  transition: box-shadow 160ms ease, background 160ms ease, transform 140ms ease, opacity 160ms ease;
}

/* Make layout stable + allow icon sizing */
.lux-banner-handle{
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  line-height: 1; /* helps icon alignment */
}

/* Bigger, crisp caret that inherits text color (stays dark) */
.lux-banner-caret{
  width: 16px;
  height: 16px;
  display: inline-block;
  transform-origin: 50% 50%;
  transition: transform 160ms ease;
}

/* Tips handle: lock hitbox (no hover motion), halo + tint */
button.lux-banner-handle:hover:not(:disabled),
button.lux-banner-handle:focus-visible:not(:disabled){
  transform: translate(-50%, -50%) !important; /* cancels global hover translate/scale */
  filter: none !important;

  background: #eef6ff;
  box-shadow:
    0 10px 20px rgba(0,0,0,0.16),
    0 0 0 3px rgba(0,120,215,0.22);
}

/* Caret cue only (subtle) */
button.lux-banner-handle:hover .lux-banner-caret,
button.lux-banner-handle:focus-visible .lux-banner-caret{
  transform: rotate(12deg);
}

button.lux-banner-handle:active:not(:disabled){
  transform: translate(-50%, -50%) scale(0.96) !important;
}

.lux-banner-handle:active{
  transform: translate(-50%, -50%) scale(0.96);
}
</file>

<file path="lux-results.css">
/* lux-results.css */
/* Wrapper entry — split modules */

@import "./lux-results.table.css";
@import "./lux-results.prosody.css";
@import "./lux-results.legacy.css";
@import "./lux-results.ai.css";
@import "./lux-results.accordion.css";
</file>

<file path="lux-widgets.buttons.css">
/* lux-widgets.buttons.css */
/* Global button system */

/* ============================================================
   Buttons → recording states & effects
   ============================================================ */
#record::before { content: "🎙️  "; display: inline-block; }
#stop::before { content: "🛑  "; }
#nextPartBtn::before { content: "➡️  "; }

#record.record-intro,
#record.record-glow,
#record.record-intro:disabled,
#record.record-glow:disabled {
  background: var(--rec-base);
  color: var(--rec-ink);
}

#record {
  position: relative;
  overflow: hidden;
}

#stop.processing {
  position: relative;
  overflow: hidden;
  color: transparent;
}

#stop.processing::after {
  content: "Stopping…";
  position: absolute;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: 600;
  color: #fff;
  border-radius: inherit;
  white-space: nowrap;
  background: repeating-linear-gradient(
    135deg,
    #34d399 0 10px,
    #059669 10px 20px
  );
  background-size: 200% 100%;
  animation: stripeMove 1s linear infinite;
}

@keyframes stripeMove {
  from { background-position: 0 0; }
  to { background-position: 40px 0; }
}
</file>

<file path="lux-widgets.core.css">
/* lux-widgets.core.css */
/* Base widget styles + reusable helpers (pills/spinners/etc.) */

/* ============================================================
   Global utilities → link styles for results table
   ============================================================ */
#prettyResult a {
  text-decoration: none !important;
  font-weight: 700;
}

#prettyResult a:visited,
#prettyResult a:active,
#prettyResult a:focus {
  text-decoration: none !important;
}

#prettyResult a:hover {
  text-decoration: none !important;
}

/* ============================================================
                           Spinner
   ============================================================ */
@keyframes slowSpin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}
.ai-spinner {
  display: inline-block;
  animation: slowSpin 2.4s linear infinite;
}

/* ============================================================
                           Global interactive hover cues
   ============================================================ */
#prettyResult a,
#prettyResult .tooltip {
  display: inline-block;
  transition: transform 0.18s ease, box-shadow 0.18s ease;
}
#prettyResult a:hover,
#prettyResult .tooltip:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.28);
}
#prettyResult a:active,
#prettyResult .tooltip:active {
  transform: translateY(0);
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
}

#prettyResult tbody a.word-chip {
  transition: transform 0.18s ease, box-shadow 0.18s ease;
}

#prettyResult th .phoneme-chip {
  transition: box-shadow 0.18s ease, transform 0.16s ease, filter 0.18s ease;
}
#prettyResult th#phonemeHeader .phoneme-chip:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.28);
}
#prettyResult th#phonemeHeader .phoneme-chip:active {
  transform: translateY(0);
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
}

#referenceText,
#partsInfoTip {
  transition: transform 0.18s ease, box-shadow 0.18s ease;
}
#referenceText:hover,
#partsInfoTip:hover {
  transform: translateY(-2px);
  filter: none;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.28);
}

/* ============================================================
                           Tooltip base
   ============================================================ */
.tooltip {
  position: relative;
  display: inline-block;
  cursor: pointer;
  margin-left: 3px;
  border-bottom: none !important;
}
.result-tip {
  border-bottom: none !important;
}

.tooltip .tooltiptext {
  visibility: hidden;
  opacity: 0;
  transition: opacity 0.4s;
  position: absolute;
  left: 50%;
  top: 99%;
  transform: translateX(-50%);
  background: #444;
  color: #fff;
  padding: 10px;
  border-radius: 5px;
  min-width: 240px;
  max-width: 520px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
  white-space: normal;
  word-wrap: break-word;
  overflow: hidden;
  z-index: var(--z-popover);
}
.tooltip:hover .tooltiptext {
  visibility: visible;
  opacity: 1;
}
.tooltip:hover,
.tooltip:focus-within {
  z-index: var(--z-popover);
}

/* ============================================================
                           Reusable chips (word)
   ============================================================ */
.word-chip {
  display: inline-block;
  background: #eef7fb;
  color: #205080;
  font-weight: 700;
  font-size: 1.12em;
  padding: 4px 18px;
  border-radius: 20px;
  box-shadow: 0 2px 8px rgba(40, 120, 255, 0.13);
  transition: box-shadow 0.18s, transform 0.16s, filter 0.18s, opacity 0.25s, transform 0.25s;
  cursor: pointer;
  user-select: none;
}

/* ============================================================
                           Visibility helpers
   ============================================================ */
.fade-vis {
  opacity: 1;
  transition: opacity 0.26s ease;
}
.fade-vis.is-hidden {
  opacity: 0;
  pointer-events: none;
}
</file>

<file path="lux-widgets.record-viz.css">
/* lux-widgets.record-viz.css */
/* Record button states + mic visualizer bars */

/* ============================================================
   Record button: Live Mic Level Viz (equalizer bars)
   ============================================================ */

/* Keep button stable + allow overlay visuals */
#record {
  position: relative;
  overflow: hidden;
}

/* Label sits above everything */
#record .lux-recLabel{
  position: relative;
  z-index: 2;
}

/* Equalizer overlay */
#record .lux-recViz{
  position: absolute;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 3px;
  z-index: 3;
  pointer-events: none;
  opacity: 0;
  transform: scale(0.98);
  transition: opacity 0.18s ease, transform 0.18s ease;
}

/* Show the viz only once we’re in the amber “record-glow” phase */
#record.record-glow .lux-recViz,
#record.record-glow:disabled .lux-recViz{
  opacity: 1;
  transform: scale(1);
  transition-delay: 0.82s; /* waits for your green intro stripe to finish */
}

/* Hide label + mic emoji while recording (keeps button width stable) */
#record.record-glow .lux-recLabel,
#record.record-glow:disabled .lux-recLabel,
#record.record-glow::before,
#record.record-glow:disabled::before{
  opacity: 0;
}

/* Individual bars */
#record .lux-recBar{
  width: 4px;
  height: 18px;
  border-radius: 3px;
  background: currentColor;
  opacity: 0.72;
  transform-origin: center bottom;
  transform: scaleY(var(--y, 0.12));
  will-change: transform;
}

@media (prefers-reduced-motion: reduce) {
  #record .lux-recViz { transition: none; }
}

/* ============================================================
   Record button intro stripe sweep
   ============================================================ */
#record.record-intro::after {
  content: "";
  position: absolute;
  inset: 0;
  border-radius: inherit;
  background: repeating-linear-gradient(
    135deg,
    var(--stripe-green-1) 0 10px,
    var(--stripe-green-2) 10px 20px
  );
  background-size: 220% 100%;
  animation: recordSlashGreen 0.8s ease-out forwards;
  pointer-events: none;
}

@keyframes recordSlashGreen {
  from { background-position: -220% 0; opacity: 1; }
  90% { background-position: 0 0; opacity: 1; }
  to { background-position: 0 0; opacity: 0; }
}

/* ============================================================
   Record button glow loop (amber pulse)
   ============================================================ */
#record.record-glow,
#record.record-glow:disabled {
  animation: recordGlowAmber 1.6s ease-in-out infinite;
  box-shadow: 0 0 0 0 var(--rec-glow-soft), 0 0 20px var(--rec-glow-soft);
  filter: brightness(1);
}

@keyframes recordGlowAmber {
  0% {
    box-shadow: 0 0 0 0 var(--rec-glow-soft), 0 0 20px var(--rec-glow-soft);
    filter: brightness(1);
  }
  50% {
    box-shadow: 0 0 0 16px rgba(234, 179, 8, 0), 0 0 38px var(--rec-glow-strong);
    filter: brightness(1.14);
  }
  100% {
    box-shadow: 0 0 0 0 var(--rec-glow-soft), 0 0 20px var(--rec-glow-soft);
    filter: brightness(1);
  }
}

@media (prefers-reduced-motion: reduce) {
  #record.record-glow { animation: none; }
}
</file>

<file path="lux-widgets.results-panels.css">
/* lux-widgets.results-panels.css */
/* Results surfaces + widget panels */

/* ============================================================
                           Result panels
   ============================================================ */

#suggested-section {
  margin: 32px 0 18px;
  padding: 12px 0;
  font-size: 1.25em;
  background: #f3faff;
  border-radius: 0.8em;
  font-weight: 700;
  box-shadow: 0 2px 8px rgba(40, 120, 255, 0.09);
}

.raw-data-section {
  background: #f3f3f3;
  margin: 1em auto;
  padding: 15px;
  border-radius: 6px;
  font-size: 1.16em;
  max-width: 96vw;
  max-height: 340px;
  overflow: auto;
  display: none;
  text-align: left;
}

.show-raw-link {
  cursor: pointer;
  color: #0083ff;
  text-decoration: underline;
  font-size: 1.12em;
  margin-left: 8px;
}
</file>

<file path="lux-widgets.score-tiles.css">
/* lux-widgets.score-tiles.css */
/* Score tiles + rings + compact score visuals */

/* ============================================================
   Results Score Summary (Modal Style)
   Pronunciation ring + 4 metric cards
   ============================================================ */

/* ============================================================
   LUX SCORE PYRAMID (Overall circle + 5 rubric tiles)
   ============================================================ */

.lux-scoreSummary{
  margin-top: 10px;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 10px;
}

.lux-scoreMain{
  display:flex;
  flex-direction: column;
  align-items:center;
  justify-content:center;
}

.lux-scoreMainLabel{
  display:flex;
  align-items:center;
  justify-content:center;
  gap: 6px;
  margin-bottom: 6px;

  color:#64748b;
  font-size: 0.95rem;
  font-weight: 900;
  letter-spacing: 0.02em;
}

.lux-scoreRing{
  width: 82px;
  height: 82px;
  border-radius: 50%;
  border: 4px solid var(--lux-score-ring, #2563eb);

  display:flex;
  align-items:center;
  justify-content:center;

  font-size: 1.45rem;
  font-weight: 900;
  color:#334155;

  background:#fff;
  box-shadow: 0 4px 6px -1px rgba(0,0,0,0.06);
}

.lux-scorePyramid{
  width: min(920px, 94vw);
  display:flex;
  flex-direction: column;
  gap: 8px;
}

/* rows */
.lux-scoreRow{
  display:flex;
  justify-content:center;
  gap: 8px;
  width: 100%;
}

/* pyramid shape: mid row a bit wider */
.lux-scoreRow-mid .lux-scoreTile{
  flex: 1 1 0;
  max-width: 320px;
}
.lux-scoreRow-bottom .lux-scoreTile{
  flex: 1 1 0;
  max-width: 260px;
}

/* flatter tiles (squat pyramid goal) */
.lux-scoreTile{
  border: 1px solid #e2e8f0;
  background: #f8fafc;
  border-radius: 12px;

  /* was ~10px 12px */
  padding: 7px 12px;           /* ✅ squatter */

  text-align: center;
  box-shadow: 0 4px 6px -1px rgba(0,0,0,0.05);
}

.lux-scoreTile-label{
  display:flex;
  align-items:center;
  justify-content:center;
  gap: 6px;

  /* keep same font-size */
  line-height: 1.05;           /* ✅ tighter */

  color:#64748b;
  font-size: 0.92rem;
  font-weight: 900;
}

.lux-scoreTile-value{
  margin-top: 1px;             /* ✅ was 3–4px */
  line-height: 1.05;           /* ✅ tighter */

  color:#0f172a;
  font-size: 1.28rem;
  font-weight: 900;
}

.lux-scoreTile-meta{
  margin-top: 1px;             /* ✅ was 2px */
  line-height: 1.05;

  color:#94a3b8;
  font-size: 0.78rem;
  font-weight: 800;
}

/* ============================================================
   Metric tiles: click-to-expand modal cards (affordance only)
   ============================================================ */
.lux-scoreTile,
.lux-scoreRing{
  cursor: pointer;
  user-select: none;
}

/* Subtle affordance (keeps your Lux vibe) */
.lux-scoreTile:hover,
.lux-scoreRing:hover{
  transform: translateY(-1px);
  box-shadow: 0 10px 18px rgba(0,0,0,0.06);
}

.lux-scoreTile:active,
.lux-scoreRing:active{
  transform: translateY(0px);
}

.lux-scoreTile:focus-visible,
.lux-scoreRing:focus-visible{
  outline: 3px solid rgba(37, 99, 235, 0.25);
  outline-offset: 3px;
}

/* mobile: keep readable without blowing vertical space */
@media (max-width: 640px){
  .lux-scoreRow{ flex-wrap: wrap; }
  .lux-scoreRow-mid .lux-scoreTile,
  .lux-scoreRow-bottom .lux-scoreTile{
    max-width: none;
    flex: 1 1 calc(50% - 10px);
  }
}
</file>

<file path="prosody/core-calc.js">
// prosody/core-calc.js
// Timestamp parsing + timing/stat helpers (ES Module)

function toSec(v) {
  if (v == null) return null;
  if (typeof v === "number" && Number.isFinite(v)) {
    if (v >= 5e6) return v / 1e7;
    if (v >= 1000 && v < 5e6) return v / 1000;
    return v;
  }
  if (typeof v === "string") {
    var s = v.trim();
    if (!s) return null;
    if (/^-?\d+(\.\d+)?$/.test(s)) return toSec(+s);
    var suf = s.match(/^(-?\d+(?:\.\d+)?)(ms|msec|s|sec|secs|seconds)$/i);
    if (suf) {
      var n = parseFloat(suf[1]);
      var u = suf[2].toLowerCase();
      return u === "ms" || u === "msec" ? n / 1000 : n;
    }
    var hms = s.match(/^(\d{1,2}):([0-5]?\d):([0-5]?\d)(?:\.(\d{1,9}))?$/);
    if (hms) {
      var h = +hms[1],
        m = +hms[2],
        sec = +hms[3],
        frac = hms[4] ? parseFloat("0." + hms[4]) : 0;
      return h * 3600 + m * 60 + sec + frac;
    }
    var iso = s.match(
      /^P(?:T(?:(\d+(?:\.\d+)?)H)?(?:(\d+(?:\.\d+)?)M)?(?:(\d+(?:\.\d+)?)S)?)$/i
    );
    if (iso) {
      var ih = parseFloat(iso[1] || "0"),
        im = parseFloat(iso[2] || "0"),
        is = parseFloat(iso[3] || "0");
      return ih * 3600 + im * 60 + is;
    }
    return null;
  }
  if (typeof v === "object") {
    if ("seconds" in v) return toSec(v.seconds);
    if ("ms" in v) return toSec(v.ms);
    if ("ticks" in v) return v.ticks / 1e7;
    if ("Offset" in v || "offset" in v) return toSec(v.Offset ?? v.offset);
    if ("Duration" in v || "duration" in v)
      return toSec(v.Duration ?? v.duration);
  }
  return null;
}

export function ticksToSec(v) {
  return toSec(v);
}

export function median(nums) {
  var a = (nums || [])
    .filter(Number.isFinite)
    .slice()
    .sort(function (x, y) {
      return x - y;
    });
  if (!a.length) return null;
  var mid = Math.floor(a.length / 2);
  return a.length % 2 ? a[mid] : (a[mid - 1] + a[mid]) / 2;
}

export function computeTimings(words = []) {
  const out = [];

  for (const w of words || []) {
    if (!w) continue;

    let start = null;
    let end = null;
    let dur = null;

    // ✅ Azure Pronunciation Assessment word timings are ALWAYS 100ns ticks.
    // This avoids the "2902s / 0 wpm" bug caused by misclassifying values as ms.
    const ticksToSec = (v) =>
      v == null || !Number.isFinite(+v) ? null : +v / 1e7;

    if (w.Offset != null) start = ticksToSec(w.Offset);
    if (w.Duration != null) dur = ticksToSec(w.Duration);
    if (w.Offset != null && w.Duration != null)
      end = ticksToSec(+w.Offset + +w.Duration);

    // Fallbacks for other shapes
    if (w.Start != null) start = toSec(w.Start);
    if (w.End != null) end = toSec(w.End);

    if (dur != null && end != null && start == null) start = end - dur;
    if (dur != null && start != null && end == null) end = start + dur;
    if (dur == null && start != null && end != null)
      dur = Math.max(0, end - start);

    out.push({
      ...w,
      start,
      end,
      durationSec: dur,
    });
  }

  return out;
}

export function getSpeakingRate(data) {
  var words =
    (data && data.NBest && data.NBest[0] && data.NBest[0].Words) || [];
  var totalSec = toSec(data && data.Duration);
  if (!Number.isFinite(totalSec)) {
    var sum = computeTimings(words)
      .map(function (t) {
        return t.durationSec;
      })
      .filter(Number.isFinite)
      .reduce(function (a, b) {
        return a + b;
      }, 0);
    totalSec = Number.isFinite(sum) && sum > 0 ? sum : null;
  }
  var count = words.length;
  if (!Number.isFinite(totalSec) || totalSec <= 0 || !count)
    return { wps: null, spw: null, label: "" };
  var wps = count / totalSec;
  var spw = totalSec / count;
  var label = "ok";
  if (wps < 2.0) label = "slow";
  else if (wps > 4.0) label = "fast";
  return { wps: wps, spw: spw, label: label };
}
</file>

<file path="repomix.config.json">
{
  "output": {
    "filePath": "repomix-frontend.LATEST.xml",
    "style": "xml"
  }
}
</file>

<file path="src/data/index.js">
// src/data/index.js
// index.js (barrel) — re-export data pieces for easy imports

import { passages as basePassages } from "./passages.js";

// ✅ Base passages are always available
export const passages = { ...basePassages };

// ✅ Harvard is lazy-loaded ONLY when needed
let _harvardLoaded = false;
let _harvardLoadPromise = null;

export async function ensureHarvardPassages() {
  if (_harvardLoaded) return passages;

  if (!_harvardLoadPromise) {
    _harvardLoadPromise = import("./harvard.js")
      .then((mod) => {
        Object.assign(passages, mod.harvardPassages || {});
        _harvardLoaded = true;
        return passages;
      })
      .catch((err) => {
        _harvardLoadPromise = null; // allow retry
        throw err;
      });
  }

  return _harvardLoadPromise;
}

// everything else stays the same:
export { norm, normalizePhoneSequence } from "./phonemes/core.js";
export { getPhonemeAssetByIPA, phonemeAssets } from "./phonemes/assets.js";
export {
  articulatorPlacement,
  phonemeDetailsByIPA,
  ytLink,
} from "./phonemes/details.js";
</file>

<file path="src/progress.js">
// src/progress.js
import { ensureUID } from "../api/identity.js";
import { initDashboard } from "../features/dashboard/index.js";
import { bootRippleButtons } from "../ui/ui-ripple-filter.js";

import { initMyWordsGlobal } from "../features/my-words/index.js";

const uid = ensureUID();
initMyWordsGlobal({ uid, inputEl: null });

initDashboard();

// Enable ripple effect for any element with [data-lux-ripple] on this page
bootRippleButtons();
</file>

<file path="src/wordcloud.js">
// src/wordcloud.js
import { ensureUID } from "../api/identity.js";
import { initWordCloudPage } from "../features/progress/wordcloud/index.js";
import { bootRippleButtons } from "../ui/ui-ripple-filter.js";

ensureUID();
initWordCloudPage();
bootRippleButtons();
</file>

<file path="ui/lazy-assets.js">
// src/ui/lazy-assets.js

export function ensureCSS(href) {
  const exists = [...document.styleSheets].some((s) => (s.href || "").includes(href));
  if (exists) return;

  const link = document.createElement("link");
  link.rel = "stylesheet";
  link.href = href;
  document.head.appendChild(link);
}

export async function ensureScript(src) {
  const exists = [...document.scripts].some((s) => (s.src || "").includes(src));
  if (exists) return;

  await new Promise((resolve, reject) => {
    const script = document.createElement("script");
    script.src = src;
    script.async = true;
    script.onload = resolve;
    script.onerror = reject;
    document.head.appendChild(script);
  });
}
</file>

<file path="ui/ui-ai-ai-dom.js">
// ui/ui-ai-ai-dom.js
// Handles DOM updates for the AI feedback panel.
// UPDATED: Implements persistent Sidebar and SCROLLABLE content area.

function getSectionAndBox() {
  const section = document.getElementById("aiFeedbackSection");
  const box = document.getElementById("aiFeedback");
  return { section, box };
}

function getCoachDrawerEl() {
  const { section } = getSectionAndBox();
  return section ? section.closest("details") : null;
}

export function openAICoachDrawer() {
  const d = getCoachDrawerEl();
  if (d) d.open = true;
}

export function collapseAICoachDrawer() {
  const d = getCoachDrawerEl();
  if (d) d.open = false;
}

// --- Layout Builder (The Sidebar + Scrollable Content) ---
function ensureShell(box, onPersonaChange) {
  // If the shell exists, just return the content area
  const existingContent = box.querySelector(".ai-content");
  if (existingContent) {
    // If we provided a callback, ensure the buttons are wired up to it
    if (onPersonaChange) wireSidebarButtons(box, onPersonaChange);
    return existingContent;
  }

  // Otherwise, build the Grid Layout
  box.innerHTML = "";
  box.classList.add("ai-grid-container");

  // 1. Sidebar (Persistent)
  const sidebar = document.createElement("div");
  sidebar.className = "ai-sidebar";

  const label = document.createElement("div");
  label.className = "ai-sidebar-label";
  label.textContent = "Coach Style";
  sidebar.appendChild(label);

  // The Buttons (Drill / Tutor / Expert)
  const modes = [
    { id: "tutor", icon: "🧑‍🏫", label: "Tutor" },
    { id: "drill", icon: "🫡", label: "Sgt." },
    { id: "linguist", icon: "🧐", label: "Expert" },
  ];

  modes.forEach((m) => {
    const btn = document.createElement("button");
    btn.className = `ai-voice-btn ${m.id === "tutor" ? "active" : ""}`; // Default to tutor
    btn.dataset.value = m.id;
    btn.innerHTML = `<span>${m.icon}</span> <span>${m.label}</span>`;
    sidebar.appendChild(btn);
  });

  // 2. Main Content Area (Dynamic & Scrollable)
  const content = document.createElement("div");
  content.className = "ai-content custom-scrollbar";

  // THE FIX: Constrain height and allow scrolling
  content.style.cssText = `
    max-height: 450px; 
    overflow-y: auto; 
    padding: 20px; 
    background: #fff; 
    display: flex; 
    flex-direction: column;
  `;

  box.appendChild(sidebar);
  box.appendChild(content);

  // Wire events
  if (onPersonaChange) wireSidebarButtons(box, onPersonaChange);

  return content;
}

function wireSidebarButtons(box, callback) {
  const sidebar = box.querySelector(".ai-sidebar");
  if (!sidebar) return;

  const buttons = sidebar.querySelectorAll(".ai-voice-btn");
  buttons.forEach((btn) => {
    // Remove old listeners to prevent duplicates (simple cloning trick)
    const newBtn = btn.cloneNode(true);
    btn.parentNode.replaceChild(newBtn, btn);

    newBtn.onclick = () => {
      // Visual toggle
      sidebar.querySelectorAll(".ai-voice-btn").forEach((b) => b.classList.remove("active"));
      newBtn.classList.add("active");
      // Trigger logic
      callback(newBtn.dataset.value);
    };
  });
}

// Helper to get current persona from the DOM state
export function getCurrentPersona() {
  const activeBtn = document.querySelector(".ai-voice-btn.active");
  return activeBtn ? activeBtn.dataset.value : "tutor";
}

// ---------------------------

export function hideAI() {
  const { section } = getSectionAndBox();
  if (section) section.style.display = ""; // keep summary visible
  collapseAICoachDrawer();
}

// UPDATED: Now uses Sidebar instead of Dropdown
export function renderEntryButtons({ onQuick, onDeep, onPersonaChange }) {
  const { section, box } = getSectionAndBox();
  if (section) section.style.display = "";
  if (!box) return;

  // Build/Get the Shell
  const contentArea = ensureShell(box, onPersonaChange);

  // Clear only the content area
  contentArea.innerHTML = "";
  box.style.display = "grid"; // Activate CSS Grid if hidden

  const wrap = document.createElement("div");
  wrap.style.cssText = "text-align:center; padding:10px 0;";

  const title = document.createElement("h3");
  title.textContent = "AI Analysis";
  title.style.cssText = "margin: 0 0 16px 0; color: #334155; font-size: 1.2rem;";
  wrap.appendChild(title);

  const btnRow = document.createElement("div");
  btnRow.style.cssText = "display:flex; justify-content:center; gap:12px; flex-wrap:wrap;";

  // Quick Button
  const btnQuick = document.createElement("button");
  btnQuick.innerHTML = "⚡ Quick Tips";
  btnQuick.className = "ai-action-btn secondary";
  btnQuick.onclick = () => {
    const p = getCurrentPersona();
    if (onQuick) onQuick(p);
  };

  // Deep Button
  const btnDeep = document.createElement("button");
  btnDeep.innerHTML = "🎓 Deep Dive";
  btnDeep.className = "ai-action-btn primary";
  btnDeep.onclick = () => {
    const p = getCurrentPersona();
    if (onDeep) onDeep(p);
  };

  btnRow.appendChild(btnQuick);
  btnRow.appendChild(btnDeep);
  wrap.appendChild(btnRow);
  contentArea.appendChild(wrap);
}

export function showLoading() {
  const { section, box } = getSectionAndBox();
  if (section) section.style.display = "";
  openAICoachDrawer();

  // Ensure shell exists (in case we jump straight here)
  const contentArea = ensureShell(box, null);

  contentArea.innerHTML = `
      <div style="text-align:center; padding: 40px 15px;">
         <div class="ai-spinner" style="font-size: 2.5rem; display:inline-block; margin-bottom:12px;">🤖</div>
         <div style="font-weight:600; color:#475569; margin-bottom:10px;">Analyzing...</div>
         <div class="ai-progress"></div>
      </div>
  `;
}

export function renderSections(sections, count) {
  const { section, box } = getSectionAndBox();
  if (section) section.style.display = "";

  const contentArea = ensureShell(box, null);

  const toShow = sections.slice(0, count);

  const html = toShow
    .map((sec, idx) => {
      const titleEn = sec.title || sec.emoji || "";
      const textEn = sec.en || sec.content || "";
      const titleL1 = sec.titleL1 || "";
      const textL1 = sec.l1;
      const hasL1 = !!textL1;

      const icon = sec.emoji ? `<span style="margin-right:6px;">${sec.emoji}</span>` : "";

      let headerHTML = `${icon} ${titleEn}`;
      if (titleL1 && titleL1 !== titleEn) {
        headerHTML += ` — ${titleL1}`;
      }

      let englishBlock = "";
      if (hasL1) {
        englishBlock = `
          <button class="toggle-en-btn" style="margin-top:10px;" onclick="
            const el = document.getElementById('en-block-${idx}');
            el.classList.toggle('hidden');
          ">Show/Hide English</button>
          <div id="en-block-${idx}" class="en-text hidden" style="margin-top:10px; padding:10px; background:#f1f5f9; border-radius:6px; font-size:0.9em;">
            <div style="font-weight:700; margin-bottom:4px; color:#334155; font-style:normal;">${titleEn}</div>
            ${mdToHtml(textEn)}
          </div>
        `;
      }

      return `
      <div style="margin-bottom:24px; padding-bottom:16px; border-bottom:1px solid #e2e8f0;">
        <div style="font-weight:800; color:#0f766e; margin-bottom:8px; font-size:1.15em;">
           ${headerHTML}
        </div>
        <div style="color:#334155; line-height:1.6;">
           ${mdToHtml(hasL1 ? textL1 : textEn)}
        </div>
        ${englishBlock}
      </div>
    `;
    })
    .join("");

  contentArea.innerHTML = html;

  // Create a Footer specifically for this content area
  const footer = document.createElement("div");
  footer.id = "ai-internal-footer";
  footer.style.marginTop = "20px";
  footer.style.textAlign = "center";
  contentArea.appendChild(footer);

  return { shown: toShow.length };
}

export function updateFooterButtons({
  onShowMore,
  onShowLess,
  canShowMore,
  canShowLess,
  isLoading,
  lessLabel = "Back ⬆",
}) {
  const footer = document.getElementById("ai-internal-footer");
  if (!footer) return;

  footer.innerHTML = "";
  footer.style.display = "flex";
  footer.style.justifyContent = "center";
  footer.style.gap = "10px";

  if (canShowMore) {
    const btn = document.createElement("button");
    btn.textContent = isLoading ? "Loading..." : "More ⬇";
    btn.className = "toggle-en-btn"; // Reuse existing style
    if (!isLoading) btn.onclick = onShowMore;
    footer.appendChild(btn);
  }

  if (canShowLess) {
    const btn = document.createElement("button");
    btn.textContent = lessLabel;
    btn.className = "toggle-en-btn";
    btn.onclick = onShowLess;
    footer.appendChild(btn);
  }
}

export function showAIFeedbackError(msg) {
  const { box } = getSectionAndBox();
  const contentArea = ensureShell(box, null);
  contentArea.innerHTML = `<div style="color:#c00; padding:20px;">Error: ${msg}</div>`;
}

export function clearAIFeedback() {
  const { box } = getSectionAndBox();
  const contentArea = ensureShell(box, null);
  contentArea.innerHTML = "";
}

// RESTORED FUNCTION
export function renderAIFeedbackMarkdown(md) {
  const { box } = getSectionAndBox();
  // Ensure we render inside the content area, not destroying the sidebar
  const contentArea = ensureShell(box, null);
  contentArea.innerHTML = mdToHtml(md);
}

// RESTORED HELPER
function mdToHtml(md = "") {
  if (!md || !md.trim()) return "";
  let html = md
    .replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>")
    .replace(/\*(.+?)\*/g, "<em>$1</em>");

  if (html.includes("- ")) {
    html = html
      .split("\n")
      .map((line) => {
        return line.trim().startsWith("- ")
          ? `<li>${line.trim().substring(2)}</li>`
          : line;
      })
      .join("<br>");
  }
  return html;
}
</file>

<file path="ui/ui-ai-ai-logic.js">
// ui/ui-ai-ai-logic.js
// Handles Logic for AI Feedback (Quick/Deep modes + Auto-Updates).

import {
  showLoading,
  hideAI,
  renderSections,
  renderEntryButtons,
  updateFooterButtons,
  showAIFeedbackError,
  clearAIFeedback,
  getCurrentPersona, // <--- NEW IMPORT
  renderAIFeedbackMarkdown,
  openAICoachDrawer,
  collapseAICoachDrawer,
} from "./ui-ai-ai-dom.js";

import { fetchAIFeedback, updateAttempt } from "/src/api/index.js";

// State
let chunkHistory = [];
let currentArgs = null;
let isFetching = false;

let lastContext = {
  azureResult: null,
  referenceText: "",
  firstLang: "universal",
};

// NEW: QuickTip paging state
let quickTipState = { index: 0, count: 3, cache: [] };

/**
 * Entry Point
 */
export function promptUserForAI(azureResult, referenceText, firstLang) {
  const nb = azureResult?.NBest?.[0];
  const saidText = (azureResult?.DisplayText || nb?.Display || "").trim();

  if (!nb || !saidText) {
    hideAI();
    return;
  }

  // Save context
  lastContext = { azureResult, referenceText, firstLang };
  resetState();

  // Practice Skills: auto-open after first usable result
  openAICoachDrawer();

  // Render Entry with Sidebar Callback
  renderEntryButtons({
    onQuick: (persona) => startQuickMode(azureResult, referenceText, firstLang, persona),
    onDeep: (persona) => startDeepMode(azureResult, referenceText, firstLang, persona),
    onPersonaChange: (newPersona) => onPersonaChanged(newPersona), // <--- Wire this up
  });
}

/**
 * Always-on AI Coach shell (for AI Conversations chat mode).
 * Renders the panel UI immediately, even before any attempt exists.
 *
 * getContext() should return:
 *   { azureResult, referenceText, firstLang }
 */
export function mountAICoachAlwaysOn(getContext) {
  const section = document.getElementById("aiFeedbackSection");
  if (!section) return;

  // Idempotent mount (don’t rebuild every render tick)
  if (section.dataset.convoMounted === "1") return;
  section.dataset.convoMounted = "1";

  // Keep collapsed on initial load (bubble bar only)
  collapseAICoachDrawer();

  renderEntryButtons({
    onQuick: (persona) => {
      const ctx = (typeof getContext === "function" ? getContext() : null) || {};
      const azureResult = ctx.azureResult;
      const referenceText = ctx.referenceText || "";
      const firstLang = ctx.firstLang || "universal";

      const nb = azureResult?.NBest?.[0];
      const saidText = (azureResult?.DisplayText || nb?.Display || "").trim();
      if (!nb || !saidText) {
        clearAIFeedback();
        renderAIFeedbackMarkdown(
          `### AI Coach is ready\nRecord **one** reply in the conversation, then click **Quick Tips** (or **Deep Dive**).`
        );
        return;
      }

      lastContext = { azureResult, referenceText, firstLang };
      resetState();
      startQuickMode(azureResult, referenceText, firstLang, persona);
    },
    onDeep: (persona) => {
      const ctx = (typeof getContext === "function" ? getContext() : null) || {};
      const azureResult = ctx.azureResult;
      const referenceText = ctx.referenceText || "";
      const firstLang = ctx.firstLang || "universal";

      const nb = azureResult?.NBest?.[0];
      const saidText = (azureResult?.DisplayText || nb?.Display || "").trim();
      if (!nb || !saidText) {
        clearAIFeedback();
        renderAIFeedbackMarkdown(
          `### AI Coach is ready\nRecord **one** reply in the conversation, then click **Deep Dive** for a full breakdown.`
        );
        return;
      }

      lastContext = { azureResult, referenceText, firstLang };
      resetState();
      startDeepMode(azureResult, referenceText, firstLang, persona);
    },
    onPersonaChange: (newPersona) => onPersonaChanged(newPersona),
  });
}

/**
 * Called when Sidebar "Coach Style" is clicked
 */
function onPersonaChanged(newPersona) {
  if (!lastContext.azureResult) return;
  console.log(`[AI Logic] Persona changed to ${newPersona}. Refreshing...`);

  if (currentArgs) {
    // If we are already viewing results, refresh immediately
    const { referenceText, firstLang, mode } = currentArgs;

    chunkHistory = [];
    clearAIFeedback(); // Clears content area, keeps sidebar

    if (mode === "simple") {
      startQuickMode(lastContext.azureResult, referenceText, firstLang, newPersona);
    } else {
      startDeepMode(lastContext.azureResult, referenceText, firstLang, newPersona);
    }
  } else {
    // Just sitting at menu, no fetch needed, but we keep the buttons active
    // The visual state 'active' class is handled by the DOM module
  }
}

/**
 * Called when Main L1 Dropdown changes
 */
export function onLanguageChanged(newLang) {
  if (!lastContext.azureResult) return;
  console.log(`[AI Logic] Language changed to ${newLang}. Refreshing...`);

  lastContext.firstLang = newLang;

  // Get currently selected sidebar persona to maintain consistency
  const currentPersona = getCurrentPersona();

  if (currentArgs) {
    const { mode } = currentArgs;
    chunkHistory = [];
    clearAIFeedback();

    if (mode === "simple") {
      startQuickMode(lastContext.azureResult, lastContext.referenceText, newLang, currentPersona);
    } else {
      startDeepMode(lastContext.azureResult, lastContext.referenceText, newLang, currentPersona);
    }
  } else {
    // Re-render to ensure any internal language state in closures is fresh
    renderEntryButtons({
      onQuick: (p) => startQuickMode(lastContext.azureResult, lastContext.referenceText, newLang, p),
      onDeep: (p) => startDeepMode(lastContext.azureResult, lastContext.referenceText, newLang, p),
      onPersonaChange: (p) => onPersonaChanged(p),
    });
  }
}

// ... (Rest of logic: resetState, persistFeedbackToDB, startQuickMode, startDeepMode, fetchNextChunk, handleShowLess, refreshFooter)
// [Use previous logic, just ensure startQuickMode/DeepMode use the passed persona]

function resetState() {
  chunkHistory = [];
  isFetching = false;
  currentArgs = null;
  quickTipState = { index: 0, count: 3, cache: [] };
}

function persistFeedbackToDB(sections) {
  if (window.lastAttemptId) {
    updateAttempt(window.lastAttemptId, { sections: sections });
  }
}

async function startQuickMode(azureResult, referenceText, firstLang, persona) {
  const lang = normalizeLang(firstLang);
  currentArgs = { azureResult, referenceText, firstLang: lang, persona, mode: "simple" };

  quickTipState = { index: 0, count: 3, cache: [] };
  await showQuickTipAt(0);
}

async function showQuickTipAt(i) {
  if (isFetching) return;
  isFetching = true;
  showLoading();

  try {
    // cached?
    if (quickTipState.cache[i]) {
      hideLoadingAndRenderQuick(i);
      return;
    }

    const res = await fetchAIFeedback({
      ...currentArgs,
      mode: "simple",
      tipIndex: i,
      tipCount: quickTipState.count,
    });

    const sections = res.sections || res.fallbackSections || [];
    const meta = res.meta || {};

    if (Number.isFinite(meta.tipCount)) quickTipState.count = meta.tipCount;

    quickTipState.cache[i] = sections;
    hideLoadingAndRenderQuick(i);

    // OPTIONAL: prefetch next tip to make Next feel instant
    const next = i + 1;
    if (next < quickTipState.count && !quickTipState.cache[next]) {
      fetchAIFeedback({ ...currentArgs, mode: "simple", tipIndex: next, tipCount: quickTipState.count })
        .then((r) => {
          quickTipState.cache[next] = r.sections || r.fallbackSections || [];
        })
        .catch(() => {});
    }

    // Persist only the first viewed tip (keeps DB clean + fast)
    if (i === 0) persistFeedbackToDB(sections);
  } catch (err) {
    console.error(err);
    showAIFeedbackError("Could not load Quick Tip.");
  } finally {
    isFetching = false;
  }
}

function hideLoadingAndRenderQuick(i) {
  const sections = quickTipState.cache[i] || [];
  quickTipState.index = i;

  renderSections(sections, sections.length);

  updateFooterButtons({
    canShowMore: i < quickTipState.count - 1,
    canShowLess: true,
    moreLabel: "Next Tip ➡",
    lessLabel: i === 0 ? "Back to Options ⬅" : "Previous Tip ⬅",
    onShowMore: () => showQuickTipAt(i + 1),
    onShowLess: () => (i === 0 ? handleShowLess() : showQuickTipAt(i - 1)),
  });
}

async function startDeepMode(azureResult, referenceText, firstLang, persona) {
  const lang = normalizeLang(firstLang);
  currentArgs = { azureResult, referenceText, firstLang: lang, persona, mode: "detailed" };
  chunkHistory = [];
  await fetchNextChunk();
}

async function fetchNextChunk() {
  if (isFetching) return;
  const nextChunkId = chunkHistory.length + 1;
  if (nextChunkId > 3) return;

  isFetching = true;
  if (nextChunkId === 1) showLoading();
  else refreshFooter();

  try {
    // DeepDive: includeHistory ~1/3 of the time deterministically on chunk 1
    const attemptIdNum = Number(window.lastAttemptId);
    const includeHistory =
      nextChunkId === 1 && Number.isFinite(attemptIdNum) ? attemptIdNum % 3 === 0 : undefined;

    const res = await fetchAIFeedback({
      ...currentArgs,
      chunk: nextChunkId,
      includeHistory,
    });

    const newSections = res.sections || res.fallbackSections || [];
    chunkHistory.push(newSections);

    const allSections = chunkHistory.flat();
    renderSections(allSections, allSections.length);

    persistFeedbackToDB(allSections);
  } catch (err) {
    console.error(err);
    showAIFeedbackError("Could not load next section.");
  } finally {
    isFetching = false;
    refreshFooter();
  }
}

function handleShowLess() {
  if (chunkHistory.length > 0) chunkHistory.pop();

  if (chunkHistory.length === 0) {
    clearAIFeedback();
    currentArgs = null;

    // Go back to entry buttons
    renderEntryButtons({
      onQuick: (p) =>
        startQuickMode(lastContext.azureResult, lastContext.referenceText, lastContext.firstLang, p),
      onDeep: (p) =>
        startDeepMode(lastContext.azureResult, lastContext.referenceText, lastContext.firstLang, p),
      onPersonaChange: (p) => onPersonaChanged(p),
    });
  } else {
    const allSections = chunkHistory.flat();
    renderSections(allSections, allSections.length);
    refreshFooter();
  }
}

function refreshFooter() {
  const currentCount = chunkHistory.length;
  updateFooterButtons({
    onShowMore: () => fetchNextChunk(),
    onShowLess: () => handleShowLess(),
    canShowMore: currentCount < 3,
    canShowLess: true,
    isLoading: isFetching,
  });
}

function normalizeLang(l) {
  return !l || !String(l).trim() ? "universal" : String(l).trim();
}

export const getAIFeedback = promptUserForAI;
</file>

<file path="vite.config.js">
import { defineConfig } from "vite";
import { resolve } from "path";

export default defineConfig({
  base: "./",

  build: {
    outDir: "dist",
    assetsDir: "assets",
    sourcemap: true,
    emptyOutDir: true,

    // ✅ IMPORTANT: build all your separate HTML pages
    rollupOptions: {
      input: {
        main: resolve(__dirname, "index.html"),
        convo: resolve(__dirname, "convo.html"),
        progress: resolve(__dirname, "progress.html"),
        wordcloud: resolve(__dirname, "wordcloud.html"),

        adminIndex: resolve(__dirname, "admin/index.html"),
        adminOverview: resolve(__dirname, "admin/overview.html"),
        adminUser: resolve(__dirname, "admin/user.html"),
      },
    },
  },

  server: {
    port: 3000,
    open: true,

    proxy: {
      "^/api/(?!.*\\.js(?:\\?.*)?$)": {
        target: "https://luxury-language-api.vercel.app",
        changeOrigin: true,
        secure: true,
        rewrite: (p) => p.replace(/^\/api/, ""),
      },
    },
  },
});
</file>

<file path=".repomixignore">
# Repomix: ignore heavy / generated stuff only

node_modules/
dist/
.vite/
coverage/
tmp/
temp/

# Big media
public/convo-vid/
public/convo-img/
**/*.mp4
**/*.webm
**/*.mov
**/*.wav

# Logs / caches
**/*.log
**/*.cache

# Big token hogs
public/vendor/
_ARCHIVE/
**/*.min.js
</file>

<file path="features/dashboard/index.js">
// features/dashboard/index.js
// Practice-page + Progress Hub dashboard bootstrap.
// - On /index.html: renders a collapsed "My Progress" drawer (loads on expand).
// - On /progress.html: renders the full dashboard immediately.

import * as UI from "./ui.js";
import { fetchHistory, ensureUID } from "/src/api/index.js";
import { computeRollups } from "../progress/rollups.js";
import { renderProgressDashboard } from "../progress/render.js";
import { mountAICoachAlwaysOn } from "../../ui/ui-ai-ai-logic.js";

const ROOT_ID = "dashboard-root";
const HUB_HREF = "./progress.html";

let _state = null;

function pickPassageKey(a) {
  return a?.passage_key || a?.passageKey || a?.passage || "";
}

function isConvoAttempt(a) {
  return String(pickPassageKey(a)).startsWith("convo:");
}

function fmtMini(totals = {}) {
  const avg = Math.round(Number(totals.avgScore || 0));
  const attempts = totals.attempts ?? 0;
  const last = totals.lastTS ? new Date(totals.lastTS) : null;
  const lastStr = last
    ? last.toLocaleDateString(undefined, { month: "short", day: "numeric" })
    : "—";
  return `Avg ${avg}% · Attempts ${attempts} · Last ${lastStr}`;
}

/**
 * Public refresh hook (used by auth + recorder).
 * - If the drawer is open, re-renders the full dashboard.
 * - If closed, just refreshes the mini summary.
 */
export async function refreshHistory() {
  const root = document.getElementById(ROOT_ID);
  if (!root) return;

  // Hub page: always re-render fully.
  const isHub =
    location.pathname.endsWith("/progress.html") ||
    location.pathname.endsWith("progress.html");
  if (isHub) {
    return await loadAndRenderHub(root);
  }

  // Practice page: drawer mode.
  if (!_state) return; // initDashboard not run yet

  try {
    const uid = ensureUID();
    const attempts = await fetchHistory(uid);
    const filtered = attempts.filter((a) => !isConvoAttempt(a));
    const model = computeRollups(filtered);

    if (_state.miniEl) _state.miniEl.textContent = fmtMini(model.totals);

    if (_state.detailsEl && _state.detailsEl.open && _state.mountEl) {
      renderProgressDashboard(_state.mountEl, filtered, model, {
        title: "My Progress",
        subtitle: "Practice Results (word + phoneme practice)",
        showActions: false,
        // IMPORTANT: drawer should NOT show category trend grid
        // showMetricTrends: false (default)
      });
    }
  } catch (err) {
    console.error("[Dashboard] refreshHistory failed:", err);
    if (_state.miniEl) _state.miniEl.textContent = "History unavailable";
  }
}

async function loadAndRenderHub(root) {
  UI.renderDashboard(ROOT_ID);

  try {
    const uid = ensureUID();
    const attempts = await fetchHistory(uid);
    const model = computeRollups(attempts);

    renderProgressDashboard(root, attempts, model, {
      title: "My Progress",
      subtitle: "All practice (Pronunciation + AI Conversations)",
      showActions: true,
      showCoach: true,
      // ✅ ONLY the All Data page gets the new category trend block
      showMetricTrends: true,
    });

    // Always-on AI Coach shell (shows immediately, even before any clicks)
    mountAICoachAlwaysOn(() => {
      if (!Array.isArray(attempts) || !attempts.length) return null;

      // pick latest attempt robustly
      let latest = null;
      let bestTS = -1;
      for (const a of attempts) {
        const ts =
          Date.parse(
            a?.ts || a?.created_at || a?.createdAt || a?.time || a?.localTime || ""
          ) || 0;
        if (ts > bestTS) {
          bestTS = ts;
          latest = a;
        }
      }
      if (!latest) return null;

      const azureResult =
        latest?.azureResult || latest?.azure_result || latest?.azure || latest?.result || null;
      const referenceText = latest?.text || "";
      const firstLang = latest?.l1 || "universal";

      return { azureResult, referenceText, firstLang };
    });

    // Hub page: open AI Coach after first user interaction (click/tap/key)
    const coachDrawer = document.getElementById("aiCoachDrawer");
    if (coachDrawer) {
      coachDrawer.open = false;
      const openOnce = () => {
        if (!coachDrawer.open) coachDrawer.open = true;
      };
      document.addEventListener("pointerdown", openOnce, { once: true, capture: true });
      document.addEventListener("keydown", openOnce, { once: true, capture: true });
    }
  } catch (err) {
    console.error("[Dashboard] Hub load failed:", err);
    if (String(err).includes("404"))
      renderProgressDashboard(root, [], computeRollups([]), { showActions: true });
    else UI.renderError("History unavailable.");
  }
}

export async function initDashboard() {
  const root = document.getElementById(ROOT_ID);
  if (!root) return;

  // expose refresh for auth + other flows
  window.refreshDashboard = refreshHistory;

  const isHub =
    location.pathname.endsWith("/progress.html") ||
    location.pathname.endsWith("progress.html");
  if (isHub) {
    // Full page: render immediately
    await loadAndRenderHub(root);
    return;
  }

  // Main Practice page: collapsed drawer, lazy-load on open
  root.innerHTML = `
    <details class="lux-progress-drawer">
      <summary class="lux-progress-drawer-summary">
        <div class="lux-progress-drawer-left">
          <div class="lux-progress-drawer-title">My Progress · Practice Results</div>
          <div class="lux-progress-drawer-mini" data-role="mini">Tap to load</div>
        </div>
        <a class="lux-progress-drawer-link" href="${HUB_HREF}">All Data</a>
      </summary>
      <div class="lux-progress-drawer-body">
        <div class="lux-progress-drawer-mount" data-role="mount">
          <div style="color:#64748b; padding: 14px 16px;">Open to load your history.</div>
        </div>
      </div>
    </details>
  `;

  const detailsEl = root.querySelector("details.lux-progress-drawer");
  const miniEl = root.querySelector('[data-role="mini"]');
  const mountEl = root.querySelector('[data-role="mount"]');

  _state = { detailsEl, miniEl, mountEl };

  let loadedOnce = false;

  async function loadIfNeeded() {
    if (loadedOnce) return;
    loadedOnce = true;

    if (mountEl)
      mountEl.innerHTML = `<div style="color:#64748b; padding: 14px 16px;">Loading…</div>`;

    try {
      const uid = ensureUID();
      const attempts = await fetchHistory(uid);
      const filtered = attempts.filter((a) => !isConvoAttempt(a));
      const model = computeRollups(filtered);

      if (miniEl) miniEl.textContent = fmtMini(model.totals);

      if (mountEl) {
        renderProgressDashboard(mountEl, filtered, model, {
          title: "My Progress",
          subtitle: "Practice Results (word + phoneme practice)",
          showActions: false,
          // IMPORTANT: drawer should NOT show category trend grid
          // showMetricTrends: false (default)
        });
      }
    } catch (err) {
      console.error("[Dashboard] Drawer load failed:", err);
      loadedOnce = false; // allow retry on next open
      if (miniEl) miniEl.textContent = "History unavailable";
      if (mountEl)
        mountEl.innerHTML = `<div style="color:#ef4444; padding: 14px 16px;">History unavailable.</div>`;
    }
  }

  if (detailsEl) {
    detailsEl.addEventListener("toggle", () => {
      if (detailsEl.open) loadIfNeeded();
    });
  }
}
</file>

<file path="features/features/tts/boot-tts.js">
// features/features/tts/boot-tts.js
// Peekaboo drawer initialization (TTS)
// ✅ Uses EXISTING tts-peekaboo.css animation (text slides + arrow flips)
// ✅ Loads ONLY the heavy player UI + inner TTS styling on first open

const GUARD_ID = "lux-tts-guard-style";

// Heavy inner styling (controls UI)
const CSS_CORE = "/features/features/tts.css";

function ensureCSS(href, contains = "") {
  const needle = contains || href;
  const has = [...document.styleSheets].some((ss) => (ss.href || "").includes(needle));
  if (has) return;

  const link = document.createElement("link");
  link.rel = "stylesheet";
  link.href = href;
  document.head.appendChild(link);
}

let _playerBooted = false;

function ensurePanel() {
  const host = document.getElementById("tts-controls");
  if (!host) return false;

  // ✅ Always start CLOSED (so closed-state CSS applies immediately)
  document.documentElement.classList.remove("lux-tts-open");

  // Panel container
  let panel = document.querySelector(".lux-tts-panel");
  if (!panel) {
    panel = document.createElement("aside");
    panel.className = "lux-tts-panel";
    document.body.appendChild(panel);
  }

  // Shell (blank white card behind the tab)
  let shell = panel.querySelector(".lux-tts-shell");
  if (!shell) {
    shell = document.createElement("div");
    shell.className = "lux-tts-shell";
    panel.appendChild(shell);
  }

  // Tab button (driven by tts-peekaboo.css)
  let tab = panel.querySelector(".lux-tts-tab");
  if (!tab) {
    tab = document.createElement("button");
    tab.className = "lux-tts-tab";
    tab.type = "button";
    tab.setAttribute("aria-expanded", "false");
    tab.setAttribute("aria-controls", "tts-controls");

    tab.innerHTML = `
      <span class="lux-tts-tab-inner">
        <span class="lux-tts-tab-label">Text-to-Speech</span>
        <span class="lux-tts-tab-icon">◀</span>
      </span>
    `;

    // Put tab BEFORE shell
    panel.insertBefore(tab, shell);

    tab.addEventListener("click", async () => {
      const willOpen = !document.documentElement.classList.contains("lux-tts-open");
      document.documentElement.classList.toggle("lux-tts-open", willOpen);
      tab.setAttribute("aria-expanded", String(willOpen));

      // ✅ Lazy boot ONLY on first open
      if (!willOpen || _playerBooted) return;
      _playerBooted = true;

      // Load inner control styling (NOT overlay positioning CSS)
      ensureCSS(CSS_CORE, "tts.css");

      try {
        const mod = await import("./player-ui.js");
        const mountHost = document.getElementById("tts-controls");
        if (mod?.mountTTSPlayer) {
          mod.mountTTSPlayer(mountHost);
          console.info("[Lux] TTS Player mounted (lazy).");
          document.documentElement.classList.add("lux-tts-booted");
        }
      } catch (e) {
        console.warn("[Lux] TTS lazy mount failed:", e);
        _playerBooted = false; // allow retry
      }
    });
  }

  // Ensure host lives inside the shell (this gives you the blank card when closed)
  if (!shell.contains(host)) shell.appendChild(host);

  // Remove guard that hides it
  document.getElementById(GUARD_ID)?.remove();
  host.dataset.luxHidden = "0";

  console.info("[Lux] TTS Peekaboo panel initialized (lazy).");
  return true;
}

function lateMount() {
  if (!ensurePanel()) setTimeout(lateMount, 120);
}

export function bootTTS() {
  lateMount();
}
</file>

<file path="features/interactions/metric-modal.js">
// features/interactions/metric-modal.js
// Wrapper re-export to keep stable import path.
// Implementation lives in ./metric-modal/*

export { initMetricScoreModals, setMetricModalData } from "./metric-modal/index.js";
</file>

<file path="features/interactions/metric-modal/derive.js">
// features/interactions/metric-modal/derive.js
// Pure compute helpers for metric explainer modals (NOT AI Coach).

import { getAzureScores, deriveFallbackScores } from "../../../core/scoring/index.js";
import { computeTimings, median } from "../../../prosody/core-calc.js";
import { classifyTempo } from "../../../prosody/annotate.js";

const PAUSE_MIN_SEC = 0.18; // "pause" threshold

function toNum(v) {
  const n = Number(v);
  return Number.isFinite(n) ? n : null;
}

function mean(nums) {
  const v = (nums || []).map(toNum).filter((x) => Number.isFinite(x));
  if (!v.length) return null;
  return v.reduce((a, b) => a + b, 0) / v.length;
}

function pickWords(data) {
  return (
    data?.NBest?.[0]?.Words ||
    data?.nBest?.[0]?.Words ||
    data?.PronunciationAssessment?.Words ||
    []
  );
}

function getDisplayText(data) {
  return (
    data?.DisplayText ||
    data?.displayText ||
    data?.NBest?.[0]?.Display ||
    data?.NBest?.[0]?.DisplayText ||
    data?.NBest?.[0]?.display ||
    data?.Text ||
    data?.text ||
    ""
  );
}

function pickPhonemes(data) {
  const words = pickWords(data);
  const out = [];
  for (const w of words || []) {
    const phs = w?.Phonemes || w?.phonemes || [];
    for (const ph of phs || []) {
      const sym = String(ph?.Phoneme || ph?.phoneme || "").trim();
      const pa = ph?.PronunciationAssessment || ph?.pronunciationAssessment || {};
      const score = toNum(pa?.AccuracyScore);
      if (!sym) continue;
      out.push({ ph: sym, score });
    }
  }
  return out;
}

export function getScorePack(data) {
  let s = getAzureScores(data);
  if (s.accuracy == null) {
    const fb = deriveFallbackScores(data);
    s = { ...s, ...fb };
  }

  // getAzureScores().overall === Azure "Pronunciation score" (PronScore)
  const pron = toNum(s.overall);
  const agg = mean([s.accuracy, s.fluency, s.completeness, s.prosody, pron]);

  return {
    accuracy: toNum(s.accuracy),
    fluency: toNum(s.fluency),
    completeness: toNum(s.completeness),
    prosody: toNum(s.prosody),
    pronunciation: pron,
    overallAgg: agg,
  };
}

export function deriveTimingStats(data) {
  const words = pickWords(data);
  if (!Array.isArray(words) || !words.length) return null;

  const timings = computeTimings(words);

  const starts = timings.map((t) => t?.start).filter(Number.isFinite);
  const ends = timings.map((t) => t?.end).filter(Number.isFinite);

  const minStart = starts.length ? Math.min(...starts) : null;
  const maxEnd = ends.length ? Math.max(...ends) : null;

  let spanSec = null;
  if (Number.isFinite(minStart) && Number.isFinite(maxEnd) && maxEnd > minStart) {
    spanSec = maxEnd - minStart;
  }

  let pauseCount = 0;
  let pauseTotal = 0;
  let longestPause = 0;

  for (let i = 1; i < timings.length; i++) {
    const prevEnd = timings[i - 1]?.end;
    const currStart = timings[i]?.start;
    if (!Number.isFinite(prevEnd) || !Number.isFinite(currStart)) continue;

    const gap = currStart - prevEnd;
    if (gap >= PAUSE_MIN_SEC) {
      pauseCount++;
      pauseTotal += gap;
      longestPause = Math.max(longestPause, gap);
    }
  }

  const wordsCount = words.length;

  const wps = Number.isFinite(spanSec) && spanSec > 0 ? wordsCount / spanSec : null;
  const wpm = Number.isFinite(wps) ? wps * 60 : null;

  const articulationSec =
    Number.isFinite(spanSec) && spanSec > 0 ? Math.max(0, spanSec - pauseTotal) : null;

  const arWps =
    Number.isFinite(articulationSec) && articulationSec > 0
      ? wordsCount / articulationSec
      : null;
  const arWpm = Number.isFinite(arWps) ? arWps * 60 : null;

  const durs = timings.map((t) => t?.durationSec).filter(Number.isFinite);
  const med = median(durs);

  const tempoMix = { fast: 0, ok: 0, slow: 0 };
  for (const d of durs) {
    const label = classifyTempo(d, med);
    tempoMix[label] = (tempoMix[label] || 0) + 1;
  }

  // ✅ Sanity + pause ratios (catch garbage spans / WPM)
  const pauseRatio = spanSec ? pauseTotal / spanSec : null; // pause share of total span
  const pauseToSpeechRatio = articulationSec ? pauseTotal / articulationSec : null; // pause share vs spoken time

  const isSane =
    Number.isFinite(spanSec) &&
    spanSec > 0.25 &&
    spanSec < 60 &&
    (!wpm || (wpm > 20 && wpm < 400)); // keep wide; just catch garbage

  return {
    wordsCount,
    spanSec,
    wpm,
    wps,
    articulationSec,
    arWpm,
    pauseCount,
    pauseTotal,
    longestPause,
    tempoMix,
    pauseRatio,
    pauseToSpeechRatio,
    isSane,
  };
}

export function deriveErrorStats(data) {
  const words = pickWords(data);
  if (!Array.isArray(words) || !words.length) return null;

  const worstWords = words
    .map((w) => {
      const pa = w?.PronunciationAssessment || w?.pronunciationAssessment || {};
      return {
        word: w?.Word || w?.word || "",
        acc: toNum(pa?.AccuracyScore),
        err: String(pa?.ErrorType || pa?.errorType || "").trim(),
      };
    })
    .filter((x) => x.word)
    .sort((a, b) => (a.acc ?? 999) - (b.acc ?? 999))
    .slice(0, 8);

  const errCounts = {};
  for (const w of words) {
    const pa = w?.PronunciationAssessment || w?.pronunciationAssessment || {};
    const t = String(pa?.ErrorType || pa?.errorType || "").trim();
    if (!t) continue;
    errCounts[t] = (errCounts[t] || 0) + 1;
  }

  const phMap = new Map();
  for (const w of words) {
    const phs = w?.Phonemes || w?.phonemes || [];
    for (const ph of phs) {
      const sym = String(ph?.Phoneme || ph?.phoneme || "").trim();
      const pa = ph?.PronunciationAssessment || ph?.pronunciationAssessment || {};
      const acc = toNum(pa?.AccuracyScore);
      if (!sym) continue;

      const prev = phMap.get(sym) || { sum: 0, n: 0 };
      if (Number.isFinite(acc)) {
        prev.sum += acc;
        prev.n += 1;
      }
      phMap.set(sym, prev);
    }
  }

  const worstPhonemes = [...phMap.entries()]
    .map(([sym, v]) => ({ phoneme: sym, avg: v.n ? v.sum / v.n : null, n: v.n }))
    .filter((x) => Number.isFinite(x.avg))
    .sort((a, b) => (a.avg ?? 999) - (b.avg ?? 999))
    .slice(0, 8);

  return { worstWords, worstPhonemes, errCounts };
}

export function prettyErrCounts(errCounts) {
  const entries = Object.entries(errCounts || {}).sort((a, b) => b[1] - a[1]);
  if (!entries.length) return "—";
  return entries.map(([k, v]) => `${k}: ${v}`).join(" • ");
}

/* ---------------------------------------------------------------------------
   Completeness-only helper: missing/extra words vs reference
--------------------------------------------------------------------------- */

function tokenizeWords(s) {
  return (s || "").toLowerCase().match(/[a-z0-9']+/g) || [];
}

// ✅ Completeness-only: missing/extra words vs reference
export function deriveCompletenessDiff(referenceText, data) {
  const ref = tokenizeWords(referenceText);
  if (!ref.length) return null;

  // Prefer word-level tokens from Azure if available
  const saidWords = pickWords(data)
    .map((w) => (w.word || w.Word || "").toLowerCase())
    .filter(Boolean);

  const said = saidWords.length ? saidWords : tokenizeWords(getDisplayText(data));

  const refCount = new Map();
  const saidCount = new Map();

  for (const w of ref) refCount.set(w, (refCount.get(w) || 0) + 1);
  for (const w of said) saidCount.set(w, (saidCount.get(w) || 0) + 1);

  const missing = [];
  const extra = [];

  for (const [w, n] of refCount.entries()) {
    const got = saidCount.get(w) || 0;
    if (got < n) missing.push(w);
  }

  for (const [w, n] of saidCount.entries()) {
    const exp = refCount.get(w) || 0;
    if (n > exp) extra.push(w);
  }

  // first divergence (simple sequential compare)
  let divergedAt = null;
  const L = Math.min(ref.length, said.length);
  for (let i = 0; i < L; i++) {
    if (ref[i] !== said[i]) {
      divergedAt = i + 1; // 1-based word index
      break;
    }
  }

  return {
    refCount: ref.length,
    saidCount: said.length,
    missing: missing.slice(0, 8),
    extra: extra.slice(0, 8),
    divergedAt,
  };
}

/* ---------------------------------------------------------------------------
   Accuracy/Pronunciation helper: vowel vs consonant weakness split
--------------------------------------------------------------------------- */

const VOWEL_SET = new Set([
  // Common vowel IPA + common symbolic vowel sets
  "a",
  "e",
  "i",
  "o",
  "u",
  "æ",
  "ɑ",
  "ɒ",
  "ɔ",
  "ʊ",
  "ʌ",
  "ə",
  "ɚ",
  "ɝ",
  "ɪ",
  "ɛ",
  "ɜ",
  // common Azure-ish / CMU-ish
  "aa",
  "ae",
  "ah",
  "ao",
  "aw",
  "ax",
  "ay",
  "eh",
  "er",
  "ey",
  "ih",
  "iy",
  "ow",
  "oy",
  "uh",
  "uw",
]);

function isVowelSymbol(ph) {
  const s = (ph || "").toLowerCase();
  if (VOWEL_SET.has(s)) return true;
  // fallback: any obvious vowel char
  return /[aeiouæɑɔəɪɛʊʌ]/.test(s);
}

export function derivePhonemeClassSplit(data, { weakThreshold = 80 } = {}) {
  const phs = pickPhonemes(data);
  if (!phs.length) return null;

  let vTotal = 0,
    cTotal = 0;
  let vWeak = 0,
    cWeak = 0;

  for (const p of phs) {
    const isV = isVowelSymbol(p.ph);
    const sc = Number(p.score);
    const weak = Number.isFinite(sc) && sc < weakThreshold;

    if (isV) {
      vTotal++;
      if (weak) vWeak++;
    } else {
      cTotal++;
      if (weak) cWeak++;
    }
  }

  const total = vTotal + cTotal;
  if (!total) return null;

  return {
    vTotal,
    cTotal,
    vWeak,
    cWeak,
    weakThreshold,
    weakShareVowels: vTotal ? vWeak / vTotal : 0,
    weakShareConsonants: cTotal ? cWeak / cTotal : 0,
  };
}
</file>

<file path="features/interactions/metric-modal/events.js">
// features/interactions/metric-modal/events.js
// DOM wiring + open/close + click/keyboard handlers.

import { buildModalHtml, esc } from "./render.js";

let installed = false;
let currentCtx = { azureResult: null, referenceText: "" };

function resolveMetricKeyFromEl(el) {
  if (!el) return null;

  const k = el.dataset?.scoreKey;
  if (k) return String(k).trim();

  if (el.classList?.contains("lux-scoreRing")) return "Overall";

  const lbl =
    el.querySelector?.(".lux-scoreTile-label")?.textContent ||
    el.querySelector?.(".lux-scoreLabel")?.textContent ||
    el.textContent ||
    "";

  const s = String(lbl).replace(/\(\?\)/g, "").trim().toLowerCase();
  if (!s) return null;

  if (s.includes("overall")) return "Overall";
  if (s.includes("pronunciation")) return "Pronunciation";
  if (s.includes("prosody")) return "Prosody";
  if (s.includes("accuracy")) return "Accuracy";
  if (s.includes("fluency")) return "Fluency";
  if (s.includes("completeness")) return "Completeness";

  return null;
}

function decorateTiles() {
  const tiles = document.querySelectorAll(".lux-scoreTile, .lux-scoreRing");
  tiles.forEach((t) => {
    if (!t.hasAttribute("tabindex")) t.setAttribute("tabindex", "0");
    if (!t.hasAttribute("role")) t.setAttribute("role", "button");
    t.setAttribute("aria-haspopup", "dialog");

    if (!t.dataset.scoreKey) {
      const inferred = resolveMetricKeyFromEl(t);
      if (inferred) t.dataset.scoreKey = inferred;
    }
  });
}

function openMetricModal(metricKey, ctx) {
  const existing = document.getElementById("lux-metric-modal");
  if (existing) existing.remove();

  const modal = document.createElement("div");
  modal.id = "lux-metric-modal";
  modal.className = "lux-metricModal";

  const card = document.createElement("div");
  card.className = "lux-metricCard";

  const closeBtn = document.createElement("button");
  closeBtn.className = "lux-metricClose";
  closeBtn.setAttribute("aria-label", "Close");
  closeBtn.innerHTML = "&times;";

  function close() {
    try {
      document.body.style.overflow = "";
    } catch {}
    try {
      modal.remove();
    } catch {}
    document.removeEventListener("keydown", onKey);
  }

  function onKey(e) {
    if (e.key === "Escape") close();
  }

  closeBtn.addEventListener("click", close);
  modal.addEventListener("click", (e) => {
    if (e.target === modal) close();
  });

  document.addEventListener("keydown", onKey);

  card.appendChild(closeBtn);

  const azureResult = ctx?.azureResult || null;

  if (!azureResult) {
    card.insertAdjacentHTML(
      "beforeend",
      `
      <div style="font-weight:900; font-size:1.05rem; color:#0f172a;">${esc(
        metricKey
      )}</div>
      <div style="margin-top:10px; color:#64748b; font-weight:800;">
        No attempt data yet. Record once to unlock details.
      </div>
    `
    );
  } else {
    card.insertAdjacentHTML("beforeend", buildModalHtml(metricKey, ctx));
  }

  modal.appendChild(card);
  document.body.appendChild(modal);

  try {
    document.body.style.overflow = "hidden";
  } catch {}
}

function shouldIgnoreClick(target) {
  if (!target) return false;
  if (target.closest?.("#lux-metric-modal")) return true;
  return false;
}

function onDocClick(e) {
  const t = e.target;
  if (shouldIgnoreClick(t)) return;

  const hit = t?.closest?.("[data-score-key], .lux-scoreTile, .lux-scoreRing");
  if (!hit) return;

  const metricKey = resolveMetricKeyFromEl(hit);
  if (!metricKey) return;

  openMetricModal(metricKey, currentCtx);
}

function onDocKeyDown(e) {
  if (e.key !== "Enter" && e.key !== " ") return;

  const t = e.target;
  const hit = t?.closest?.("[data-score-key], .lux-scoreTile, .lux-scoreRing");
  if (!hit) return;

  const metricKey = resolveMetricKeyFromEl(hit);
  if (!metricKey) return;

  e.preventDefault();
  openMetricModal(metricKey, currentCtx);
}

export function setMetricModalData(data) {
  // Accept either raw Azure payload or the richer ctx object
  if (data && typeof data === "object" && "azureResult" in data) {
    currentCtx = {
      azureResult: data.azureResult || null,
      referenceText: data.referenceText || "",
    };
  } else {
    currentCtx = { azureResult: data || null, referenceText: "" };
  }

  decorateTiles();
}

export function getMetricModalData() {
  return currentCtx;
}

export function initMetricScoreModals() {
  if (installed) return;
  installed = true;

  document.addEventListener("click", onDocClick, true);
  document.addEventListener("keydown", onDocKeyDown, true);

  decorateTiles();
}
</file>

<file path="features/my-words/stats.js">
// features/my-words/stats.js

import { normalizeText } from "./normalize.js";
import { getColorConfig } from "../progress/progress-utils.js";

function getAttemptText(a) {
  return (
    a?.reference_text ||
    a?.referenceText ||
    a?.reference ||
    a?.text ||
    a?.prompt ||
    a?.target_text ||
    a?.targetText ||
    ""
  );
}

function getAttemptTimeISO(a) {
  return (
    a?.ts ||
    a?.created_at ||
    a?.createdAt ||
    a?.timestamp ||
    a?.time ||
    a?.date ||
    null
  );
}

function toPct(v) {
  const n = Number(v);
  if (!Number.isFinite(n)) return null;
  // Handle both 0–1 and 0–100
  if (n >= 0 && n <= 1) return Math.round(n * 100);
  if (n >= 0 && n <= 100) return Math.round(n);
  return null;
}

function getOverallScore(a) {
  // ✅ Most likely in Lux attempt objects
  const v =
    a?.summary?.pron ??
    a?.summary?.pronunciation ??
    a?.summary?.pronScore ??
    a?.summary?.pron_score ??
    a?.scores?.overall ??
    a?.pronunciation_score ??
    a?.pronunciationScore ??
    a?.assessment?.pronunciationScore ??
    a?.result?.pronunciationScore ??
    a?.score ??
    null;

  return toPct(v);
}

function statusFromScore(lastScore, attemptCount) {
  if (!attemptCount) {
    return { label: "new", cls: "mw-new", color: "#94a3b8", bg: "#e2e8f0" };
  }
  if (lastScore == null) {
    return { label: "unknown", cls: "mw-unknown", color: "#94a3b8", bg: "#e2e8f0" };
  }

  const cfg = getColorConfig(lastScore);
  const cls = lastScore >= 80 ? "mw-good" : lastScore >= 60 ? "mw-warn" : "mw-bad";
  const label = lastScore >= 80 ? "solid" : lastScore >= 60 ? "getting-there" : "needs-work";

  return { label, cls, color: cfg.color, bg: cfg.bg };
}

function computeTrend(lastScore, prevScores) {
  if (lastScore == null) return "—";
  const vals = (prevScores || []).filter((x) => Number.isFinite(x));
  if (!vals.length) return "—";

  const avg = vals.reduce((a, b) => a + b, 0) / vals.length;
  const d = lastScore - avg;

  if (d >= 5) return "↗";
  if (d <= -5) return "↘";
  return "→";
}

/**
 * Returns NEW entries array with computed fields:
 *  mw_attempts, mw_lastScore, mw_lastAt, mw_status, mw_color, mw_bg, mw_cls, mw_trend
 */
export function applyMyWordsStats(entries, attempts) {
  const list = Array.isArray(entries) ? entries : [];
  const hist = Array.isArray(attempts) ? attempts : [];

  const buckets = new Map();

  list.forEach((e) => {
    const norm = normalizeText(e?.normalized_text || e?.text || "");
    if (!norm) return;
    buckets.set(norm, []);
  });

  hist.forEach((a) => {
    const text = getAttemptText(a);
    if (!text) return;
    const norm = normalizeText(text);
    const b = buckets.get(norm);
    if (b) b.push(a);
  });

  const updated = list.map((e) => {
    const norm = normalizeText(e?.normalized_text || e?.text || "");
    const b = buckets.get(norm) || [];

    // Sort newest first
    b.sort((x, y) => {
      const tx = new Date(getAttemptTimeISO(x) || 0).getTime();
      const ty = new Date(getAttemptTimeISO(y) || 0).getTime();
      return ty - tx;
    });

    const attemptCount = b.length;
    const last = b[0] || null;

    const lastScore = last ? getOverallScore(last) : null;
    const lastAt = last ? getAttemptTimeISO(last) : null;

    const prevScores = b.slice(1, 4).map(getOverallScore).filter((n) => n != null);
    const trend = computeTrend(lastScore, prevScores);

    const status = statusFromScore(lastScore, attemptCount);

    return {
      ...e,
      mw_attempts: attemptCount,
      mw_lastScore: lastScore,
      mw_lastAt: lastAt,
      mw_status: status.label,
      mw_color: status.color,
      mw_bg: status.bg,
      mw_cls: status.cls,
      mw_trend: trend,
    };
  });

  return updated;
}
</file>

<file path="features/progress/render/export.js">
// features/progress/render/export.js
// CSV / downloadBlob / exporting lives here.
// features/progress/render/export.js

import { titleFromPassageKey } from "./format.js";

export function downloadBlob(filename, text, mime) {
  const blob = new Blob([text], { type: mime || "text/plain" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(() => URL.revokeObjectURL(url), 5000);
}

export function attemptsToCSV(attempts = []) {
  const header = ["date", "source", "activity", "score", "text", "sessionId", "id"];
  const rows = attempts.map((a) => {
    const ts = a.ts || a.created_at || a.createdAt || "";
    const pk = a.passage_key || a.passageKey || "";
    const src = String(pk).startsWith("convo:") ? "AI Conversations" : "Pronunciation";
    const activity = titleFromPassageKey(pk);
    const score = Math.round(
      a.summary?.pron != null ? a.summary.pron : a.azureResult?.NBest?.[0]?.PronScore || 0
    );
    const text = String(a.text || "").replace(/\s+/g, " ").trim();
    const sid = a.session_id || a.sessionId || "";
    const id = a.id || "";
    const safe = (x) => `"${String(x ?? "").replaceAll('"', '""')}"`;
    return [safe(ts), safe(src), safe(activity), safe(score), safe(text), safe(sid), safe(id)].join(
      ","
    );
  });
  return [header.join(","), ...rows].join("\n");
}
</file>

<file path="features/progress/render/format.js">
// features/progress/render/format.js
// Formatting helpers live here (fmtScore, fmtDate, etc).
// features/progress/render/format.js
// Formatting + labels used by Progress renders.

import { passages } from "../../../src/data/passages.js";
import { SCENARIOS } from "../../convo/scenarios.js";

export function scoreClass(score) {
  if (score >= 80) return "lux-pill--blue";
  if (score >= 60) return "lux-pill--yellow";
  return "lux-pill--red";
}

export function fmtScore(score) {
  return `${Math.round(score)}%`;
}

export function fmtDate(ts) {
  if (!ts) return "—";
  const d = new Date(ts);
  return d.toLocaleString(undefined, {
    month: "short",
    day: "numeric",
    year: "numeric",
  });
}

export function titleFromPassageKey(pk = "") {
  const s = String(pk);
  if (s.startsWith("convo:")) {
    const id = s.slice("convo:".length);
    const hit = SCENARIOS.find((x) => x.id === id);
    return hit ? `AI Conversation · ${hit.title}` : `AI Conversation · ${id}`;
  }
  const hit = passages?.[s];
  return hit?.name || s || "Practice";
}

export function esc(s) {
  return String(s ?? "")
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#39;");
}
</file>

<file path="features/progress/render/index.js">
// features/progress/render/index.js
export { scoreClass, fmtScore, fmtDate, titleFromPassageKey, esc } from "./format.js";
export { sparklineSvg } from "./sparkline.js";
export { downloadBlob, attemptsToCSV } from "./export.js";
export { renderProgressDashboard } from "./dashboard.js";
export { renderMiniProgress } from "./mini.js";
</file>

<file path="features/progress/render/mini.js">
// features/progress/render/mini.js
// Mini progress widget render functions live here.
// features/progress/render/mini.js
import { fmtScore, fmtDate } from "./format.js";

export function renderMiniProgress(host, model, opts = {}) {
  const title = opts.title || "Progress";
  const totals = model?.totals || {};

  host.innerHTML = `
    <section class="lux-pcard" style="margin-bottom:12px;">
      <div class="lux-pcard-label">${title}</div>
      <div class="lux-pcard-value">${fmtScore(totals.avgScore ?? 0)}</div>
      <div class="lux-pcard-mini">
        Sessions: ${totals.sessions ?? 0} · Attempts: ${totals.attempts ?? 0} · Last: ${fmtDate(
    totals.lastTS
  )}
        · <a href="./progress.html" style="font-weight:800; color:#2563eb; text-decoration:none;">View full</a>
      </div>
    </section>
  `;
}
</file>

<file path="features/progress/render/sparkline.js">
// features/progress/render/sparkline.js
// Sparkline rendering + trend computation lives here.
// features/progress/render/sparkline.js

export function sparklineSvg(points = []) {
  const vals = points
    .map((p) => (p && p.avg != null ? p.avg : null))
    .filter((v) => v != null);

  if (!vals.length)
    return `<svg class="lux-spark" viewBox="0 0 120 34" preserveAspectRatio="none"></svg>`;

  const min = Math.min(...vals);
  const max = Math.max(...vals);
  const span = Math.max(1, max - min);

  const W = 120,
    H = 34;
  const step = W / Math.max(1, points.length - 1);

  const pts = points.map((p, i) => {
    const v = p.avg == null ? null : p.avg;
    const x = i * step;
    const y = v == null ? null : H - 4 - ((v - min) / span) * (H - 8);
    return { x, y };
  });

  // compress gaps by carrying last known y (keeps it readable)
  let lastY = H / 2;
  const path = pts
    .map((p) => {
      const y = p.y == null ? lastY : p.y;
      lastY = y;
      return `${p.x.toFixed(2)},${y.toFixed(2)}`;
    })
    .join(" ");

  return `
    <svg class="lux-spark" viewBox="0 0 ${W} ${H}" preserveAspectRatio="none">
      <polyline points="${path}" fill="none" stroke="rgba(15,23,42,0.55)" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round"></polyline>
    </svg>
  `;
}
</file>

<file path="features/progress/wordcloud/context.js">
// features/progress/wordcloud/context.js
import {
  readState,
  writeState,
  THEME_KEY,
} from "./state-store.js";

import { readUrlState, writeUrlState } from "./url-state.js";

/**
 * COMMIT 12A — Real shared context for the WordCloud feature
 * Owns:
 * - All state vars (mode/sort/range/query/mix/clusterMode/timelineWin/timelinePos/theme)
 * - persistence (state-store + url-state)
 * - theme application (DOM + localStorage)
 * - stable refs (attemptsAll, lastModel, lastItems, lastPool)
 * - get()/set() + onChange()
 */
export function createWordcloudContext() {
  const st = readState();
  const urlSt = readUrlState();

  // ✅ All primary state lives here
  let state = {
    mode: st.mode === "phonemes" ? "phonemes" : "words",

    sort: ["priority", "freq", "diff", "recent", "persist"].includes(st.sort)
      ? st.sort
      : "priority",

    range: ["all", "30d", "7d", "today", "timeline"].includes(st.range)
      ? st.range
      : "all",

    query: String(st.query || ""),

    mix: st.mix === "view" ? "view" : "smart",

    clusterMode: !!st.clusterMode,

    timelineWin: Number(st.timelineWin || 14),
    timelinePos: Number(st.timelinePos || 0),

    // Theme: stored in localStorage, but state owns it too
    theme: String(localStorage.getItem(THEME_KEY) || "light").toLowerCase(),
  };

  // ✅ normalize theme to only light/night
  if (state.theme !== "night") state.theme = "light";

  // ✅ URL overrides (same precedence as index.js previously had)
  if (urlSt.mode === "phonemes" || urlSt.mode === "words") state.mode = urlSt.mode;

  if (["priority", "freq", "diff", "recent", "persist"].includes(urlSt.sort))
    state.sort = urlSt.sort;

  if (["all", "30d", "7d", "today", "timeline"].includes(urlSt.range))
    state.range = urlSt.range;

  if (typeof urlSt.q === "string") state.query = urlSt.q;

  if (urlSt.cluster === "1" || urlSt.cluster === "0")
    state.clusterMode = urlSt.cluster === "1";

  if (urlSt.mix === "smart" || urlSt.mix === "view") state.mix = urlSt.mix;

  if (urlSt.win != null) state.timelineWin = Number(urlSt.win || 14);
  if (urlSt.pos != null) state.timelinePos = Number(urlSt.pos || 0);

  if (urlSt.theme === "night" || urlSt.theme === "light") state.theme = urlSt.theme;

  // ✅ clamp timeline values (same as before)
  state.timelineWin = Math.max(7, Math.min(60, Number(state.timelineWin || 14)));
  state.timelinePos = Math.max(0, Math.min(90, Number(state.timelinePos || 0)));

  // ✅ Stable refs (these are NOT re-assigned)
  const refs = {
    attemptsAll: [],   // stable array ref used by render.js
    lastModel: null,
    lastItems: [],
    lastPool: [],
  };

  let _onChange = null;

  function get() {
    return { ...state };
  }

  function normalizePatch(patch = {}) {
    const next = { ...patch };

    if (next.mode != null) {
      next.mode = next.mode === "phonemes" ? "phonemes" : "words";
    }

    if (next.sort != null) {
      next.sort = ["priority", "freq", "diff", "recent", "persist"].includes(next.sort)
        ? next.sort
        : state.sort;
    }

    if (next.range != null) {
      next.range = ["all", "30d", "7d", "today", "timeline"].includes(next.range)
        ? next.range
        : state.range;
    }

    if (next.query != null) {
      next.query = String(next.query || "");
    }

    if (next.mix != null) {
      next.mix = next.mix === "view" ? "view" : "smart";
    }

    if (next.clusterMode != null) {
      next.clusterMode = !!next.clusterMode;
    }

    if (next.timelineWin != null) {
      next.timelineWin = Math.max(7, Math.min(60, Number(next.timelineWin || 14)));
    }

    if (next.timelinePos != null) {
      next.timelinePos = Math.max(0, Math.min(90, Number(next.timelinePos || 0)));
    }

    if (next.theme != null) {
      const t = String(next.theme || "").toLowerCase();
      next.theme = t === "night" ? "night" : "light";
    }

    return next;
  }

  function persist() {
    writeState({
      mode: state.mode,
      sort: state.sort,
      range: state.range,
      query: state.query,
      clusterMode: state.clusterMode,
      mix: state.mix,
      timelineWin: state.timelineWin,
      timelinePos: state.timelinePos,
    });

    // theme is stored separately (but state owns it)
    try {
      localStorage.setItem(THEME_KEY, state.theme);
    } catch (_) {}
  }

  function syncUrl() {
    writeUrlState({
      mode: state.mode,
      sort: state.sort,
      range: state.range,
      q: state.query?.trim() || "",
      theme: state.theme,
      clusterMode: state.clusterMode,
      mix: state.mix,
      win: state.timelineWin,
      pos: state.timelinePos,
    });
  }

  function set(patch) {
    const clean = normalizePatch(patch);

    state = { ...state, ...clean };

    // re-clamp timeline (defensive)
    state.timelineWin = Math.max(7, Math.min(60, Number(state.timelineWin || 14)));
    state.timelinePos = Math.max(0, Math.min(90, Number(state.timelinePos || 0)));

    persist();
    syncUrl();

    if (_onChange) _onChange(get());
  }

  function onChange(fn) {
    _onChange = fn;
  }

  // ✅ Theme belongs to context (DOM application lives here too)
  function applyTheme(dom) {
    const isNight = state.theme === "night";
    if (dom?.shell) dom.shell.classList.toggle("lux-wc--night", isNight);

    if (dom?.btnTheme) dom.btnTheme.textContent = isNight ? "☀️" : "🌙";
    if (dom?.btnTheme) {
      dom.btnTheme.title = isNight
        ? "Switch to light theme"
        : "Switch to night theme";
    }

    try {
      localStorage.setItem(THEME_KEY, state.theme);
    } catch (_) {}
  }

  function toggleTheme(dom) {
    set({ theme: state.theme === "night" ? "light" : "night" });
    applyTheme(dom);
  }

  // ✅ Stable ref setters (no reassignment)
  function setLastModel(model) {
    refs.lastModel = model || null;
  }

  function setLastItems(items) {
    refs.lastItems = items || [];
  }

  function setLastPool(pool) {
    refs.lastPool = pool || [];
  }

  return {
    get,
    set,
    onChange,

    // state side-effects
    persist,
    syncUrl,
    applyTheme,
    toggleTheme,

    // stable refs
    refs,
    setLastModel,
    setLastItems,
    setLastPool,
  };
}
</file>

<file path="features/progress/wordcloud/event-handlers.js">
/**
 * features/progress/wordcloud/event-handlers.js
 *
 * Commit 17: "The Event Handler Factory"
 * Moves the massive bindWordcloudEvents() handler mapping out of index.js.
 *
 * This module is the "glue" between UI events and app logic.
 * Each handler should delegate to controllers (ctx/ui/drawer/timeline/strips).
 */

import { addManySaved, PIN_KEY } from "./state-store.js";
import { idFromItem } from "./compute.js";
import { buildCloudTop3Plan, buildCloudCoachQuickPlan } from "./plan.js";

export function createWordcloudEventHandlers({
  dom,
  ctx,
  ui,
  drawer,
  timeline,
  strips,
  saveNextActivityPlan,

  // optional config
  goBack = () => window.location.assign("./progress.html"),
  goToConvo = () => window.location.assign("./convo.html#chat"),

  // state getter for range validation + mode references
  getState,
}) {
  if (!dom) throw new Error("[wc/events] dom is required");
  if (!ctx) throw new Error("[wc/events] ctx is required");
  if (!ui) throw new Error("[wc/events] ui is required");
  if (!drawer) throw new Error("[wc/events] drawer is required");
  if (!timeline) throw new Error("[wc/events] timeline is required");
  if (!strips) throw new Error("[wc/events] strips is required");
  if (typeof saveNextActivityPlan !== "function")
    throw new Error("[wc/events] saveNextActivityPlan is required");
  if (typeof getState !== "function")
    throw new Error("[wc/events] getState() is required");

  return {
    goBack,

    toggleTheme: () => {
      ctx.toggleTheme(dom);
    },

    redraw: (forceFetch = false) => drawer.draw(!!forceFetch),

    setMode: (mode) => {
      ctx.set({ mode });
      ui.setModeStory();
      drawer.draw(false);
    },

    setSort: (sort) => {
      ctx.set({ sort });
      drawer.draw(false);
    },

    setRange: (range) => {
      const S = getState();

      const next = ["all", "30d", "7d", "today", "timeline"].includes(range)
        ? range
        : S.range;

      // ✅ stop replay when leaving timeline
      if (next !== "timeline") timeline.stop?.();

      // ✅ entering timeline should start at "most recent"
      if (next === "timeline" && S.range !== "timeline") {
        ctx.set({ range: next, timelinePos: 0 });
      } else {
        ctx.set({ range: next });
      }

      ui.setActiveButtons();
      drawer.draw(false);
    },

    setQuery: (q) => {
      ctx.set({ query: String(q || "") });
      drawer.draw(false);
    },

    clearQuery: () => {
      ctx.set({ query: "" });
      drawer.draw(false);
    },

    toggleCluster: () => {
      const S = getState();
      ctx.set({ clusterMode: !S.clusterMode });
      drawer.draw(false);
    },

    snapshot: () => {
      try {
        if (!dom.canvas) return;
        const S = getState();
        const a = document.createElement("a");
        a.download = `lux-cloud-${S.mode}-${Date.now()}.png`;
        a.href = dom.canvas.toDataURL("image/png");
        a.click();
      } catch (_) {}
    },

    setMix: (mix) => {
      ctx.set({ mix });
      drawer.draw(false);
    },

    generateTop3: () => {
      if (!ctx.refs.lastModel) return;

      const S = getState();
      const top = strips.getTop3();
      if (!top.length) return;

      const plan = buildCloudTop3Plan(ctx.refs.lastModel, S.mode, top);
      if (!plan) return;

      saveNextActivityPlan(plan);
      goToConvo();
    },

    // timeline scrub inputs delegate to controller
    setTimelineWin: (val) => timeline.setWin?.(val),
    setTimelinePos: (val) => timeline.setPos?.(val),

    timeline,
    toggleReplay: () => timeline.toggle?.(),

    coachQuick: () => {
      if (!ctx.refs.lastModel) return;

      const top = strips.getTop3();
      if (!top.length) return;

      const plan = buildCloudCoachQuickPlan(ctx.refs.lastModel);
      if (!plan) return;

      saveNextActivityPlan(plan);
      goToConvo();
    },

    coachPinTop: () => {
      const S = getState();
      const top = strips.getTop3();
      const ids = top.map((x) => idFromItem(S.mode, x)).filter(Boolean);
      if (!ids.length) return;

      addManySaved(PIN_KEY, S.mode, ids);
      strips.renderSavedStrip();
      drawer.draw(false);
    },

    // compatibility hook (sheet is owned by drawer now)
    openSheetForId: (_id) => {
      // Intentionally no-op.
      // Sheet open is handled via onSelect in the drawing orchestrator.
    },
  };
}
</file>

<file path="features/progress/wordcloud/events.js">
// features/progress/wordcloud/events.js
// ✅ All event listeners extracted from index.js

/**
 * Dumb wiring layer:
 * - queries DOM nodes inside root
 * - binds listeners
 * - calls api callbacks provided by index.js
 */
export function bindWordcloudEvents(root, api) {
  if (!root || !api) return;

  // Top actions
  const btnTheme = root.querySelector("#luxWcThemeToggle");
  const btnRefresh = root.querySelector("#luxWcRefresh");
  const btnBack = root.querySelector("#luxWcBack");

  // Mode toggles
  const pills = Array.from(root.querySelectorAll(".lux-wc-pill"));

  // Sort + range chips
  const sortBtns = Array.from(root.querySelectorAll("[data-sort]"));
  const rangeBtns = Array.from(root.querySelectorAll("[data-range]"));

  // Search
  const search = root.querySelector("#luxWcSearch");
  const clear = root.querySelector("#luxWcClear");

  // Power row
  const btnGenTop = root.querySelector("#luxWcGenTop");
  const btnCluster = root.querySelector("#luxWcCluster");
  const btnSnap = root.querySelector("#luxWcSnapshot");

  // Mix toggle
  const mixView = root.querySelector("#luxWcMixView");
  const mixSmart = root.querySelector("#luxWcMixSmart");

  // Timeline controls
  const winSlider = root.querySelector("#luxWcWin");
  const posSlider = root.querySelector("#luxWcPos");
  const btnReplay = root.querySelector("#luxWcReplay");

  // Coach lane
  const coachQuick = root.querySelector("#luxWcCoachQuick");
  const coachPinTop = root.querySelector("#luxWcCoachPinTop");

  // -----------------------------
  // Basic navigation / actions
  // -----------------------------
  btnBack?.addEventListener("click", () => api.goBack?.(), { passive: true });

  btnTheme?.addEventListener("click", () => api.toggleTheme?.(), {
    passive: true,
  });

  btnRefresh?.addEventListener("click", () => api.redraw?.(true), {
    passive: true,
  });

  // -----------------------------
  // Mode (words / phonemes)
  // -----------------------------
  pills.forEach((b) =>
    b.addEventListener(
      "click",
      () => {
        const mode = b?.dataset?.mode;
        if (!mode) return;
        api.setMode?.(mode);
      },
      { passive: true }
    )
  );

  // -----------------------------
  // Sort
  // -----------------------------
  sortBtns.forEach((b) =>
    b.addEventListener(
      "click",
      () => {
        const sort = b?.dataset?.sort;
        if (!sort) return;
        api.setSort?.(sort);
      },
      { passive: true }
    )
  );

  // -----------------------------
  // Range
  // -----------------------------
  rangeBtns.forEach((b) =>
    b.addEventListener(
      "click",
      () => {
        const range = b?.dataset?.range;
        if (!range) return;
        api.setRange?.(range);
      },
      { passive: true }
    )
  );

  // -----------------------------
  // Search
  // -----------------------------
  if (search) {
    search.addEventListener(
      "input",
      () => {
        api.setQuery?.(search.value || "");
      },
      { passive: true }
    );
  }

  clear?.addEventListener(
    "click",
    () => {
      if (search) search.value = "";
      api.clearQuery?.();
      try {
        search?.focus?.();
      } catch (_) {}
    },
    { passive: true }
  );

  // -----------------------------
  // Power row buttons
  // -----------------------------
  btnCluster?.addEventListener("click", () => api.toggleCluster?.(), {
    passive: true,
  });

  btnSnap?.addEventListener("click", () => api.snapshot?.(), { passive: true });

  btnGenTop?.addEventListener("click", () => api.generateTop3?.(), {
    passive: true,
  });

  // -----------------------------
  // Mix toggle
  // -----------------------------
  mixView?.addEventListener("click", () => api.setMix?.("view"), {
    passive: true,
  });

  mixSmart?.addEventListener("click", () => api.setMix?.("smart"), {
    passive: true,
  });

  // -----------------------------
  // Timeline sliders
  // -----------------------------
  winSlider?.addEventListener(
    "input",
    () => {
      api.setTimelineWin?.(Number(winSlider.value || 0));
    },
    { passive: true }
  );

  posSlider?.addEventListener(
    "input",
    () => {
      api.setTimelinePos?.(Number(posSlider.value || 0));
    },
    { passive: true }
  );

  // ✅ Replay toggle (UPDATED)
  // When someone clicks “Replay”: timeline.toggle();
  btnReplay?.addEventListener(
    "click",
    () => {
      // preferred new shape
      api.timeline?.toggle?.();

      // (optional compatibility fallback if index.js still provides toggleReplay)
      // safe to keep; remove later once timeline.toggle is everywhere
      if (!api.timeline?.toggle) api.toggleReplay?.();
    },
    { passive: true }
  );

  // -----------------------------
  // Coach lane
  // -----------------------------
  coachQuick?.addEventListener("click", () => api.coachQuick?.(), {
    passive: true,
  });

  coachPinTop?.addEventListener("click", () => api.coachPinTop?.(), {
    passive: true,
  });

  // -----------------------------
  // Delegated: open sheet from chips
  // (Top targets + pinned/favs use [data-open])
  // -----------------------------
  root.addEventListener(
    "click",
    (e) => {
      const btn = e.target?.closest?.("[data-open]");
      if (!btn) return;

      const id = String(btn.getAttribute("data-open") || "").trim();
      if (!id) return;

      api.openSheetForId?.(id);
    },
    { passive: true }
  );
}
</file>

<file path="features/progress/wordcloud/index.module.js">
export { createWordcloudContext } from "./context.js";
export { getWordcloudDom } from "./dom.js";
export { bindWordcloudEvents } from "./events.js";
export { renderWordcloudView } from "./render.js";
</file>

<file path="features/progress/wordcloud/strips.js">
// features/progress/wordcloud/strips.js

/**
 * COMMIT 12B — Extract strips + coach lane UI out of index.js
 * Owns:
 * - getTop3
 * - updateCoachHint
 * - renderTargetsStrip
 * - renderSavedStrip
 * - pinnedSetNow
 */

export function createWordcloudStrips({
  ctx,
  dom,
  getState, // () => current S snapshot
  mixLabel,
  smartTop3,
  idFromItem,
  lower,
  savedListForMode,
  PIN_KEY,
  FAV_KEY,
}) {
  function top3FromView(items) {
    const S = getState();
    const out = [];
    const seen = new Set();

    for (const x of items || []) {
      const id = lower(idFromItem(S.mode, x));
      if (!id || seen.has(id)) continue;
      seen.add(id);
      out.push(x);
      if (out.length >= 3) break;
    }

    return out;
  }

  function getTop3() {
    const S = getState();
    if (S.mix === "smart") return smartTop3(S.mode, ctx.refs.lastPool);
    return top3FromView(ctx.refs.lastItems);
  }

  function updateCoachHint() {
    if (!dom.coachHint) return;

    const S = getState();
    const top = getTop3();

    if (!top.length) {
      dom.coachHint.textContent = "";
      return;
    }

    const names = top.map((x) => idFromItem(S.mode, x)).slice(0, 3);
    dom.coachHint.textContent =
      S.mode === "phonemes"
        ? `Targets: /${names.join("/, /")}/`
        : `Targets: ${names.join(", ")}`;
  }

  function renderTargetsStrip() {
    if (!dom.targetsStrip) return;

    const S = getState();
    const top = getTop3();

    if (!top.length) {
      dom.targetsStrip.innerHTML = "";
      updateCoachHint();
      return;
    }

    dom.targetsStrip.innerHTML = `
      <div class="lux-wc-stripLabel">Top targets (${mixLabel(S.mix)})</div>
      <div class="lux-wc-stripRow">
        ${top
          .map((x) => {
            const id = idFromItem(S.mode, x);
            const avg = Math.round(Number(x.avg || 0));
            return `<button class="lux-wc-chipTarget" data-open="${id}">
              <span class="lux-wc-chipTxt">${
                S.mode === "phonemes" ? `/${id}/` : id
              }</span>
              <span class="lux-wc-chipPct">${avg}%</span>
            </button>`;
          })
          .join("")}
      </div>
    `;

    updateCoachHint();
  }

  function renderSavedStrip() {
    if (!dom.savedStrip) return;

    const S = getState();

    const pins = savedListForMode(PIN_KEY, S.mode).slice(0, 10);
    const favs = savedListForMode(FAV_KEY, S.mode).slice(0, 10);

    const mkRow = (title, arr, icon) => {
      if (!arr.length) return "";
      return `
        <div class="lux-wc-savedRow">
          <div class="lux-wc-stripLabel">${icon} ${title}</div>
          <div class="lux-wc-stripRow">
            ${arr
              .map(
                (id) => `
                  <button class="lux-wc-chipSaved" data-open="${id}">
                    ${S.mode === "phonemes" ? `/${id}/` : id}
                  </button>
                `
              )
              .join("")}
          </div>
        </div>
      `;
    };

    const html = mkRow("Pinned", pins, "📌") + mkRow("Favorites", favs, "⭐");
    dom.savedStrip.innerHTML = html || "";
  }

  function pinnedSetNow() {
    const S = getState();
    const pins = savedListForMode(PIN_KEY, S.mode);
    return new Set(pins.map(lower));
  }

  return {
    getTop3,
    updateCoachHint,
    renderTargetsStrip,
    renderSavedStrip,
    pinnedSetNow,
  };
}
</file>

<file path="features/progress/wordcloud/ui-manager.js">
/**
 * features/progress/wordcloud/ui-manager.js
 *
 * Commit 14: "The Sync Layer"
 * Separates "how the page looks" from "what the page does".
 *
 * Owns:
 * - overlay / busy UI
 * - active pills/toggles UI
 * - timeline row sync
 * - mode story text
 *
 * index.js should call these functions after state changes.
 */

export function createWordcloudUIManager({ dom, getState, fmtDaysAgo }) {
  if (!dom) throw new Error("[wc/ui] dom is required");
  if (typeof getState !== "function")
    throw new Error("[wc/ui] getState() is required");

  const _fmtDaysAgo =
    typeof fmtDaysAgo === "function"
      ? fmtDaysAgo
      : (pos) => (pos === 0 ? "Now" : `${pos}d ago`);

  // ✅ Busy overlay timing control (prevents invisible blink)
  let _busyOnAt = 0;
  let _hideTimer = null;
  const MIN_BUSY_MS = 250;

  function setBusy(on, title = "Loading…", subText = "") {
    if (!dom.overlay) return;

    if (on) {
      clearTimeout(_hideTimer);
      _busyOnAt = performance.now();

      dom.overlay.hidden = false;
      dom.overlay.style.display = "flex"; // ✅ override any CSS conflict
      dom.overlay.setAttribute("aria-busy", "true");

      if (dom.overlayTitle) dom.overlayTitle.textContent = title;
      if (dom.overlaySub) dom.overlaySub.textContent = subText || "";
      return;
    }

    // ✅ ensure overlay stays visible at least MIN_BUSY_MS (prevents invisible “blink”)
    const elapsed = performance.now() - _busyOnAt;
    const delay = Math.max(0, MIN_BUSY_MS - elapsed);

    clearTimeout(_hideTimer);
    _hideTimer = setTimeout(() => {
      dom.overlay.hidden = true;
      dom.overlay.style.display = "none";
      dom.overlay.setAttribute("aria-busy", "false");
    }, delay);
  }

  function applyTimelineUI() {
    const S = getState();
    const show = S.range === "timeline";

    if (dom.timelineRow) dom.timelineRow.style.display = show ? "flex" : "none";

    if (dom.winSlider) dom.winSlider.value = String(S.timelineWin);
    if (dom.posSlider) dom.posSlider.value = String(S.timelinePos);

    if (dom.winVal) dom.winVal.textContent = `${S.timelineWin}d`;
    if (dom.posVal) dom.posVal.textContent = _fmtDaysAgo(S.timelinePos);
  }

  function setModeStory() {
    const S = getState();
    if (!dom.sub) return;

    dom.sub.textContent =
      S.mode === "phonemes"
        ? "Sounds that show up often + cause trouble (size = frequency, color = Lux difficulty)"
        : "Words you use often + struggle with most (size = frequency, color = Lux difficulty)";
  }

  function setActiveButtons() {
    const S = getState();

    (dom.pills || []).forEach((b) =>
      b.classList.toggle("is-active", b.dataset.mode === S.mode)
    );

    (dom.sortBtns || []).forEach((b) =>
      b.classList.toggle("is-on", b.dataset.sort === S.sort)
    );

    (dom.rangeBtns || []).forEach((b) =>
      b.classList.toggle("is-on", b.dataset.range === S.range)
    );

    if (dom.btnCluster) dom.btnCluster.classList.toggle("is-on", S.clusterMode);

    if (dom.mixView) dom.mixView.classList.toggle("is-on", S.mix === "view");
    if (dom.mixSmart) dom.mixSmart.classList.toggle("is-on", S.mix === "smart");

    applyTimelineUI();
  }

  return {
    setBusy,
    applyTimelineUI,
    setModeStory,
    setActiveButtons,
  };
}
</file>

<file path="features/progress/wordcloud/view-logic.js">
/**
 * features/progress/wordcloud/view-logic.js
 *
 * Commit 13: "The Data Engine"
 * Owns how we compute and sort items for the current cloud view.
 *
 * index.js should NOT care how sorting works (priority/persistence/recent/etc).
 * index.js simply asks: "Given attemptsInRange + current state, give me items."
 */

import { computeRollups } from "../rollups.js";
import {
  lower,
  idFromItem,
  computeLastSeenMap,
  persistentScore,
} from "./compute.js";

const POOL_MAX = 140; // was 60 (lets topN expand without starving the pool)

/**
 * Compute items for the current view:
 * - builds rollup model from attemptsInRange
 * - selects trouble words/phonemes pool
 * - attaches lastSeenTS
 * - sorts by state.sort
 * - applies query reorder (hits first)
 * - returns top N
 */
export function computeItemsForView({ attemptsInRange, state, ctx, topN = 20 }) {
  const model = computeRollups(attemptsInRange);
  ctx?.setLastModel?.(model);

  const raw =
    state.mode === "phonemes"
      ? model?.trouble?.phonemesAll || []
      : model?.trouble?.wordsAll || [];

  // pool for smartMix + better candidate recall
  let pool = raw.slice(0, POOL_MAX);

  const ids = pool.map((x) => idFromItem(state.mode, x));

  const lastSeen = computeLastSeenMap(
    state.mode === "phonemes" ? "phonemes" : "words",
    attemptsInRange,
    ids
  );

  pool = pool.map((x) => {
    const id = lower(idFromItem(state.mode, x));
    return { ...x, lastSeenTS: lastSeen.get(id) || 0 };
  });

  // view sort rules shape cloud
  let items = pool.slice();

  if (state.sort === "freq")
    items.sort((a, b) => Number(b.count || 0) - Number(a.count || 0));
  else if (state.sort === "diff")
    items.sort((a, b) => Number(a.avg || 0) - Number(b.avg || 0));
  else if (state.sort === "recent")
    items.sort((a, b) => Number(b.lastSeenTS || 0) - Number(a.lastSeenTS || 0));
  else if (state.sort === "persist")
    items.sort((a, b) => persistentScore(b) - persistentScore(a));
  else items.sort((a, b) => Number(b.priority || 0) - Number(a.priority || 0));

  // search ordering (hits first, preserve the sort inside each group)
  const q = lower(state.query);
  if (q) {
    const match = (x) => lower(idFromItem(state.mode, x)).includes(q);
    const hits = items.filter(match);
    const rest = items.filter((x) => !match(x));
    items = [...hits, ...rest];
  }

  ctx?.setLastPool?.(pool);
  return items.slice(0, topN);
}
</file>

<file path="features/recorder/ui.js">
// features/recorder/ui.js
// Responsible for all DOM element lookups and UI state updates.

import { setText, logStatus } from "../../app-core/lux-utils.js";

// --- Element Getters ---
export const ui = {
  get textarea() { return document.querySelector("#referenceText"); },
  get recordBtn() { return document.querySelector("#record"); },
  get stopBtn() { return document.querySelector("#stop"); },
  get status() { return document.querySelector("#status"); },
  get error() { return document.querySelector("#recordingError"); },
};

// --- UI Actions ---

export function setStatus(msg) {
  if (ui.status) setText(ui.status, msg);
  logStatus(msg);
}

// Live mic level meter bars inside the Record button.
// levels = array of 0..1 values (length = number of bars).
export function setRecordVizLevels(levels = []) {
  const btn = ui.recordBtn;
  if (!btn) return;

  const bars = btn.querySelectorAll(".lux-recBar");
  if (!bars || !bars.length) return;

  for (let i = 0; i < bars.length; i++) {
    // baseline so it's never totally “dead”
    const vRaw = (levels && typeof levels[i] === "number") ? levels[i] : 0.12;
    const v = Math.max(0.08, Math.min(1, vRaw));
    bars[i].style.setProperty("--y", v.toFixed(3));
  }
}

export function resetRecordViz() {
  setRecordVizLevels([]);
}

export function setVisualState(state) {
  const { recordBtn, stopBtn } = ui;
  if (!recordBtn || !stopBtn) return;

  if (state === "recording") {
    recordBtn.disabled = true;
    recordBtn.classList.add("record-intro", "record-glow");
    stopBtn.disabled = false;
    stopBtn.classList.add("is-armed");
  } else if (state === "processing") {
    recordBtn.disabled = false;
    recordBtn.classList.remove("record-intro", "record-glow");
    stopBtn.disabled = true;
    stopBtn.classList.add("processing");
    resetRecordViz();
  } else {
    recordBtn.disabled = false;
    recordBtn.classList.remove("record-intro", "record-glow");
    stopBtn.disabled = true;
    stopBtn.classList.remove("is-armed", "processing");
    resetRecordViz();
  }
}

export function wireButtons({ onRecord, onStop }) {
  const { recordBtn, stopBtn } = ui;
  if (!recordBtn || !stopBtn) {
    console.warn("[LUX] Recorder buttons missing from DOM");
    return false;
  }

  recordBtn.addEventListener("click", (e) => {
    e.preventDefault();
    onRecord();
  });

  stopBtn.addEventListener("click", (e) => {
    e.preventDefault();
    onStop();
  });
  
  return true;
}
// ✅ Back-compat: some code calls DOM.ensureRefs()
export function ensureRefs() {
  // Touch getters so refs resolve (no-op but safe)
  void ui.textarea;
  void ui.recordBtn;
  void ui.stopBtn;
  void ui.status;
  void ui.error;
  return ui;
}
</file>

<file path="features/results/header-modern.js">
/* ============================================================================
   MODERN HEADER BUILDER
   ---------------------------------------------------------------------------
   - Fixed White Space Issue (Bottom of results).
   - Unified Phoneme Tooltips (Using shared Global logic).
   - Sticky Header + Contained Scroll.
============================================================================ */

import {
  scoreClass,
  fmtPct,
  getAzureScores,
  deriveFallbackScores,
} from "../../core/scoring/index.js";

const TOOLTIPS = {
  Accuracy: "How close your pronunciation is to a native speaker.",
  Fluency: "How smooth and natural your speech was.",
  Completeness: "Did you say all the words in the reference?",
  Pronunciation: "Overall pronunciation quality.",
  Prosody: "Stress, intonation, rhythm, and pacing.",
  Phoneme: "The smallest possible sound in a language.",
  Overall: "Aggregate score across all categories combined.",
};

export function renderResultsHeaderModern(data) {
  // 1. SCORING LOGIC
  let scores = getAzureScores(data);
  if (scores.accuracy == null) {
    const fb = deriveFallbackScores(data);
    scores = { ...scores, ...fb };
  }
  const { accuracy, fluency, completeness, overall, prosody, nbest } = scores;

  // 2. SPEAKING RATE
  let rateStr = "";
  if (typeof globalThis.getSpeakingRate === "function") {
      const rate = globalThis.getSpeakingRate(data);
      if (rate && Number.isFinite(rate.wps)) {
          rateStr = ` • ~${rate.wps.toFixed(1)} w/s`;
      }
  }

  // 3) PYRAMID SCORE UI (Overall circle + 5 tiles)

  const fmtRoundPct = (v) =>
    v == null || !Number.isFinite(+v) ? "—" : `${Math.round(+v)}%`;

  const meanAvail = (...vals) => {
    const v = vals.map((x) => +x).filter((x) => Number.isFinite(x));
    if (!v.length) return null;
    return v.reduce((a, b) => a + b, 0) / v.length;
  };

  // Treat "overall" from Azure as Pronunciation (tile)
  const pronunciation = overall;

  // Overall aggregate (your new blue circle)
  const overallAgg = meanAvail(accuracy, fluency, completeness, prosody, pronunciation);

  const getRingColor = (v) => {
    const n = +v;
    if (!Number.isFinite(n)) return "#cbd5e1";
    if (n >= 80) return "#2563eb";
    if (n >= 60) return "#d97706";
    return "#dc2626";
  };

  const overallRingColor = getRingColor(overallAgg);

  const renderMetricTile = (label, val, key, meta = "") => {
    const labelHtml =
      key === "Prosody"
        ? `<span id="prosodyLegendToggle"
                tabindex="0"
                role="button"
                title="Show/hide prosody bars key">${label}</span>`
        : label;

    return `
      <div class="lux-scoreTile" data-score-key="${key}">
        <div class="lux-scoreTile-label">
          ${labelHtml}
          <span class="tooltip result-tip tip-${key}">(?) 
            <span class="tooltiptext">${TOOLTIPS[key] || ""}</span>
          </span>
        </div>
        <div class="lux-scoreTile-value">${fmtRoundPct(val)}</div>
        ${meta ? `<div class="lux-scoreTile-meta">${meta}</div>` : ``}
      </div>
    `;
  };

  const saidText = data?.DisplayText || nbest?.Display || "(No speech detected)";

  const headerScoreClass = overallAgg != null ? scoreClass(overallAgg) : "";
  const scoreHeaderAttrs = [
    'id="scoreHeader"',
    `class="toggle-col ${headerScoreClass}"`,
    `data-overall-score="${overallAgg || 0}"`
  ].join(" ");

  // 4. PROSODY LEGEND
  const legendHtml = `
    <div id="prosodyLegend" class="prosody-legend prosody-legend--side hidden" role="note" aria-live="polite">
      <div class="legend-row">
        <div class="sample">
          <div class="prosody-ribbon">
            <span class="pr-seg pr-gap ok" style="width:12px"></span>
            <span class="pr-seg pr-tempo ok" style="width:28px"></span>
          </div>
          <span class="label">Normal</span>
        </div>

        <div class="sample">
          <div class="prosody-ribbon">
            <span class="pr-seg pr-gap missing" style="width:20px"></span>
            <span class="pr-seg pr-tempo ok" style="width:28px"></span>
          </div>
          <span class="label">Pause</span>
        </div>

        <div class="sample">
          <div class="prosody-ribbon">
            <span class="pr-seg pr-gap unexpected" style="width:34px"></span>
            <span class="pr-seg pr-tempo ok" style="width:28px"></span>
          </div>
          <span class="label">Long pause</span>
        </div>

        <div class="sample">
          <div class="prosody-ribbon">
            <span class="pr-seg pr-gap ok" style="width:12px"></span>
            <span class="pr-seg pr-tempo fast" style="width:16px"></span>
          </div>
          <span class="label">Fast word</span>
        </div>

        <div class="sample">
          <div class="prosody-ribbon">
            <span class="pr-seg pr-gap ok" style="width:12px"></span>
            <span class="pr-seg pr-tempo slow" style="width:60px"></span>
          </div>
          <span class="label">Slow word</span>
        </div>
      </div>
      <div class="note">Bars show pause (left) and tempo (right).</div>
    </div>
  `;

  // 5. FINAL ASSEMBLY
  // FIX: Styles specifically tuned to kill white space and scrolling issues.
  // display: block; height: auto; flex: none; -> Forces container to shrink to content.
  return `
    <div id="resultHeader" style="margin-bottom: 20px;">
      <div style="margin-bottom: 12px;">
        <b style="font-size: 1.1em;">Your Results:</b>

        <div class="lux-scoreSummary lux-scoreSummary--pyramid">
          <!-- Top: Overall aggregate -->
          <div class="lux-scoreMain">
            <div class="lux-scoreMainLabel">
              Overall
              <span class="tooltip result-tip tip-Overall">(?) 
                <span class="tooltiptext">${TOOLTIPS["Overall"] || ""}</span>
              </span>
            </div>

            <div class="lux-scoreRing" style="--lux-score-ring:${overallRingColor};">
              ${fmtRoundPct(overallAgg)}
            </div>
          </div>

          <!-- Pyramid tiles -->
          <div class="lux-scorePyramid">
            <div class="lux-scoreRow lux-scoreRow-mid">
              ${renderMetricTile("Prosody", prosody, "Prosody", rateStr ? rateStr.replace(/^ • /, "") : "")}
              ${renderMetricTile("Pronunciation", pronunciation, "Pronunciation")}
            </div>

            <div class="lux-scoreRow lux-scoreRow-bottom">
              ${renderMetricTile("Accuracy", accuracy, "Accuracy")}
              ${renderMetricTile("Fluency", fluency, "Fluency")}
              ${renderMetricTile("Completeness", completeness, "Completeness")}
            </div>
          </div>
        </div>
      </div>
  
      <div style="margin-bottom: 16px; color:#334155;">
        <b>What you said:</b>
        <span style="font-style:italic;">"${saidText}"</span>
      </div>
    </div>

    <details class="lux-results-accordion" id="luxWpAccordion" open>
      <summary class="lux-results-accordion-handle" title="Show/hide Word & Phoneme chart">
        <span class="lux-acc-label lux-acc-label-open">Hide Word &amp; Phoneme chart</span>
        <span class="lux-acc-label lux-acc-label-closed">Show Word &amp; Phoneme chart</span>
        <span class="lux-acc-chev">▾</span>
      </summary>

      <div class="results-flex">
        ${legendHtml}

        <div class="table-scroll-container custom-scrollbar">
          <table class="score-table collapsed-score collapsed-error">
            <thead style="position: sticky; top: 0; z-index: 20; box-shadow: 0 4px 6px -1px rgba(0,0,0,0.05);">
              <tr>
                <th id="wordHeader">
                  <button class="lux-col-toggle" type="button" data-col="word" aria-label="Collapse/expand Word column" title="Collapse/expand Word column">▸</button>
                  <span class="word-chip clickable">Word</span>
                </th>

                <th id="syllableHeader">
                  <span class="word-chip syllable-chip">Syllable</span>
                </th>

                <th ${scoreHeaderAttrs}>Score ▸</th>
                <th id="errorHeader" class="toggle-col">Error ▸</th>
                <th id="phonemeHeader">
                  <button class="lux-col-toggle" type="button" data-col="phoneme" aria-label="Collapse/expand Phoneme column" title="Collapse/expand Phoneme column">▸</button>
                  <span class="word-chip phoneme-chip clickable" id="phonemeTitle">Phoneme</span>
                  <span class="tooltip result-tip tip-Phoneme" style="margin-left:6px;">(?)<span class="tooltiptext">${TOOLTIPS.Phoneme}</span></span>
                </th>
              </tr>
            </thead>
            <tbody id="resultBody"></tbody>
          </table>
        </div>
      </div>
    </details>
  `;
}
</file>

<file path="lux-progress.css">
/* lux-progress.css — user-first progress UI (clean → expandable) */

.lux-progress-shell{
  max-width: 1100px;
  margin: 28px auto 0;
  padding: 0 16px 28px;
}

.lux-progress-head{
  display:flex;
  align-items:flex-end;
  justify-content:space-between;
  gap:12px;
  flex-wrap:wrap;
  padding-bottom: 12px;
  border-bottom: 1px solid #e2e8f0;
}

.lux-progress-title{
  margin:0;
  font-size: 1.6rem;
  color:#334155;
  letter-spacing: 0.2px;
}

.lux-progress-sub{
  margin-top:6px;
  color:#64748b;
  font-size: 0.95rem;
}

.lux-progress-actions{
  display:flex;
  gap:10px;
  flex-wrap:wrap;
}

.lux-pbtn{
  display:inline-flex;
  align-items:center;
  justify-content:center;
  gap:8px;
  padding: 10px 12px;
  border-radius: 12px;
  border: 1px solid rgba(15, 23, 42, 0.12);
  background: rgba(255,255,255,0.92);
  color:#0f172a;
  font-weight:700;
  font-size: 0.95rem;
  text-decoration:none;
  cursor:pointer;
  user-select:none;
  box-shadow: 0 6px 18px rgba(15,23,42,0.08);
}

.lux-pbtn:hover{ transform: translateY(-1px); }
.lux-pbtn:active{ transform: translateY(0px); }

.lux-pbtn--ghost{
  background: rgba(255,255,255,0.55);
  font-weight: 650;
  color:#334155;
}

.lux-progress-cards{
  display:grid;
  grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
  gap: 12px;
  margin-top: 14px;
}

.lux-pcard{
  background: rgba(255,255,255,0.9);
  border: 1px solid rgba(15, 23, 42, 0.08);
  border-radius: 16px;
  padding: 14px;
  box-shadow: 0 10px 24px rgba(15,23,42,0.08);
  overflow:hidden;
}

.lux-pcard-label{
  color:#64748b;
  font-size: 0.85rem;
  letter-spacing: 0.2px;
}

.lux-pcard-value{
  margin-top:6px;
  color:#0f172a;
  font-size: 1.5rem;
  font-weight: 800;
}

.lux-pcard-mini{
  margin-top: 10px;
  color:#64748b;
  font-size: 0.9rem;
}

.lux-progress-sec{
  margin-top: 14px;
  background: rgba(255,255,255,0.72);
  border: 1px solid rgba(15, 23, 42, 0.08);
  border-radius: 16px;
  padding: 0;
  overflow:hidden;
  box-shadow: 0 10px 24px rgba(15,23,42,0.06);
}

.lux-progress-sec > summary{
  list-style:none;
  cursor:pointer;
  padding: 12px 14px;
  font-weight: 800;
  color:#334155;
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
  border-bottom: 1px solid rgba(15,23,42,0.06);
}

.lux-progress-sec > summary::-webkit-details-marker{ display:none; }

.lux-progress-sec .lux-sec-body{
  padding: 12px 14px 14px;
}

.lux-chiprow{
  display:flex;
  flex-wrap:wrap;
  gap:8px;
}

.lux-chip{
  display:inline-flex;
  align-items:center;
  gap:8px;
  padding: 8px 10px;
  border-radius: 999px;
  border: 1px solid rgba(15,23,42,0.10);
  background: rgba(255,255,255,0.75);
  color:#0f172a;
  font-weight: 800;
  font-size: 0.95rem;
}

.lux-pill{
  display:inline-flex;
  align-items:center;
  justify-content:center;
  padding: 3px 8px;
  border-radius: 999px;
  font-weight: 900;
  font-size: 0.85rem;
}

.lux-pill--blue   { background:#dbeafe; color:#2563eb; }
.lux-pill--yellow { background:#fef3c7; color:#d97706; }
.lux-pill--red    { background:#fee2e2; color:#dc2626; }

.lux-history{
  display:flex;
  flex-direction:column;
  gap:10px;
}

.lux-hrow{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:12px;
  padding: 10px 12px;
  border-radius: 14px;
  border: 1px solid rgba(15,23,42,0.08);
  background: rgba(255,255,255,0.65);
}

.lux-hleft{ display:flex; flex-direction:column; gap:2px; }
.lux-htitle{ font-weight: 850; color:#0f172a; }
.lux-hmeta{ font-size: 0.9rem; color:#64748b; }

.lux-spark{
  width: 100%;
  height: 34px;
  margin-top: 10px;
  opacity: 0.92;
}

/* =========================================================
   NEW: Metric trends grid + card meta
   ========================================================= */

.lux-metricTrendsGrid{
  display:grid;
  grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
  gap: 12px;
}

.lux-metricTrendCard .lux-spark{
  margin-top: 8px;
}

.lux-metricTrendTop{
  display:flex;
  align-items:baseline;
  justify-content:space-between;
  gap:10px;
}

.lux-metricTrendValue{
  font-weight: 900;
  font-size: 1.1rem;
  color:#0f172a;
}

.lux-metricTrendMeta{
  margin-top: 10px;
  display:flex;
  flex-wrap:wrap;
  gap: 10px;
  color:#64748b;
  font-size: 0.9rem;
}

.lux-metricTrendsNote{
  margin-top: 10px;
  color:#64748b;
  font-size: 0.9rem;
  font-weight: 700;
}

.lux-mini-progress{
  max-width: 1100px;
  margin: 18px auto 0;
  padding: 0 16px;
}

/* =========================================================
   My Progress Drawer (collapsed on main pages)
   ========================================================= */

.lux-progress-drawer{
  max-width: 1100px;
  margin: 18px auto 0;
  padding: 0 16px;
}

.lux-progress-drawer-summary{
  list-style: none;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 12px;
  padding: 12px 14px;
  border-radius: 16px;
  border: 1px solid rgba(15,23,42,0.10);
  background: rgba(255,255,255,0.78);
  box-shadow: 0 10px 24px rgba(15,23,42,0.05);
}

.lux-progress-drawer[open] > .lux-progress-drawer-summary{
  border-bottom-left-radius: 0;
  border-bottom-right-radius: 0;
  border-bottom-color: rgba(15,23,42,0.06);
}

.lux-progress-drawer-left{
  display: flex;
  flex-direction: column;
  gap: 2px;
  min-width: 0;
}

.lux-progress-drawer-title{
  font-weight: 900;
  color: #0f172a;
  letter-spacing: -0.01em;
  line-height: 1.1;
}

.lux-progress-drawer-mini{
  font-size: 0.9rem;
  color: #64748b;
  font-weight: 800;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.lux-progress-drawer-link{
  flex: 0 0 auto;
  font-weight: 900;
  color: #2563eb;
  text-decoration: none;
  padding: 6px 10px;
  border-radius: 999px;
  border: 1px solid rgba(37,99,235,0.25);
  background: rgba(37,99,235,0.06);
}

.lux-progress-drawer-body{
  border: 1px solid rgba(15,23,42,0.10);
  border-top: 0;
  border-bottom-left-radius: 16px;
  border-bottom-right-radius: 16px;
  overflow: hidden;
  background: rgba(255,255,255,0.65);
  box-shadow: 0 10px 24px rgba(15,23,42,0.05);
}

.lux-progress-drawer-mount{
  padding: 0;
}

/* reduce the big outer margins when the dashboard is inside the drawer */
.lux-progress-drawer-body .lux-progress-shell{
  margin: 0;
  padding: 16px 16px 18px;
}

/* =========================================================
   History drill-in (👉) detail cards
   ========================================================= */

.lux-hright{
  display: flex;
  align-items: center;
  gap: 10px;
}

.lux-hbtn{
  border: 1px solid rgba(15,23,42,0.14);
  background: rgba(255,255,255,0.85);
  border-radius: 999px;
  padding: 6px 10px;
  cursor: pointer;
  font-weight: 900;
  line-height: 1;
}

.lux-hdetail{
  margin: 10px 0 0;
  padding: 10px 12px;
  border-radius: 14px;
  border: 1px dashed rgba(15,23,42,0.18);
  background: rgba(255,255,255,0.70);
}

.lux-hdetail-card{
  display: flex;
  flex-direction: column;
  gap: 10px;
  padding: 10px 10px;
  border-radius: 12px;
  border: 1px solid rgba(15,23,42,0.10);
  background: rgba(255,255,255,0.75);
  margin-bottom: 10px;
}

.lux-hdetail-head{
  display: flex;
  align-items: flex-start;
  justify-content: space-between;
  gap: 10px;
}

.lux-hdetail-title{
  font-weight: 900;
  color: #0f172a;
  letter-spacing: -0.01em;
}

.lux-hdetail-pills{
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
  justify-content: flex-end;
}

.lux-mini-pill{
  font-size: 0.82rem;
  padding: 3px 8px;
  border-radius: 999px;
  border: 1px solid rgba(15,23,42,0.12);
  background: rgba(15,23,42,0.04);
  color: #334155;
  font-weight: 800;
}

.lux-hdetail-text{
  color: #475569;
  font-size: 0.95rem;
  line-height: 1.35;
  white-space: pre-wrap;
}

.lux-hdetail-ai{
  border-radius: 12px;
  border: 1px solid rgba(15,23,42,0.10);
  background: rgba(15,23,42,0.03);
  padding: 8px 10px;
}

.lux-hdetail-ai > summary{
  cursor: pointer;
  font-weight: 900;
  color: #334155;
}

.lux-ai-sec-title{
  font-weight: 900;
  color: #0f172a;
  margin-top: 10px;
}

.lux-ai-bullets{
  margin: 6px 0 0 18px;
  color: #475569;
  line-height: 1.35;
}

/* =========================================================
   AI Coach drawer (collapsed on load)
   ========================================================= */

.lux-ai-drawer > summary::-webkit-details-marker{ display:none; }
.lux-ai-drawer > summary::marker{ content:""; }

/* Coach panel already has its own framing — keep drawer body clean */
.lux-ai-drawer .lux-progress-drawer-body{
  border: 0;
  background: transparent;
  box-shadow: none;
}
.lux-ai-drawer #aiFeedbackSection{
  margin: 0;
}
</file>

<file path="lux-results.accordion.css">
/* lux-results.accordion.css */
/* Word/Phoneme accordion pill handle (end-of-file rules) */

#prettyResult details.lux-results-accordion{
  margin-top: 10px;
}

/* kill native marker */
#prettyResult details.lux-results-accordion > summary::-webkit-details-marker{ display:none; }
#prettyResult details.lux-results-accordion > summary::marker{ content:""; }

/* the pill */
#prettyResult details.lux-results-accordion > summary.lux-results-accordion-handle{
  display: flex !important;
  align-items: center !important;
  justify-content: center !important;
  gap: 10px !important;

  height: 34px !important;
  width: min(980px, 100%) !important;
  margin: 6px auto 0 !important;

  padding: 0 14px !important;
  border-radius: 999px !important;

  background: #e7f2fb !important;
  border: 1px solid rgba(0,120,215,0.28) !important;
  box-shadow: 0 6px 18px rgba(0,0,0,0.06) !important;

  cursor: pointer !important;
  user-select: none !important;
  list-style: none !important;
}

/* label styles */
#prettyResult .lux-acc-label{
  font-weight: 800 !important;
  color: #1e293b !important;
  font-size: 0.95rem !important;
  line-height: 1 !important;
  white-space: nowrap !important;
}

/* label swap: only one shows */
#prettyResult .lux-acc-label-open{ display:none !important; }
#prettyResult details.lux-results-accordion:not([open]) .lux-acc-label-closed{ display:inline !important; }
#prettyResult details.lux-results-accordion[open] .lux-acc-label-open{ display:inline !important; }
#prettyResult details.lux-results-accordion[open] .lux-acc-label-closed{ display:none !important; }

/* chevron */
#prettyResult .lux-acc-chev{
  opacity: 0.65 !important;
  transition: transform 160ms ease !important;
}
#prettyResult details.lux-results-accordion[open] .lux-acc-chev{
  transform: rotate(180deg) !important;
}
</file>

<file path="lux-results.ai.css">
/* lux-results.ai.css */
/* AI coaching sidebar layout (polished) */

/* ============================================================
   AI COACHING SIDEBAR LAYOUT (Polished)
   ============================================================ */
.ai-grid-container {
  display: grid;
  grid-template-columns: 80px 1fr;
  min-height: 220px;
  background: #fff;
  border-radius: 12px;
  border: 1px solid #c9e2ff;
  box-shadow: 0 2px 16px rgba(60, 90, 155, 0.06);
  margin-top: 25px;
  overflow: hidden;
  padding: 0 !important;
}

.ai-sidebar {
  background: #f1f5f9;
  border-right: 1px solid #cbd5e1;
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 12px 6px;
  gap: 8px;
}

.ai-sidebar-label {
  font-size: 0.65rem;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  font-weight: 800;
  color: #64748b;
  margin-bottom: 4px;
  text-align: center;
  width: 100%;
}

.ai-voice-btn {
  appearance: none;
  border: 1px solid transparent;
  background: #fff;
  border-color: #cbd5e1;
  border-radius: 8px;
  width: 100%;
  padding: 10px 4px;
  cursor: pointer;

  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 5px;

  color: #64748b;
  transition: all 0.15s ease;
  box-shadow: 0 1px 2px rgba(0,0,0,0.04);
}

.ai-voice-btn span:first-child {
  font-size: 1.5rem;
  line-height: 1;
}
.ai-voice-btn span:last-child {
  font-size: 0.7rem;
  font-weight: 700;
}

.ai-voice-btn:hover {
  transform: translateY(-1px);
  border-color: #94a3b8;
  color: #334155;
  box-shadow: 0 4px 6px rgba(0,0,0,0.05);
}

.ai-voice-btn.active {
  background: #fff;
  border-color: #0078d7;
  color: #0078d7;
  box-shadow: 0 0 0 1px #0078d7 inset, 0 4px 8px rgba(0, 120, 215, 0.15);
}

.ai-content {
  padding: 20px;
  background: #fff;
  display: flex;
  flex-direction: column;
}

.ai-action-btn {
  padding: 10px 18px;
  border-radius: 8px;
  font-weight: 700;
  cursor: pointer;
  transition: all 0.2s;
  border: 1px solid transparent;
  font-size: 0.95rem;
}

.ai-action-btn.secondary {
  background: #fff;
  border-color: #cbd5e1;
  color: #334155;
  box-shadow: 0 2px 4px rgba(0,0,0,0.05);
}
.ai-action-btn.secondary:hover {
  border-color: #94a3b8;
  background: #f8fafc;
}
</file>

<file path="lux-results.prosody.css">
/* lux-results.prosody.css */
/* Prosody ribbons + legend + results layout cues */

/* ============================================================
   Prosody Ribbons & Legend
   ============================================================ */
.prosody-ribbon { display: inline-flex; align-items: center; gap: 4px; margin-right: 8px; }
.pr-seg { display: inline-block; height: 8px; border-radius: 3px; transition: transform 0.15s ease, filter 0.15s ease; }
.pr-seg:hover { transform: scaleY(1.35); filter: brightness(0.9); }

/* Color map: left bar = pause before word, right bar = word length */
.pr-gap.ok { background: #cbd5e1; }
.pr-gap.missing { background: #fbbf24; }
.pr-gap.unexpected { background: #fb7185; }

.pr-tempo.ok { background: #60a5fa; }
.pr-tempo.fast { background: #22c55e; }
.pr-tempo.slow { background: #f59e0b; }

#prettyResult .results-flex { display: flex; align-items: flex-start; gap: 16px; width: 100%; }

/* table is wrapped now, so flex the wrapper */
#prettyResult .results-flex > .table-scroll-container { flex: 1 1 auto; min-width: 420px; }
#prettyResult .results-flex > .table-scroll-container > table.score-table { width: 100%; }

/* ============================================================
   Word/Phoneme table: contained scroll (like AI feedback)
   ============================================================ */
#prettyResult .table-scroll-container{
  max-height: min(520px, 55vh);   /* adjust if you want taller/shorter */
  overflow-y: auto;
  overflow-x: auto;
  scrollbar-gutter: stable;
}

.prosody-legend {
  margin: 8px auto 12px; max-width: 950px; padding: 8px 10px; border-radius: 10px;
  background: #f7fbff; border: 1px solid #d9ebff; color: #234;
}
.prosody-legend .legend-row { display: flex; flex-wrap: wrap; gap: 14px 18px; align-items: center; margin-bottom: 6px; }
.prosody-legend .sample {
  display: inline-flex; align-items: center; gap: 8px; padding: 4px 6px;
  background: #fff; border-radius: 12px; border: 1px solid #e8eef7;
}
.prosody-legend .sample .prosody-ribbon { transform: scale(0.95); transform-origin: left center; }
.prosody-legend .label { font-weight: 600; color: #355; }
.prosody-legend .note { font-size: 0.95em; color: #556; }

#prettyResult .prosody-legend--side {
  margin: 0; max-width: 260px; width: 260px; flex: 0 0 260px; position: sticky; top: 8px;
}

@media (max-width: 900px) {
  #prettyResult .results-flex { flex-direction: column; }
  #prettyResult .prosody-legend--side { position: static; width: 100%; max-width: 100%; margin: 8px 0 12px; }
  #prettyResult .results-flex > .table-scroll-container { min-width: 0; }
}

/* ============================================================
   Cue Styles
   ============================================================ */
#prosodyLegend {
  overflow: hidden;
  width: 0 !important;
  min-width: 0 !important;
  flex: 0 0 0 !important;
  height: 0 !important;
  padding: 0 !important; margin: 0 !important; border: 0 !important; opacity: 0;
  transform: translateX(-10px);
  transition: width .28s ease, flex-basis .28s ease, opacity .28s ease, transform .28s ease, padding .28s ease, margin .28s ease;
}

.results-flex.legend-open #prosodyLegend {
  width: 280px !important;
  min-width: 280px !important;
  flex: 0 0 280px !important;
  height: auto !important;
  padding-right: 10px !important; margin-right: 0 !important; border-left: 0 !important;
  opacity: 1; transform: translateX(0);
}

.results-flex.legend-open { gap: 12px; }

#prosodyLegendToggle { position: relative; isolation: isolate; cursor: pointer; }
#prosodyLegendToggle.cue-legend::after {
  content: ""; position: absolute; left: 50%; top: 50%; width: 22px; height: 22px;
  margin: -11px 0 0 -11px; border-radius: 50%;
  border: 2px solid rgba(0, 120, 215, .55);
  animation: legendPing 1.6s ease-out infinite; pointer-events: none;
}
@keyframes legendPing {
  0% { transform: scale(.7); opacity: .9; }
  70%, 100% { transform: scale(1.9); opacity: 0; }
}

#legendPeek {
  position: absolute; top: 44px; width: 12px; height: 40px;
  border-radius: 8px 0 0 8px; background: linear-gradient(180deg, #9fd2ff, #0078d7);
  box-shadow: 0 3px 10px rgba(0, 0, 0, .22);
  opacity: 0; transform: translateX(10px);
  transition: opacity .24s ease, transform .24s ease;
  pointer-events: auto; cursor: pointer; z-index: 6;
}
#legendPeek::after {
  content: ""; position: absolute; inset: 0;
  background: linear-gradient(90deg, rgba(255, 255, 255, 0), rgba(255, 255, 255, .95), rgba(255, 255, 255, 0));
  background-size: 220% 100%; animation: legendLine 1.3s linear infinite; opacity: .5;
}
@keyframes legendLine {
  from { background-position: 200% 0; }
  to { background-position: 0% 0; }
}

.results-flex.show-peek #legendPeek { opacity: .95; transform: translateX(0); }
.results-flex.legend-open #legendPeek { display: none; }

.tip-ProsodyBars .tooltiptext { padding-bottom: 14px; }
.tip-ProsodyBars .tooltiptext::before {
  content: ""; position: absolute; left: 10px; right: 10px; bottom: 6px;
  height: 2px; background: #ffffff66; border-radius: 2px;
}
.tip-ProsodyBars .tooltiptext::after {
  content: ""; position: absolute; bottom: 2px; right: -18px; width: 0; height: 0;
  border-right: 10px solid #fff; border-top: 6px solid transparent; border-bottom: 6px solid transparent;
  opacity: .9; animation: legendArrow 1.7s linear infinite;
}
@keyframes legendArrow {
  from { right: -18px; }
  to { right: calc(100% + 18px); }
}

/* Tap flash: box-shadow only (NO scale transform) */
#resultBody .phoneme-chip.tap-flash { animation: chipTap .22s ease-out 1; }
@keyframes chipTap {
  0%   { box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2); }
  50%  { box-shadow: 0 0 0 6px rgba(64, 156, 255, .28); }
  100% { box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2); }
}
</file>

<file path="lux-widgets.metric-modal.css">
/* lux-widgets.metric-modal.css */
/* Metric explainer modal styles */

/* ============================================================
   Metric Modal
   ============================================================ */
.lux-metricModal{
  position: fixed;
  inset: 0;
  z-index: 10050;
  background: rgba(0,0,0,0.45);
  backdrop-filter: blur(2px);
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 18px;
}

.lux-metricCard{
  width: min(740px, 96vw);
  max-height: 90vh;
  overflow: auto;
  background: #fff;
  border-radius: 18px;
  box-shadow: 0 24px 60px rgba(0,0,0,0.22);
  padding: 22px 22px 18px;
  position: relative;
}

.lux-metricClose{
  position: absolute;
  top: 12px;
  right: 12px;
  width: 42px;
  height: 42px;
  border-radius: 14px;
  border: 1px solid rgba(0,0,0,0.10);
  background: rgba(255,255,255,0.92);
  cursor: pointer;
  font-size: 26px;
  line-height: 1;
  color: #64748b;
}
.lux-metricClose:hover{
  background: #fff;
  color: #0f172a;
}

/* ============================================================
   Card typography
   ============================================================ */
.lux-metricTop{
  text-align: center;
  padding-top: 6px;
}

.lux-metricTitle{
  font-weight: 950;
  font-size: 1.05rem;
  color:#334155;
}

/* PATCH 1 changed class from .lux-metricBig -> .lux-metricScore */
.lux-metricScore{
  font-weight: 1000;
  font-size: 2rem;
  color:#0f172a;
  margin-top: 6px;
}

.lux-metricBlurb{
  margin-top: 8px;
  color:#64748b;
  font-weight: 800;
  line-height: 1.35;
}

/* Keep legacy in case any older modal uses it */
.lux-metricBig{
  font-weight: 1000;
  font-size: 2rem;
  color:#0f172a;
  margin-top: 6px;
}

/* ============================================================
   Legacy KV blocks (still used in some sections)
   ============================================================ */
.lux-metricGrid{
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 10px;
}

.lux-metricKV{
  border: 1px solid rgba(0,0,0,0.08);
  background: rgba(248,250,252,0.7);
  border-radius: 14px;
  padding: 10px 12px;
}
.lux-metricKV-k{
  color:#64748b;
  font-weight: 900;
  font-size: 0.85rem;
}
.lux-metricKV-v{
  color:#0f172a;
  font-weight: 1000;
  font-size: 1.05rem;
  margin-top: 2px;
}

.lux-metricSubhead{
  margin-top: 6px;
  font-weight: 950;
  color:#334155;
}

.lux-metricChips{
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  margin-top: 8px;
}
.lux-metricChip{
  border: 1px solid rgba(0,0,0,0.10);
  background: rgba(255,255,255,0.85);
  border-radius: 999px;
  padding: 6px 10px;
  font-weight: 950;
  color:#0f172a;
  font-size: 0.85rem;
}

.lux-metricList{
  margin: 8px 0 0;
  padding-left: 18px;
  color:#334155;
  font-weight: 800;
  line-height: 1.4;
}

.lux-metricFoot{
  border-top: 1px dashed rgba(0,0,0,0.12);
  margin-top: 12px;
  padding-top: 10px;
  color:#475569;
  font-weight: 800;
}

/* ============================= */
/*  Modal segmentation + clarity */
/* ============================= */

.lux-metricSection{
  margin-top: 14px;
}

.lux-metricSectionTitle{
  font-size: 15px;
  font-weight: 800;
  margin-bottom: 10px;
}

/* Body wrapper inside sections */
.lux-metricSectionBody{
  color:#334155;
  font-weight: 800;
  line-height: 1.45;
}

/* Collapsible section (details) */
.lux-metricSection--details{
  border-top: 1px solid rgba(0,0,0,0.06);
  padding-top: 10px;
}

/* Summary should look like a section header */
.lux-metricSection--details > summary{
  cursor: pointer;
  user-select: none;
  list-style: none;
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 6px;
}

/* Remove default marker */
.lux-metricSection--details > summary::-webkit-details-marker{
  display:none;
}

.lux-metricSection--details > summary::after{
  content: "▸";
  opacity: 0.65;
  transform: translateY(-1px);
  transition: transform 160ms ease;
}

.lux-metricSection--details[open] > summary::after{
  transform: rotate(90deg) translateX(-1px);
}

/* ============================= */
/*  Bullets spacing              */
/* ============================= */

/* PATCH: your JS uses .lux-metricBullets */
.lux-metricBullets{
  margin: 0;
  padding-left: 18px;
}

.lux-metricBullets li{
  margin: 6px 0;
  line-height: 1.35;
}

/* Optional support if older code uses these */
.lux-bullets{
  margin: 0;
  padding-left: 18px;
}
.lux-bullets li{
  margin: 6px 0;
  line-height: 1.35;
}

/* Details blocks inside “How this score is measured” */
.lux-metricDetails{
  margin-top: 10px;
  border: 1px solid rgba(0,0,0,0.08);
  border-radius: 14px;
  padding: 10px 12px;
  background: rgba(248,250,252,0.75);
}
.lux-metricDetails summary{
  cursor: pointer;
  user-select: none;
  font-weight: 950;
  color:#0f172a;
}
.lux-metricDetailsBody{
  margin-top: 8px;
  color:#334155;
  font-weight: 800;
  line-height: 1.45;
}

/* ============================= */
/*  “What Lux found” mini tiles  */
/* ============================= */

.lux-metricKVGrid{
  display: grid;
  grid-template-columns: repeat(2, minmax(0,1fr));
  gap: 12px;
  margin-top: 10px;
}

.lux-kv{
  border: 1px solid rgba(0,0,0,0.10);
  background: #f8fafc;
  border-radius: 14px;
  padding: 10px 12px;
}

.lux-kv-label{
  font-size: 12px;
  font-weight: 700;
  opacity: 0.70;
  color:#0f172a;
}

.lux-kv-value{
  font-size: 16px;
  font-weight: 900;
  margin-top: 4px;
  color:#0f172a;
}

/* ============================= */
/*  Score meter bar (subtle)     */
/* ============================= */

.lux-metricMeter{
  width: 260px;
  max-width: 60%;
  height: 8px;
  border-radius: 999px;
  margin: 10px auto 0;
  background: rgba(0,0,0,0.08);
  overflow: hidden;
}

.lux-metricMeterFill{
  height: 100%;
  border-radius: 999px;
  background: #1e6fff;
}

/* ============================================================
   Responsive tweaks
   ============================================================ */
@media (max-width: 520px){
  .lux-metricCard{
    width: 96vw;
    padding: 18px 16px 14px;
  }
  .lux-metricKVGrid{
    grid-template-columns: 1fr;
  }
  .lux-metricMeter{
    max-width: 80%;
  }
}
</file>

<file path="lux-widgets.table.css">
/* lux-widgets.table.css */
/* Word & phoneme chart table (score-table) */

/* ============================================================
                           Table
   ============================================================ */
.score-table {
  border-collapse: collapse;
  width: 95%;
  margin: 1em auto;
  font-size: 1.09rem;
  table-layout: fixed;
}

/* SYNCED ZOOM TRANSITION: Applied to word and phoneme equally */
.score-table th,
.score-table td {
  border: 1px solid #bbb;
  padding: 10px;
  text-align: center;
  transition:
    width 0.35s cubic-bezier(0.45, 1.6, 0.4, 0.95),
    min-width 0.35s cubic-bezier(0.45, 1.6, 0.4, 0.95),
    max-width 0.35s cubic-bezier(0.45, 1.6, 0.4, 0.95),
    padding 0.35s ease,
    opacity 0.25s ease;

  overflow: hidden;

  /* IMPORTANT: stop wrapping which creates stacked/jumbled cells */
  white-space: nowrap;
}

.score-table th {
  background: #f3f7fa;
  font-weight: 700;
}

/* table score pills */
.score-good,
.score-warn,
.score-bad {
  position: relative;
  font-weight: 700;
  padding: 2px 6px 2px 24px;
  border-radius: 14px;
}

.score-good {
  color: #2563eb;
  background: #dbeafe;
}
.score-warn {
  color: #d97706;
  background: #fef3c7;
}
.score-bad {
  color: #dc2626;
  background: #fee2e2;
}

.score-good::before,
.score-warn::before,
.score-bad::before {
  position: absolute;
  left: 6px;
  top: 1px;
  font-size: 0.9em;
}
.score-good::before { content: "✔"; }
.score-warn::before { content: "⚠️"; }
.score-bad::before  { content: "✖"; }

/* keep tooltip/hover content visible for the ERROR column (now td.error-cell) */
#prettyResult .score-table td.error-cell,
#prettyResult .score-table th#errorHeader{
  overflow: visible !important;
}
</file>

<file path="wordcloud.html">
<!-- wordcloud.html -->
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Your Clouds</title>

    <link rel="stylesheet" href="lux-layout.css" />
    <link rel="stylesheet" href="lux-progress.css" />
    <link rel="stylesheet" href="lux-wordcloud.css" />

    <link rel="stylesheet" href="./ui/warp.css" />
  </head>

  <body>
    <div class="lux-container" id="container">
      <div class="lux-header">
        <h2>Your Clouds</h2>
        <div class="lux-toplinks">
          <a class="lux-toplink lux-navpill" href="./index.html" data-lux-ripple>
            Practice Skills
          </a>

          <a
            class="lux-toplink lux-navpill"
            href="./progress.html"
            data-lux-ripple
          >
            My Progress
          </a>

          <a
            class="lux-toplink lux-toplink-cta lux-cta-same"
            href="./convo.html"
          >
            AI Conversations
          </a>
        </div>
      </div>

      <div id="wordcloud-root"></div>
    </div>

    <script type="module" src="./src/wordcloud.js"></script>
    <script type="module" src="./ui/warp-nav.js"></script>
  </body>
</html>
</file>

<file path=".gitignore">
# dependencies
node_modules/

# CodeSandbox
.codesandbox/scripts/
.codesandbox/

# build output / caches
dist/
.vite/

# local env files (keep secrets out of git)
.env*
!.env.example

# logs
*.log
npm-debug.log*
yarn-debug.log*
pnpm-debug.log*

# lockfiles (keep only the one you actually use)
yarn.lock

# local video backups
public/convo-vid/*_ORIG.mp4

# Repomix output (keep ONLY the single latest file)
repomix-output.xml
repomix-*.xml
!repomix-frontend.LATEST.xml

# combined CSS artifact
lux-layout.COMBINED.css
</file>

<file path="features/convo/convo-flow.js">
// features/convo/convo-flow.js
import { buildConvoTargetOverlay } from "../next-activity/next-activity.js";
import { buildAudioConstraints } from "../recorder/audio-mode.js";
import { getAudioMode } from "../recorder/audio-mode.js";
import AudioInspector from "../recorder/audio-inspector.js";

export function wireConvoFlow({
  SCENARIOS,
  state,

  // DOM
  root,
  input,
  talkBtn,
  endBtn,

  // render hooks
  renderMessages,
  renderSuggestions,

  // APIs + helpers
  convoTurn,
  assessPronunciation,
  saveAttempt,
  uid,
  convoReport,
  showConvoReportOverlay,
}) {
  function scenarioForTurn() {
    const s = SCENARIOS[state.scenarioIdx];
    const overlay = buildConvoTargetOverlay(state.nextActivity);
    return {
      id: s.id,
      title: s.title,
      desc: overlay ? `${s.desc}\n\n${overlay}` : s.desc,
    };
  }

  function showNetErrorBubble(err) {
    const msg = err && err.message ? err.message : "Unknown error";

    // Visible bubble, but keep it OUT of model history by using role:"system"
    state.messages.push({
      role: "system",
      content: `⚠️ AI turn failed: ${msg}. Try again.`,
    });
    renderMessages();
    renderSuggestions([]);
  }

  function modelMessagesSlice() {
    // Never send "system" bubbles back to the model
    return state.messages
      .filter((m) => m.role === "assistant" || m.role === "user")
      .slice(-24);
  }

  async function startScenario() {
    // reset convo
    state.messages = [];
    state.turns = [];
    renderMessages();
    renderSuggestions([]);

    const scenario = scenarioForTurn();

    // ask backend for opening line + suggestions
    try {
      const rsp = await convoTurn({ scenario, knobs: state.knobs, messages: [] });
      state.messages.push({ role: "assistant", content: rsp.assistant });
      renderMessages();
      renderSuggestions(rsp.suggested_replies);
    } catch (err) {
      console.warn("[convo] startScenario failed", err);
      showNetErrorBubble(err);
    }
  }

  // --- Recording helpers ---
  async function startRecording() {
    state.chunks = [];

    state.stream = await navigator.mediaDevices.getUserMedia(buildAudioConstraints());

    // ✅ Inspector: note stream immediately (convo context)
    await AudioInspector.noteStream(state.stream, "convo");

    const prefer = ["audio/webm;codecs=opus", "audio/webm"];
    let opts = {};
    try {
      for (const t of prefer) {
        if (window.MediaRecorder?.isTypeSupported?.(t)) {
          opts.mimeType = t;
          break;
        }
      }
    } catch {}

    state.recorder = new MediaRecorder(state.stream, opts);

    // ✅ Inspector: note recorder right after creation
    AudioInspector.noteRecorder(state.recorder);

    state.recorder.ondataavailable = (e) => {
      if (e.data && e.data.size > 0) state.chunks.push(e.data);
    };

    state.recorder.start();
  }

  async function stopRecordingAndGetBlob() {
    return new Promise((resolve) => {
      if (!state.recorder) return resolve(null);

      const rec = state.recorder;
      rec.onstop = () => {
        try {
          state.stream?.getTracks()?.forEach((t) => t.stop());
        } catch (_) {}
        state.stream = null;

        const blob = new Blob(state.chunks, { type: rec.mimeType || "audio/webm" });

        // ✅ Inspector: note final blob right after creation
        AudioInspector.noteBlob(blob);

        state.chunks = [];
        state.recorder = null;
        resolve(blob);
      };

      rec.stop();
    });
  }

  // --- Turn send (assess -> attempt -> convoTurn) ---
  async function sendTurn({ audioBlob }) {
    const s = SCENARIOS[state.scenarioIdx];
    const scenario = scenarioForTurn();
    const userText = (input.value || "").trim();
    if (!userText) return;

    // Hand the finished learner audio to the Self Playback drawer (if present)
    if (audioBlob) {
      // ✅ Store latest recording globally so Self Playback can download it
      try {
        const mode = getAudioMode();
        window.LuxLastRecordingBlob = audioBlob;
        window.LuxLastRecordingMeta = {
          mode,
          type: audioBlob?.type || "",
          size: audioBlob?.size || 0,
          ts: Date.now(),
          scope: "convo",
        };

        window.dispatchEvent(
          new CustomEvent("lux:lastRecording", {
            detail: { blob: audioBlob, meta: window.LuxLastRecordingMeta },
          })
        );
      } catch {}

      if (window.__attachLearnerBlob) window.__attachLearnerBlob(audioBlob);
    }

    // show user msg in chat immediately (natural flow)
    state.messages.push({ role: "user", content: userText });
    renderMessages();
    input.value = "";

    // Azure assessment (silent) - only if we actually have audio
    let azureResult = null;
    try {
      if (audioBlob && audioBlob.size > 0) {
        azureResult = await assessPronunciation({ audioBlob, text: userText });
      }
    } catch (e) {
      console.error("[Convo] assess failed", e);
    }

    // save attempt (always)
    try {
      const saved = await saveAttempt({
        uid: uid(),
        passageKey: `convo:${s.id}`,
        partIndex: state.turns.length,
        text: userText,
        azureResult,
        sessionId: state.sessionId,
        localTime: new Date().toISOString(),
      });

      // Keep AI Coach wired to the latest convo attempt (Practice Skills parity)
      window.lastAttemptId = saved?.id || null;

      state.turns.push({ turn: state.turns.length, userText, azureResult, attemptId: saved?.id });
    } catch (e) {
      console.error("[Convo] saveAttempt failed", e);
      state.turns.push({ turn: state.turns.length, userText, azureResult, attemptId: null });
    }

    // Auto-open AI Coach after the first saved user turn
    try {
      const d = document.getElementById("aiCoachDrawer");
      if (d && !d.open && state.turns.length === 1) d.open = true;
    } catch (_) {}

    // refresh Conversation Skills progress (if present)
    if (window.refreshConvoProgress) {
      try {
        await window.refreshConvoProgress();
      } catch (_) {}
    }

    // next AI response + suggestions
    let rsp;
    try {
      rsp = await convoTurn({
        scenario,
        knobs: state.knobs,
        messages: modelMessagesSlice(),
      });
    } catch (err) {
      console.warn("[convo] convo-turn failed", err);
      showNetErrorBubble(err);
      return;
    }

    state.messages.push({ role: "assistant", content: rsp.assistant });
    renderMessages();
    renderSuggestions(rsp.suggested_replies);
  }

  // --- Buttons ---
  talkBtn.addEventListener("click", async () => {
    if (state.busy) return;

    // If we're currently recording, STOP and SEND
    if (state.isRecording) {
      state.busy = true;
      talkBtn.disabled = true;
      try {
        const blob = await stopRecordingAndGetBlob();
        state.isRecording = false;
        root.classList.remove("is-recording");
        talkBtn.textContent = "🎙 Record";
        if (blob) await sendTurn({ audioBlob: blob });
      } finally {
        state.busy = false;
        talkBtn.disabled = false;
      }
      return;
    }

    // Not recording yet => start (only if input has text)
    const userText = (input.value || "").trim();
    if (!userText) return;

    state.busy = true;
    talkBtn.disabled = true;
    try {
      await startRecording();
      state.isRecording = true;
      root.classList.add("is-recording");
      talkBtn.textContent = "■ Stop & Send";
    } catch (e) {
      console.error("[Convo] start recording failed", e);
      alert(`Recording failed: ${e?.message || e}`);
    } finally {
      state.busy = false;
      talkBtn.disabled = false;
    }
  });

  endBtn.addEventListener("click", async () => {
    try {
      const s = SCENARIOS[state.scenarioIdx];
      const report = await convoReport({
        uid: uid(),
        sessionId: state.sessionId,
        passageKey: `convo:${s.id}`,
      });

      console.log("[Convo] convo-report result", report);
      showConvoReportOverlay(report, state.turns, {
        nextActivity: state.nextActivity || null,
        turns: Array.isArray(state.turns) ? state.turns : [],
        sessionId: state.sessionId,
        passageKey: `convo:${s.id}`,
        scenario: { id: s.id, title: s.title },
      });

      // Keep the old debug dump too (harmless + useful)
      let pre = document.getElementById("luxConvoReportDump");
      if (!pre) {
        pre = document.createElement("pre");
        pre.id = "luxConvoReportDump";
        pre.style.cssText = `
          position: fixed; left: 12px; bottom: 12px; z-index: 99998;
          max-width: min(520px, 92vw);
          max-height: min(320px, 38vh);
          overflow: auto;
          white-space: pre-wrap;
          background: rgba(0,0,0,0.55);
          color: #e5e7eb;
          border: 1px solid rgba(255,255,255,0.10);
          border-radius: 12px;
          padding: 10px;
          font-size: 11px;
        `;
        (document.getElementById("convoApp") || document.body).appendChild(pre);
      }
      pre.textContent = JSON.stringify(report, null, 2);
    } catch (e) {
      console.error("[Convo] convo-report failed", e);
      alert(`End Session report failed: ${e?.message || e}`);
    }
  });

  return { startScenario };
}
</file>

<file path="features/interactions/metric-modal/render.js">
// features/interactions/metric-modal/render.js
// HTML builder for the metric explainer modal card.

import { fmtPct } from "../../../core/scoring/index.js";
import {
  getScorePack,
  deriveTimingStats,
  deriveErrorStats,
  prettyErrCounts,
  deriveCompletenessDiff,
  derivePhonemeClassSplit,
} from "./derive.js";

export const METRIC_META = {
  Overall: {
    title: "Overall",
    blurb:
      "Your overall score is an aggregate of the five core categories below. It gives a quick summary of this attempt.",
  },
  Pronunciation: {
    title: "Pronunciation",
    blurb: "A high-level pronunciation score based on how accurately you produced the expected sounds overall.",
  },
  Accuracy: {
    title: "Accuracy",
    blurb: "How close your pronunciation was to the expected target sounds (segment-by-segment accuracy).",
  },
  Fluency: {
    title: "Fluency",
    blurb: "How smooth and natural your speech flow was—often affected by pausing, stopping, and restarts.",
  },
  Completeness: {
    title: "Completeness",
    blurb: "Whether you said all the words from the reference (and whether anything was skipped or extra).",
  },
  Prosody: {
    title: "Prosody",
    blurb: "Stress, rhythm, intonation, and pacing — how your speech “sounds as a whole,” not just individual sounds.",
  },
};

export const esc = (s) =>
  String(s ?? "")
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;");

function kv(label, val) {
  return `
    <div class="lux-metricKV">
      <div class="lux-metricKV-k">${esc(label)}</div>
      <div class="lux-metricKV-v">${esc(val)}</div>
    </div>
  `;
}

/* ============================================================================
   Section helpers
============================================================================ */

/** Standard section block */
function section(title, body) {
  return `
    <section class="lux-metricSection">
      <h3 class="lux-metricSectionTitle">${esc(title)}</h3>
      <div class="lux-metricSectionBody">${body}</div>
    </section>
  `;
}

/** Collapsible (details/summary) section block */
function sectionDetails(title, body, { open = false } = {}) {
  return `
    <details class="lux-metricSection lux-metricSection--details" ${open ? "open" : ""}>
      <summary class="lux-metricSectionTitle">${esc(title)}</summary>
      <div class="lux-metricSectionBody">${body}</div>
    </details>
  `;
}

function buildMeta(metricKey, pack) {
  const base = METRIC_META[metricKey] || { title: metricKey, blurb: "" };

  const valMap = {
    Overall: pack.overallAgg,
    Pronunciation: pack.pronunciation,
    Accuracy: pack.accuracy,
    Fluency: pack.fluency,
    Completeness: pack.completeness,
    Prosody: pack.prosody,
  };

  return {
    title: base.title || metricKey,
    blurb: base.blurb || "",
    value: valMap[metricKey],
  };
}

export function buildModalHtml(metricKey, data) {
  const azure = data?.azureResult || data;
  const referenceText = data?.referenceText || "";

  const pack = getScorePack(azure);
  const meta = buildMeta(metricKey, pack);

  const timing = deriveTimingStats(azure);
  const errs = deriveErrorStats(azure);
  const diff = deriveCompletenessDiff(referenceText, azure);
  const classSplit = derivePhonemeClassSplit(azure);

  const score = meta.value;

  // ✅ TOP BLOCK (with subtle meter bar)
  const top = `
    <div class="lux-metricTop">
      <div class="lux-metricTitle">${esc(metricKey)}</div>
      <div class="lux-metricScore">${esc(fmtPct(score))}</div>
      <div class="lux-metricMeter" aria-hidden="true">
        <div class="lux-metricMeterFill" style="width:${Math.max(
          0,
          Math.min(100, Number(score) || 0)
        )}%"></div>
      </div>
      <div class="lux-metricBlurb">${esc(meta.blurb || "")}</div>
    </div>
  `;

  const explainerBlock = section("How this score is measured", explainMetric(metricKey));

  const uniqueBlock = section(
    "What Lux found (unique)",
    uniqueMetricPanel(metricKey, { pack, timing, errs, diff, classSplit })
  );

  // ✅ COLLAPSED BY DEFAULT (no “wall of text” on first glance)
  const interpretBlock = sectionDetails(
    "How to interpret it",
    interpretMetric(metricKey, pack),
    { open: false }
  );

  const helpBlock = section("Need help?", helpCta(metricKey));

  return `
    ${top}

    ${explainerBlock}
    ${uniqueBlock}
    ${interpretBlock}
    ${helpBlock}

    <div class="lux-metricFoot">
      <span style="color:#64748b;">Tip:</span>
      These cards are “data + explanations.” The AI Coach stays separate and focuses on personalized strategy.
    </div>
  `;
}

/* ============================================================================
   New helpers (metric-specific modal sections)
============================================================================ */

function bullets(items = []) {
  return `<ul class="lux-metricBullets">${(items || [])
    .map((x) => `<li>${esc(x)}</li>`)
    .join("")}</ul>`;
}

function explainMetric(metricKey) {
  const map = {
    Overall: {
      simple: [
        "A quick combined snapshot of all five categories.",
        "Not a separate measurement — it’s just a simple blend.",
        "Use it to track progress, then click a tile for specifics.",
      ],
      advanced:
        "Lux currently computes Overall as an equal-weight mean of Accuracy, Fluency, Completeness, Prosody, and Pronunciation.",
    },
    Pronunciation: {
      simple: [
        "A big-picture score of how close your sounds were overall.",
        "More global than Accuracy (which is phoneme-by-phoneme).",
        "Great for tracking improvement across attempts.",
      ],
      advanced:
        "Pronunciation summarizes overall sound quality and is often influenced by both segment accuracy and prosodic naturalness.",
    },
    Accuracy: {
      simple: [
        "How correct each sound (phoneme) was compared to the target.",
        "Sensitive to substitutions, deletions, and insertions.",
        "Best metric for pinpointing specific sound errors.",
      ],
      advanced:
        "Accuracy reflects closeness to expected target phonemes and is the most “microscopic” score of the five.",
    },
    Fluency: {
      simple: [
        "Smoothness: pauses, stops, and interruptions between words.",
        "Fluency is NOT about speaking fast — it’s about flow.",
        "A few long pauses can drop this score quickly.",
      ],
      advanced:
        "Fluency primarily reflects silent breaks and disfluency patterns across the utterance.",
    },
    Completeness: {
      simple: [
        "Did you say all expected words in the reference text?",
        "Skipping small words (the / a / to) can lower this a lot.",
        "Most improved by slowing down and reading fully.",
      ],
      advanced:
        "Completeness is essentially a reference-match ratio: spoken words vs expected words.",
    },
    Prosody: {
      simple: [
        "How natural your speech sounds as a whole.",
        "Includes stress, rhythm, intonation, and pacing.",
        "You can have great sounds but low prosody (robotic rhythm).",
      ],
      advanced:
        "Prosody relates to timing patterns, emphasis, and pitch movement — not just correctness of phonemes.",
    },
  };

  const info = map[metricKey] || map.Overall;
  return `
    ${bullets(info.simple)}
    <details class="lux-metricDetails">
      <summary>More technical</summary>
      <div class="lux-metricDetailsBody">${esc(info.advanced)}</div>
    </details>
  `;
}

function interpretMetric(metricKey, pack) {
  void pack; // pack may be used later for more personalized tips

  const tips = {
    Overall: [
      "Click the lowest tile — that’s what pulled the overall down most.",
      "Big gaps between tiles = uneven skill profile (totally normal).",
    ],
    Pronunciation: [
      "High Pronunciation + low Prosody usually means clear sounds but “flat” rhythm.",
      "High Prosody + low Accuracy usually means good flow but wrong consonants/vowels.",
    ],
    Accuracy: [
      "If Accuracy is low, focus on 1–2 sounds at a time (not everything).",
      "Look for patterns: vowels vs consonants vs voicing.",
    ],
    Fluency: [
      "A few long pauses hurt more than many tiny pauses.",
      "Try chunking phrases (meaning groups) instead of word-by-word starts.",
    ],
    Completeness: [
      "If Completeness is low, slow down and prioritize saying every word.",
      "Function words matter: the / a / to / of / in.",
    ],
    Prosody: [
      "Prosody improves fastest when you imitate short phrases with rhythm.",
      "Aim for natural emphasis, not perfect speed.",
    ],
  };

  return bullets(tips[metricKey] || tips.Overall);
}

function uniqueMetricPanel(metricKey, ctx) {
  const { pack, timing, errs, diff, classSplit } = ctx;

  // Common “quick insight” for all: what’s lowest?
  const five = [
    ["Accuracy", pack.accuracy],
    ["Fluency", pack.fluency],
    ["Completeness", pack.completeness],
    ["Prosody", pack.prosody],
    ["Pronunciation", pack.pronunciation],
  ].filter(([, v]) => v != null);

  const lowest = five.slice().sort((a, b) => (a[1] ?? 0) - (b[1] ?? 0))[0];

  const base = `
    <div class="lux-metricKVGrid">
      <div class="lux-kv">
        <div class="lux-kv-label">Lowest driver</div>
        <div class="lux-kv-value">${esc(lowest?.[0] || "—")}</div>
      </div>
      <div class="lux-kv">
        <div class="lux-kv-label">Lowest score</div>
        <div class="lux-kv-value">${esc(fmtPct(lowest?.[1]))}</div>
      </div>
    </div>
  `;

  // Completeness: show missing/extra vs reference
  if (metricKey === "Completeness") {
    if (!diff) {
      return base + `<div class="lux-muted">Reference text not available for this attempt.</div>`;
    }

    return (
      base +
      `
      <div class="lux-metricKVGrid">
        <div class="lux-kv">
          <div class="lux-kv-label">Expected words</div>
          <div class="lux-kv-value">${esc(String(diff.refCount))}</div>
        </div>
        <div class="lux-kv">
          <div class="lux-kv-label">You said</div>
          <div class="lux-kv-value">${esc(String(diff.saidCount))}</div>
        </div>
        <div class="lux-kv">
          <div class="lux-kv-label">Missing</div>
          <div class="lux-kv-value">${
            diff.missing.length ? esc(diff.missing.join(", ")) : "None ✅"
          }</div>
        </div>
        <div class="lux-kv">
          <div class="lux-kv-label">Extra</div>
          <div class="lux-kv-value">${
            diff.extra.length ? esc(diff.extra.join(", ")) : "None ✅"
          }</div>
        </div>
      </div>
    `
    );
  }

  // Accuracy/Pronunciation: vowel vs consonant weakness split
  if (metricKey === "Accuracy" || metricKey === "Pronunciation") {
    if (!classSplit) return base;

    return (
      base +
      `
      <div class="lux-metricKVGrid">
        <div class="lux-kv">
          <div class="lux-kv-label">Weak vowels</div>
          <div class="lux-kv-value">${esc(
            `${Math.round(classSplit.weakShareVowels * 100)}%`
          )}</div>
        </div>
        <div class="lux-kv">
          <div class="lux-kv-label">Weak consonants</div>
          <div class="lux-kv-value">${esc(
            `${Math.round(classSplit.weakShareConsonants * 100)}%`
          )}</div>
        </div>
      </div>
    `
    );
  }

  // Fluency/Prosody/Overall: timing & pacing sanity + pause ratios
  if (metricKey === "Fluency" || metricKey === "Prosody" || metricKey === "Overall") {
    if (!timing?.isSane) {
      return base + `<div class="lux-muted">Timing stats not available for this attempt.</div>`;
    }

    return (
      base +
      `
      <div class="lux-metricKVGrid">
        <div class="lux-kv"><div class="lux-kv-label">Words</div><div class="lux-kv-value">${esc(
          String(timing.wordsCount)
        )}</div></div>
        <div class="lux-kv"><div class="lux-kv-label">Span</div><div class="lux-kv-value">${esc(
          timing.spanSec != null ? `${timing.spanSec.toFixed(2)}s` : "—"
        )}</div></div>
        <div class="lux-kv"><div class="lux-kv-label">WPM</div><div class="lux-kv-value">${esc(
          timing.wpm != null ? `${timing.wpm.toFixed(0)}` : "—"
        )}</div></div>
        <div class="lux-kv"><div class="lux-kv-label">Pause count</div><div class="lux-kv-value">${esc(
          String(timing.pauseCount)
        )}</div></div>
        <div class="lux-kv"><div class="lux-kv-label">Pause share</div><div class="lux-kv-value">${esc(
          timing.pauseRatio != null ? `${Math.round(timing.pauseRatio * 100)}%` : "—"
        )}</div></div>
        <div class="lux-kv"><div class="lux-kv-label">Longest pause</div><div class="lux-kv-value">${esc(
          timing.longestPause != null ? `${timing.longestPause.toFixed(2)}s` : "—"
        )}</div></div>
      </div>
    `
    );
  }

  // Default: concise error fingerprint (if present)
  if (errs) {
    const topPh = (errs.worstPhonemes || [])
      .slice(0, 3)
      .map((x) => x.phoneme)
      .filter(Boolean)
      .join(", ");

    const topW = (errs.worstWords || [])
      .slice(0, 3)
      .map((x) => x.word)
      .filter(Boolean)
      .join(", ");

    const errTypes = prettyErrCounts(errs.errCounts);

    return (
      base +
      `
      <div class="lux-metricKVGrid">
        <div class="lux-kv">
          <div class="lux-kv-label">Top weak sounds</div>
          <div class="lux-kv-value">${esc(topPh || "—")}</div>
        </div>
        <div class="lux-kv">
          <div class="lux-kv-label">Top weak words</div>
          <div class="lux-kv-value">${esc(topW || "—")}</div>
        </div>
        <div class="lux-kv" style="grid-column:1 / -1;">
          <div class="lux-kv-label">Error types</div>
          <div class="lux-kv-value">${esc(errTypes || "—")}</div>
        </div>
      </div>
    `
    );
  }

  return base;
}

function helpCta(metricKey) {
  const topic = String(metricKey || "").toLowerCase();
  return `
    <button class="lux-helpBtn" type="button"
      onclick="window.openLuxHelp ? window.openLuxHelp('${esc(topic)}') : alert('Lux Help is coming soon.')">
      Ask Lux Help about ${esc(metricKey)} →
    </button>
  `;
}
</file>

<file path="features/interactions/ph-hover/dom.js">
// features/interactions/ph-hover/dom.js
// Global tooltip DOM + CSS injection + hide scheduling + outside-close.
// This module does NOT decide tooltip content — it only provides the container + rules.

export function ensureGlobalTooltip(state, { scheduleHide } = {}) {
  if (state.globalTooltip) return state.globalTooltip;

  // Put the CSS in <head> ONCE (not inside tooltip),
  // because tooltipContent.innerHTML updates would wipe it.
  injectTooltipCSS();

  const globalTooltip = document.createElement("div");
  globalTooltip.id = "lux-global-ph-tooltip";

  globalTooltip.style.cssText = `
    position: fixed;
    z-index: var(--z-popover);
    visibility: hidden;
    opacity: 0;
    transition: opacity 0.15s ease, transform 0.15s ease;
    background: #1e293b;
    color: #fff;
    padding: 0;
    border-radius: 8px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.35);
    width: min(560px, calc(100vw - 20px));
    pointer-events: auto;
    font-family: system-ui, sans-serif;
    font-size: 14px;
    line-height: 1.4;
    overflow: hidden;
  `;

  const tooltipContent = document.createElement("div");
  tooltipContent.id = "lux-global-ph-tooltip-content";
  globalTooltip.appendChild(tooltipContent);

  // Hover bridge: keep tooltip open while mouse is over it
  globalTooltip.addEventListener("mouseenter", () => {
    if (state.hideTimeout) clearTimeout(state.hideTimeout);
  });

  globalTooltip.addEventListener("mouseleave", () => {
    if (typeof scheduleHide === "function") scheduleHide();
  });

  document.body.appendChild(globalTooltip);

  // Save into shared state
  state.globalTooltip = globalTooltip;
  state.tooltipContent = tooltipContent;

  return globalTooltip;
}

export function injectTooltipCSS() {
  if (document.getElementById("lux-global-ph-tooltip-style")) return;

  const style = document.createElement("style");
  style.id = "lux-global-ph-tooltip-style";

  style.textContent = `
    #lux-global-ph-tooltip video::-webkit-media-controls { display:none !important; }
    #lux-global-ph-tooltip video::-webkit-media-controls-enclosure { display:none !important; }
    #lux-global-ph-tooltip video::-webkit-media-controls-panel { display:none !important; }

    /* ---- Topbar (IPA + mode nav + close) ---- */
    #lux-global-ph-tooltip .lux-ph-topbar{
      background:#0f172a;
      padding: 8px 10px;
      border-bottom:1px solid rgba(255,255,255,0.06);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }

    #lux-global-ph-tooltip .lux-ph-ipaBlock{
      min-width: 0;
      display:flex;
      align-items:baseline;
      gap:8px;
      flex: 1;
    }

    #lux-global-ph-tooltip .lux-ph-ipa{
      font-weight:900;
      font-size: 1.1em;
      color:#fff;
      white-space:nowrap;
    }

    #lux-global-ph-tooltip .lux-ph-examples{
      color:#94a3b8;
      font-size: 12px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      min-width: 0;
    }

    #lux-global-ph-tooltip .lux-ph-modeNav{
      display:flex;
      align-items:center;
      gap:8px;
      flex: 0 0 auto;
    }

    #lux-global-ph-tooltip .lux-ph-nav-btn{
      width:28px;
      height:28px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.06);
      color:#e2e8f0;
      cursor:pointer;
      line-height: 1;
      display:flex;
      align-items:center;
      justify-content:center;
      user-select:none;
    }

    #lux-global-ph-tooltip .lux-ph-nav-btn:disabled{
      opacity:0.35;
      cursor:default;
    }

    #lux-global-ph-tooltip .lux-ph-modeTitle{
      font-size:12px;
      letter-spacing:0.02em;
      color:#cbd5e1;
      font-weight:900;
      white-space:nowrap;
    }

    #lux-global-ph-tooltip .lux-ph-closeBtn{
      border:0;
      background:rgba(255,255,255,0.08);
      color:#e2e8f0;
      border-radius:10px;
      width:30px;
      height:30px;
      cursor:pointer;
      font-size:16px;
      line-height:30px;
      flex: 0 0 auto;
    }

    /* Center the ✕ perfectly inside its button */
    #lux-global-ph-tooltip #lux-ph-close{
      display: grid;
      place-items: center;
      width: 34px;
      height: 34px;
      line-height: 1;
    }

    /* Single source of truth for the panel text (no duplicates) */
    #lux-global-ph-tooltip .lux-ph-panelText{
      background:#0f172a;
      color:#e2e8f0;
      font-size:13px;
      padding: 10px 12px 12px;
      border-bottom:1px solid #334155;
      white-space: normal;
    }

    #lux-global-ph-tooltip .lux-ph-panelText.is-empty{
      color:#94a3b8;
      font-style:italic;
    }

    /* ---- Video block (bigger + clickable play system) ---- */
    #lux-global-ph-tooltip .lux-ph-vidBox{
      background:#000;
      padding: 6px;
    }

    #lux-global-ph-tooltip .lux-ph-vidControls{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom:10px;
    }

    #lux-global-ph-tooltip .lux-ph-vidBtns{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
    }

    #lux-global-ph-tooltip .lux-ph-miniBtn{
      border:0;
      background:rgba(255,255,255,0.10);
      color:#e2e8f0;
      border-radius:999px;
      padding:6px 10px;
      font-size:12px;
      font-weight:800;
      cursor:pointer;
    }

    #lux-global-ph-tooltip .lux-ph-miniBtn.is-primary{
      background:rgba(96,165,250,0.35);
    }

    #lux-global-ph-tooltip .lux-ph-miniBtn:active{
      transform: translateY(1px);
    }

    /* ---- Expand button: visible breathe + stable bigger hover ---- */
    #lux-global-ph-tooltip #lux-ph-expand{
      position: relative;
      transform-origin: center;
      will-change: transform, filter, box-shadow;

      /* IMPORTANT: make hover “stay expanded” (no twitch) */
      transform: scale(1);
      transition:
        transform 180ms cubic-bezier(.2,.9,.2,1),
        filter 180ms ease,
        box-shadow 240ms ease;

      /* Always-on breathe (VISIBLE, but subtle) */
      animation: luxExpandBreathe 2400ms ease-in-out infinite;
    }

    /* Bigger bulge than other buttons — and it STAYS while hovered */
    #lux-global-ph-tooltip #lux-ph-expand:hover{
      transform: scale(1.22);                 /* hair bigger than before */
      filter: brightness(1.14);
      box-shadow: 0 0 18px rgba(96,165,250,0.38);
      animation-play-state: paused;           /* prevents “breathing jitter” while hovering */
    }

    /* The delayed 2s “attention nudge” — keep it non-transform to avoid fighting hover scale */
    #lux-global-ph-tooltip #lux-ph-expand.lux-expand-attn{
      animation: luxExpandAttention 560ms cubic-bezier(.2,.9,.2,1) both;
    }

    /* box-shadow/brightness pulse so it’s actually visible */
    @keyframes luxExpandBreathe{
      0%{
        filter: brightness(1.02);
        box-shadow: 0 0 0 rgba(96,165,250,0.00);
      }
      55%{
        filter: brightness(1.10);
        box-shadow: 0 0 16px rgba(96,165,250,0.22);
      }
      100%{
        filter: brightness(1.02);
        box-shadow: 0 0 0 rgba(96,165,250,0.00);
      }
    }

    /* Attention pulse (no transform = no hover twitch) */
    @keyframes luxExpandAttention{
      0%{
        filter: brightness(1.02);
        box-shadow: 0 0 0 rgba(96,165,250,0.00);
      }
      55%{
        filter: brightness(1.22);
        box-shadow: 0 0 22px rgba(96,165,250,0.42);
      }
      100%{
        filter: brightness(1.02);
        box-shadow: 0 0 0 rgba(96,165,250,0.00);
      }
    }

    #lux-global-ph-tooltip .lux-ph-speed{
      background: rgba(255,255,255,0.10);
      color:#e2e8f0;
      border: 0;
      border-radius: 999px;
      padding: 6px 10px;
      font-weight: 800;
      font-size: 12px;
      cursor: pointer;
    }

    #lux-global-ph-tooltip .lux-ph-vidGrid{
      display:grid;
      gap: 6px;
    }

    #lux-global-ph-tooltip .lux-ph-vidGrid[data-cols="1"]{
      grid-template-columns:1fr;
    }

    #lux-global-ph-tooltip .lux-ph-vidGrid[data-cols="2"]{
      grid-template-columns:repeat(2, minmax(0, 1fr));
    }

    #lux-global-ph-tooltip .lux-ph-vidTile{
      position:relative;
      border-radius:12px;
      overflow:hidden;
      background:#05070f;
      aspect-ratio: 16 / 10;
      cursor:pointer;
    }

    #lux-global-ph-tooltip .lux-ph-vidTile video{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      object-fit: cover;
      transform: scale(1.06);
    }

    #lux-global-ph-tooltip .lux-ph-vidOverlay{
      position:absolute;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      background:rgba(0,0,0,0.25);
      font-size:34px;
      opacity:0.88;
      transition: opacity 140ms ease;
      pointer-events:none;
    }

    #lux-global-ph-tooltip .lux-ph-vidTile.is-playing .lux-ph-vidOverlay{
      opacity:0;
    }

    #lux-global-ph-tooltip .lux-ph-vidLabel{
      position:absolute;
      left:8px;
      bottom:8px;
      background:rgba(0,0,0,0.55);
      color:#e2e8f0;
      font-size:11px;
      padding:4px 8px;
      border-radius:999px;
      font-weight:800;
    }

    /* ---- Video Focus Modal ---- */
    .lux-ph-modalBack{
      position: fixed;
      inset: 0;
      background: rgba(2,6,23,0.62);
      backdrop-filter: blur(2px);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
    }

    .lux-ph-modalCard{
      width: min(980px, 96vw);
      height: min(650px, 88vh);
      background: #0b1020;
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 16px;
      box-shadow: 0 22px 70px rgba(0,0,0,0.55);
      padding: 14px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .lux-ph-modalTop{
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      flex-wrap: wrap;
    }

    .lux-ph-modalTitle{
      color: #e2e8f0;
      font-weight: 900;
      font-size: 13px;
      opacity: 0.9;
      white-space: nowrap;
      margin-right: 10px;
    }

    .lux-ph-modalGrid{
      flex: 1;
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 10px;
      min-height: 0;
    }

    /* Modal needs the same video tile rules (not scoped to tooltip id) */
    .lux-ph-modalCard .lux-ph-vidTile{
      position: relative;
      border-radius: 12px;
      overflow: hidden;
      background: #05070f;
      cursor: pointer;
      height: 100%;
      aspect-ratio: auto; /* override */
    }

    .lux-ph-modalCard .lux-ph-vidTile video{
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      transform: scale(1.06);
    }

    .lux-ph-modalCard .lux-ph-vidOverlay{
      position: absolute;
      inset: 0;
      display:flex;
      align-items:center;
      justify-content:center;
      background:rgba(0,0,0,0.25);
      font-size:34px;
      opacity:0.88;
      transition: opacity 140ms ease;
      pointer-events:none;
    }

    .lux-ph-modalCard .lux-ph-vidTile.is-playing .lux-ph-vidOverlay{
      opacity:0;
    }

    .lux-ph-modalCard .lux-ph-vidLabel{
      position:absolute;
      left:8px;
      bottom:8px;
      background:rgba(0,0,0,0.55);
      color:#e2e8f0;
      font-size:11px;
      padding:4px 8px;
      border-radius:999px;
      font-weight:800;
    }
  `;

  document.head.appendChild(style);
}

// Schedules hide unless tooltip is pinned.
export function scheduleHide(state, hideTooltip) {
  if (state.tooltipPinned) return;

  if (state.hideTimeout) clearTimeout(state.hideTimeout);

  state.hideTimeout = setTimeout(() => {
    try {
      hideTooltip?.();
    } catch (_) {}
  }, 200);
}

// Close if you click/tap outside tooltip AND outside any phoneme chip
export function bindOutsideCloseOnce(state, hideTooltip) {
  if (state.outsideCloseBound) return;
  state.outsideCloseBound = true;

  document.addEventListener(
    "pointerdown",
    (e) => {
      if (!state.tooltipPinned) return;

      const t = e.target;
      if (!t) return;

      // Click inside tooltip -> keep open
      const tip = state.globalTooltip;
      if (tip && (t === tip || tip.contains(t))) return;

      // Click on a chip -> let chip handler decide
      const chip = t.closest?.(".phoneme-chip[data-hydrated]");
      if (chip && chip.id !== "phonemeTitle") return;

      // Otherwise close
      try {
        hideTooltip?.();
      } catch (_) {}
    },
    { capture: true }
  );
}
</file>

<file path="features/my-words/launcher.js">
// features/my-words/launcher.js
// Corner launcher + lazy boot entrypoint

function shouldHideOnThisPage() {
  // ✅ hide on AI landing page (keep BOTH checks for safety)
  if (location.pathname.toLowerCase().includes("ai")) return true;
  if (document.querySelector(".lux-ai-landing")) return true;
  return false;
}

/**
 * OLD NAME (your code still imports this)
 * ✅ Keep it for compatibility.
 */
export function mountMyWordsCornerLauncher({ onClick } = {}) {
  if (shouldHideOnThisPage()) return null;

  let btn = document.querySelector(".lux-mw-corner");
  if (!btn) {
    btn = document.createElement("button");
    btn.className = "lux-mw-corner";
    btn.type = "button";
    btn.innerHTML = `<span class="lux-mw-corner-ink">📝</span>`;
    document.body.appendChild(btn);
  }

  // ✅ Remove any previous handler (prevents duplicate listeners)
  if (btn.__luxMwHandler) {
    btn.removeEventListener("click", btn.__luxMwHandler);
  }

  const handler = (e) => {
    e.preventDefault();
    try {
      onClick?.(e);
    } catch (_) {}
  };

  btn.__luxMwHandler = handler;
  btn.addEventListener("click", handler);

  return btn;
}

/**
 * NEW NAME (what we want main.js to call)
 * ✅ Boots My Words ONLY when clicked (lazy import)
 */
export function bootMyWordsLauncher() {
  let booted = false;
  let api = null; // ✅ holds { store, sidecar, modal, launcher }

  mountMyWordsCornerLauncher({
    onClick: async () => {
      if (!booted) {
        booted = true;
        const mod = await import("./index.js");
        api = await mod.initMyWordsEverywhere?.();
      }

      // ✅ toggle via returned store FIRST (most reliable)
      if (api?.store?.toggleOpen) {
        api.store.toggleOpen();
        return;
      }

      // ✅ fallback if global exists
      window.LuxMyWords?.toggle?.();
    },
  });
}
</file>

<file path="features/my-words/service.js">
/**
 * features/my-words/service.js
 * Supabase persistence for authenticated users ONLY.
 */
import { supabase } from "../../src/supabase.js";
import { normalizeText } from "./normalize.js";

export async function getAuthedUID() {
  try {
    const { data } = await supabase.auth.getUser();
    return data?.user?.id || null;
  } catch {
    return null;
  }
}

export async function fetchMyWords(uid) {
  if (!uid) return [];

  const { data, error } = await supabase
    .from("my_words_entries")
    .select("*")
    .eq("uid", uid)
    .eq("archived", false)
    .order("pinned", { ascending: false })
    .order("updated_at", { ascending: false });

  if (error) {
    console.warn("[my-words] fetchMyWords error:", error);
    return [];
  }

  return data || [];
}

export async function upsertManyMyWords(uid, texts) {
  if (!uid) return;

  const now = new Date().toISOString();
  const rows = (texts || [])
    .map((t) => String(t || "").trim())
    .filter(Boolean)
    .map((text) => ({
      uid,
      text,
      normalized_text: normalizeText(text),
      pinned: false,
      archived: false,
      updated_at: now,
    }));

  if (!rows.length) return;

  const { error } = await supabase
    .from("my_words_entries")
    .upsert(rows, {
      onConflict: "uid,normalized_text",
      ignoreDuplicates: true,
    });

  if (error) {
    console.warn("[my-words] upsertManyMyWords error:", error);
    throw error;
  }
}

export async function setPinned(uid, id, pinned) {
  if (!uid || !id) return;

  const { error } = await supabase
    .from("my_words_entries")
    .update({ pinned: !!pinned, updated_at: new Date().toISOString() })
    .eq("uid", uid)
    .eq("id", id);

  if (error) console.warn("[my-words] setPinned error:", error);
}

export async function archiveEntry(uid, id) {
  if (!uid || !id) return;

  const { error } = await supabase
    .from("my_words_entries")
    .update({ archived: true, updated_at: new Date().toISOString() })
    .eq("uid", uid)
    .eq("id", id);

  if (error) console.warn("[my-words] archiveEntry error:", error);
}

// ✅ PHASE 5: Restore / Un-archive (explicit call)
export async function restoreEntry(uid, id) {
  if (!uid || !id) return;

  const { error } = await supabase
    .from("my_words_entries")
    .update({ archived: false, updated_at: new Date().toISOString() })
    .eq("uid", uid)
    .eq("id", id);

  if (error) console.warn("[my-words] restoreEntry error:", error);
}

/**
 * ✅ Generic archived toggle helper (supports restore/unarchive)
 * archived=true  -> archive
 * archived=false -> restore
 */
export async function setArchived(uid, id, archived) {
  if (!uid || !id) return;

  const { error } = await supabase
    .from("my_words_entries")
    .update({ archived: !!archived, updated_at: new Date().toISOString() })
    .eq("uid", uid)
    .eq("id", id);

  if (error) console.warn("[my-words] setArchived error:", error);
}

export async function deleteEntry(uid, id) {
  if (!uid || !id) return;

  const { error } = await supabase
    .from("my_words_entries")
    .delete()
    .eq("uid", uid)
    .eq("id", id);

  if (error) console.warn("[my-words] deleteEntry error:", error);
}
</file>

<file path="features/progress/render.js">
// features/progress/render.js
// NOTE: This file used to be a pure re-export barrel.
// We keep that behavior, but we ALSO add a tiny helper that:
// 1) ensures the "My Words" button exists in the actions area (if possible)
// 2) wires it to open the global My Words Library modal

export * from "./render/index.js";

/**
 * Ensures + wires the "My Words" Library gateway button on the Progress page.
 *
 * Expected markup target:
 *  - actions area container (we try a few common selectors)
 *  - button id: #luxMyWordsLibraryBtn
 *
 * Call this right after the dashboard/progress UI renders.
 */
export function wireMyWordsLibraryGateway(root) {
  if (!root) return;

  // 1) Ensure the button exists (if template didn't include it yet)
  let mwBtn = root.querySelector("#luxMyWordsLibraryBtn");

  if (!mwBtn) {
    // Try to locate an actions container
    const actionsHost =
      root.querySelector("#luxProgressActions") ||
      root.querySelector(".lux-actions") ||
      root.querySelector(".lux-dashboard-actions") ||
      root.querySelector("[data-lux-actions]");

    if (actionsHost) {
      mwBtn = document.createElement("button");
      mwBtn.className = "lux-btn";
      mwBtn.id = "luxMyWordsLibraryBtn";
      mwBtn.type = "button";
      mwBtn.textContent = "My Words";

      actionsHost.appendChild(mwBtn);
    }
  }

  // 2) Wire click → open library (global hook set by initMyWordsGlobal)
  if (mwBtn) {
    mwBtn.addEventListener("click", () => {
      window.LuxMyWords?.openLibrary?.();
    });
  }
}
</file>

<file path="features/progress/wordcloud/action-sheet.js">
// features/progress/wordcloud/action-sheet.js
import { esc, getColorConfig } from "../progress-utils.js";

const FAV_KEY = "lux.cloud.favs.v1";
const PIN_KEY = "lux.cloud.pins.v1";

function readStore(key) {
  try {
    const raw = localStorage.getItem(key);
    const obj = raw ? JSON.parse(raw) : null;
    const out = obj && typeof obj === "object" ? obj : {};
    out.words = Array.isArray(out.words) ? out.words : [];
    out.phonemes = Array.isArray(out.phonemes) ? out.phonemes : [];
    return out;
  } catch (_) {
    return { words: [], phonemes: [] };
  }
}

function writeStore(key, obj) {
  try {
    localStorage.setItem(key, JSON.stringify(obj));
  } catch (_) {}
}

function hasItem(kind, id, store) {
  const arr = kind === "phoneme" ? store.phonemes : store.words;
  return arr.some((x) => String(x).toLowerCase() === String(id).toLowerCase());
}

function toggleItem(kind, id, key) {
  const store = readStore(key);
  const arrKey = kind === "phoneme" ? "phonemes" : "words";
  const arr = store[arrKey] || [];
  const norm = String(id).trim();
  const next = arr.filter((x) => String(x).toLowerCase() !== norm.toLowerCase());
  if (next.length === arr.length) next.unshift(norm); // add
  store[arrKey] = next.slice(0, 50);
  writeStore(key, store);
  return hasItem(kind, id, store);
}

function labelFor(avg) {
  const n = Number(avg) || 0;
  if (n >= 80) return "Good";
  if (n >= 60) return "Developing";
  return "Needs work";
}

function safePct(v) {
  if (!Number.isFinite(Number(v))) return "–";
  return `${Math.round(Number(v))}%`;
}

export function createCloudActionSheet({
  onGenerate = null,
  onOpenAttempt = null,
  onStoreChange = null,
} = {}) {
  let overlay = null;
  let sheet = null;

  let state = null; // { kind, id, title, avg, count, days, priority, examples, recents[] }

  function positionSheetMidRight() {
    if (!overlay) return;

    const shell = document.getElementById("luxWcShell");
    const r = shell?.getBoundingClientRect?.();

    // fallback: center in viewport
    const y = r ? r.top + r.height / 2 : window.innerHeight / 2;
    const clampedY = Math.max(18, Math.min(window.innerHeight - 18, y));

    overlay.style.position = "fixed";
    overlay.style.top = `${Math.round(clampedY)}px`;
    overlay.style.right = "18px";
    overlay.style.left = "auto";
    overlay.style.transform = "translateY(-50%)";
  }

  function ensureMounted() {
    if (overlay) return;

    overlay = document.createElement("div");
    overlay.className = "lux-wc-sheetOverlay";
    overlay.setAttribute("aria-hidden", "true");
    overlay.innerHTML = `
      <div class="lux-wc-sheetCard" role="dialog" aria-modal="true">
        <div class="lux-wc-sheetHead">
          <div class="lux-wc-sheetHeadMain">
            <div class="lux-wc-sheetTitle" id="luxWcSheetTitle">—</div>
            <div class="lux-wc-sheetMeta" id="luxWcSheetMeta">—</div>
          </div>

          <div class="lux-wc-sheetHeadBtns">
            <button class="lux-wc-iconBtn" data-act="fav" title="Favorite">⭐</button>
            <button class="lux-wc-iconBtn" data-act="pin" title="Pin">📌</button>
            <button class="lux-wc-iconBtn" data-act="close" title="Close">✕</button>
          </div>
        </div>

        <div class="lux-wc-sheetBody">
          <div class="lux-wc-sheetPrimary">
            <button class="lux-pbtn lux-wc-primaryBtn" data-act="generate">
              ✨ Generate my next practice
            </button>
            <div class="lux-wc-primaryHint" id="luxWcPrimaryHint">
              Uses your selection as the focus target inside an AI conversation.
            </div>
          </div>

          <div class="lux-wc-sheetGrid">
            <div class="lux-wc-miniStat">
              <div class="lux-wc-miniLabel">Avg</div>
              <div class="lux-wc-miniVal" id="luxWcStatAvg">—</div>
            </div>
            <div class="lux-wc-miniStat">
              <div class="lux-wc-miniLabel">Seen</div>
              <div class="lux-wc-miniVal" id="luxWcStatSeen">—</div>
            </div>
            <div class="lux-wc-miniStat">
              <div class="lux-wc-miniLabel">Level</div>
              <div class="lux-wc-miniVal" id="luxWcStatLevel">—</div>
            </div>
          </div>

          <div class="lux-wc-sec" id="luxWcExamplesBlock" style="display:none;">
            <div class="lux-wc-secTitle">Examples</div>
            <div class="lux-wc-chipRow" id="luxWcExamplesRow"></div>
          </div>

          <div class="lux-wc-sec" id="luxWcRecentsBlock">
            <div class="lux-wc-secTitle">Recent attempts</div>
            <div class="lux-wc-recents" id="luxWcRecentsList"></div>
          </div>

          <details class="lux-wc-details">
            <summary>Details</summary>
            <div class="lux-wc-detailsInner" id="luxWcDetailsInner"></div>
          </details>
        </div>
      </div>
    `;

    document.body.appendChild(overlay);
    sheet = overlay.querySelector(".lux-wc-sheetCard");

    // close when clicking dark overlay (not inside card)
    overlay.addEventListener("click", (e) => {
      if (e.target === overlay) close();
    });

    // esc closes
    window.addEventListener("keydown", (e) => {
      if (e.key === "Escape" && overlay?.getAttribute("aria-hidden") === "false")
        close();
    });

    const reflow = () => {
      if (overlay?.classList.contains("is-open")) positionSheetMidRight();
    };

    window.addEventListener("resize", reflow);
    window.addEventListener("scroll", reflow, { passive: true });

    overlay.addEventListener("click", (e) => {
      const btn = e.target?.closest?.("[data-act]");
      if (!btn) return;

      const act = btn.getAttribute("data-act");
      if (act === "close") close();

      if (!state) return;

      if (act === "generate") {
        onGenerate?.(state);
      }

      if (act === "fav") {
        const isNowFav = toggleItem(state.kind, state.id, FAV_KEY);
        btn.classList.toggle("is-on", isNowFav);
        onStoreChange?.();
      }

      if (act === "pin") {
        const isNowPinned = toggleItem(state.kind, state.id, PIN_KEY);
        btn.classList.toggle("is-on", isNowPinned);
        onStoreChange?.();
      }
    });

    overlay.addEventListener("click", (e) => {
      const row = e.target?.closest?.("[data-open-attempt]");
      if (!row) return;
      const idx = Number(row.getAttribute("data-open-attempt") || -1);
      const rec = state?.recents?.[idx];
      if (!rec?.attempt) return;
      onOpenAttempt?.(rec.attempt);
    });
  }

  function open(nextState) {
    ensureMounted();
    state = nextState || null;
    if (!state) return;

    // ✅ Position the sheet next to the Word Cloud, centered vertically
    positionSheetMidRight();

    // ✅ Match night mode if active on the shell
    const shell = document.getElementById("luxWcShell");
    overlay.classList.toggle(
      "lux-wc--night",
      !!shell?.classList.contains("lux-wc--night")
    );

    const col = getColorConfig(state.avg || 0);
    const titleEl = overlay.querySelector("#luxWcSheetTitle");
    const metaEl = overlay.querySelector("#luxWcSheetMeta");

    titleEl.textContent = state.title || state.id || "—";
    metaEl.innerHTML = `
      <span class="lux-wc-pillTag" style="background:${col.bg}; color:${col.color}">
        ${esc(labelFor(state.avg))}
      </span>
      <span class="lux-wc-sheetMetaSep">·</span>
      <span>${safePct(state.avg)}</span>
      <span class="lux-wc-sheetMetaSep">·</span>
      <span>seen ${Number(state.count || 0)}×</span>
    `;

    overlay.querySelector("#luxWcStatAvg").textContent = safePct(state.avg);
    overlay.querySelector("#luxWcStatSeen").textContent = `${Number(
      state.count || 0
    )}×`;
    overlay.querySelector("#luxWcStatLevel").textContent = labelFor(state.avg);

    // Fav/pin button state
    const fav = readStore(FAV_KEY);
    const pin = readStore(PIN_KEY);

    overlay
      .querySelector('[data-act="fav"]')
      ?.classList.toggle("is-on", hasItem(state.kind, state.id, fav));
    overlay
      .querySelector('[data-act="pin"]')
      ?.classList.toggle("is-on", hasItem(state.kind, state.id, pin));

    // Examples (phonemes only)
    const exBlock = overlay.querySelector("#luxWcExamplesBlock");
    const exRow = overlay.querySelector("#luxWcExamplesRow");

    const examples = Array.isArray(state.examples) ? state.examples : [];
    if (examples.length) {
      exBlock.style.display = "";
      exRow.innerHTML = examples
        .slice(0, 6)
        .map((t) => `<span class="lux-wc-chip">${esc(t)}</span>`)
        .join("");
    } else {
      exBlock.style.display = "none";
      exRow.innerHTML = "";
    }

    // Recents list
    const recList = overlay.querySelector("#luxWcRecentsList");
    const recents = Array.isArray(state.recents) ? state.recents : [];
    if (!recents.length) {
      recList.innerHTML = `<div class="lux-wc-empty">No recent attempts found for this item yet.</div>`;
    } else {
      recList.innerHTML = recents
        .slice(0, 6)
        .map(
          (r, i) => `
          <button class="lux-wc-recentRow" data-open-attempt="${i}">
            <div class="lux-wc-recentTop">
              <span class="lux-wc-recentTitle">${esc(r.title || "Attempt")}</span>
              <span class="lux-wc-recentScore">${safePct(r.score)}</span>
            </div>
            <div class="lux-wc-recentSub">${esc(r.when || "")}</div>
          </button>
        `
        )
        .join("");
    }

    // Details
    const det = overlay.querySelector("#luxWcDetailsInner");
    det.innerHTML = `
      <div class="lux-wc-kv"><b>Kind:</b> ${esc(state.kind)}</div>
      <div class="lux-wc-kv"><b>ID:</b> ${esc(state.id)}</div>
      ${
        state.days != null
          ? `<div class="lux-wc-kv"><b>Days seen:</b> ${esc(state.days)}</div>`
          : ``
      }
      ${
        state.priority != null
          ? `<div class="lux-wc-kv"><b>Priority:</b> ${esc(state.priority)}</div>`
          : ``
      }
    `;

    overlay.setAttribute("aria-hidden", "false");
    overlay.classList.add("is-open");
  }

  function close() {
    if (!overlay) return;
    overlay.setAttribute("aria-hidden", "true");
    overlay.classList.remove("is-open");
    state = null;
  }

  return { open, close };
}
</file>

<file path="features/recorder/audio-mode.js">
// features/recorder/audio-mode.js
// Normal vs Pro recording constraints for Lux

const MODE_KEY = "luxAudioMode";

export const AUDIO_MODES = {
  NORMAL: "normal",
  PRO: "pro",
};

export function getAudioMode() {
  const v = (localStorage.getItem(MODE_KEY) || "").toLowerCase();
  return v === "pro" ? "pro" : "normal";
}

export function setAudioMode(mode) {
  const m = String(mode || "").toLowerCase() === "pro" ? "pro" : "normal";
  localStorage.setItem(MODE_KEY, m);

  // ✅ drive CSS / UI state
  try {
    document.documentElement.setAttribute("data-lux-audio-mode", m);
  } catch {}

  // ✅ broadcast for any listeners (switch UI, inspector, etc)
  try {
    window.dispatchEvent(
      new CustomEvent("lux:audioModeChanged", { detail: { mode: m } })
    );
  } catch {}

  return m;
}

export function toggleAudioMode() {
  const next = getAudioMode() === "pro" ? "normal" : "pro";
  return setAudioMode(next);
}

export function initAudioModeDataset() {
  const m = getAudioMode();
  try {
    document.documentElement.setAttribute("data-lux-audio-mode", m);
  } catch {}
  return m;
}

function supportedConstraints() {
  try {
    return navigator.mediaDevices?.getSupportedConstraints?.() || {};
  } catch {
    return {};
  }
}

export function getAudioConstraints() {
  const mode = getAudioMode();
  const supported = supportedConstraints();

  // ✅ Force explicit settings so we can compare apples-to-apples
  const normal = {
    echoCancellation: true,
    noiseSuppression: true,
    autoGainControl: true,
    channelCount: 1,
    sampleRate: 48000,
    sampleSize: 16,
  };

  const pro = {
    echoCancellation: false,
    noiseSuppression: false,
    autoGainControl: false,
    channelCount: 1, // ✅ request mono even in Pro
    sampleRate: 48000,
    sampleSize: 16,
  };

  const want = mode === "pro" ? pro : normal;

  // Only include constraints browser supports
  const audio = {};
  for (const [k, v] of Object.entries(want)) {
    if (supported[k] === true) audio[k] = v;
  }

  // If none supported, fallback to just `true`
  return { audio: Object.keys(audio).length ? audio : true };
}

// Back-compat alias (some modules import buildAudioConstraints)
export function buildAudioConstraints() {
  return getAudioConstraints();
}
</file>

<file path="features/recorder/media.js">
// features/recorder/media.js
import { logError } from "../../app-core/lux-utils.js";
import AudioInspector from "./audio-inspector.js";
import { buildAudioConstraints } from "./audio-mode.js";

let mediaRecorder = null;
let recordedChunks = [];
let stopMeterFn = null;

function clamp(n, lo, hi) {
  return Math.max(lo, Math.min(hi, n));
}

function startLevelMeter(stream, onMeter, bars = 10) {
  const AudioCtx = window.AudioContext || window.webkitAudioContext;
  if (!AudioCtx) return () => {};

  let rafId = null;
  let alive = true;

  const ctx = new AudioCtx();
  const analyser = ctx.createAnalyser();
  analyser.fftSize = 256;
  analyser.smoothingTimeConstant = 0.85;

  const source = ctx.createMediaStreamSource(stream);
  source.connect(analyser);

  const freqData = new Uint8Array(analyser.frequencyBinCount);

  // kick it on (some browsers start suspended until a gesture)
  ctx.resume?.().catch?.(() => {});

  const tick = () => {
    if (!alive) return;
    analyser.getByteFrequencyData(freqData);

    const levels = [];
    const startBin = 2;
    const endBin = Math.min(freqData.length, 64);
    const span = Math.max(1, endBin - startBin);
    const step = span / bars;

    for (let i = 0; i < bars; i++) {
      const a = Math.floor(startBin + i * step);
      const b = Math.floor(startBin + (i + 1) * step);
      let sum = 0;
      let count = 0;

      for (let k = a; k < Math.max(a + 1, b); k++) {
        sum += freqData[k] || 0;
        count++;
      }

      const avg = sum / Math.max(1, count); // 0..255
      // normalize + compress so quiet speech still shows movement
      let v = (avg / 255) * 1.9;
      v = Math.pow(v, 0.65);
      levels.push(clamp(v, 0.08, 1));
    }

    try {
      onMeter(levels);
    } catch (_) {}

    rafId = requestAnimationFrame(tick);
  };

  tick();

  return () => {
    alive = false;
    if (rafId) cancelAnimationFrame(rafId);
    try {
      ctx.close();
    } catch (_) {}
  };
}

export async function startMic(onStopCallback, { onMeter } = {}) {
  try {
    const stream = await navigator.mediaDevices.getUserMedia(buildAudioConstraints());

    // ✅ Inspector: note stream immediately (practice context)
    await AudioInspector.noteStream(stream, "practice");

    const prefer = ["audio/webm;codecs=opus", "audio/webm"];
    let opts = {};
    try {
      for (const t of prefer) {
        if (window.MediaRecorder?.isTypeSupported?.(t)) {
          opts.mimeType = t;
          break;
        }
      }
    } catch {}
    mediaRecorder = new MediaRecorder(stream, opts);

    // ✅ Inspector: note recorder right after creation
    AudioInspector.noteRecorder(mediaRecorder);

    recordedChunks = [];

    // Optional: live mic level meter (for record-button equalizer bars)
    if (typeof onMeter === "function") {
      if (stopMeterFn) {
        stopMeterFn();
        stopMeterFn = null;
      }
      stopMeterFn = startLevelMeter(stream, onMeter, 10);
    }

    mediaRecorder.ondataavailable = (e) => {
      if (e.data.size > 0) recordedChunks.push(e.data);
    };

    mediaRecorder.onstop = () => {
      if (stopMeterFn) {
        stopMeterFn();
        stopMeterFn = null;
      }

      stream.getTracks().forEach((t) => t.stop());

      const blob = new Blob(recordedChunks, { type: "audio/webm" });

      // ✅ Inspector: note final blob right after creation
      AudioInspector.noteBlob(blob);

      if (onStopCallback) onStopCallback(blob);
    };

    mediaRecorder.start();
    return true;
  } catch (err) {
    logError("Mic access failed", err);
    return false;
  }
}

export function stopMic() {
  if (mediaRecorder && mediaRecorder.state === "recording") {
    if (stopMeterFn) {
      stopMeterFn();
      stopMeterFn = null;
    }
    mediaRecorder.stop();
  }
}
</file>

<file path="features/results/header.js">
/* ============================================================================
   CANONICAL SHIM — HEADER SHELL + POST-DOM WIRING
   ---------------------------------------------------------------------------
   - Canonical results renderer: ui/views/index.js (lux-results-root)
   - This file is ACTIVE in the modern trunk.
   - It still supports legacy globals *only as fallback*.
   - Phase-E move here: stop relying on hooks shim from deps.js.
============================================================================ */
// ui/views/header.js

// Modern ES-module header builder (canonical scoring)
import { renderResultsHeaderModern } from "./header-modern.js";

// Direct ES-module interaction boots (idempotent in their own modules)
import { setupYGHover } from "../interactions/yg-hover.js";
import { setupPhonemeHover } from "../interactions/ph-hover.js";
import { initPhonemeAudio } from "../interactions/ph-audio.js";
import { initScoreErrorCollapse } from "../interactions/score-collapse.js";
import { animateMetricTips } from "../interactions/tips.js";
import { initProsodyLegendToggle } from "../interactions/legend-toggle.js";
import { initProsodyTooltips } from "../../prosody/prosody-help-bars.js";
import { initMetricScoreModals, setMetricModalData } from "../interactions/metric-modal.js";

// Helpers: call a global hook if it exists (kept for shims / parked features)
function callGlobal(name, ...args) {
  const fn = globalThis?.[name];
  if (typeof fn === "function") return fn(...args);
}

export function ensureHeader(data) {
  const G = globalThis;
  const $out = document.getElementById("prettyResult");
  if (!$out) return;

  // If the header/table already exists, just (re)fill slots and attach light UX.
  if (document.getElementById("resultBody")) {
    callGlobal("fillProsodyAndContentSlots", data);
    setTimeout(() => animateMetricTips?.(), 0);
    initProsodyLegendToggle?.();
    initProsodyTooltips?.();

    const refEl = document.getElementById("referenceText");
    const referenceText =
      (refEl && "value" in refEl ? refEl.value : refEl?.textContent) || "";
    setMetricModalData?.({ azureResult: data, referenceText });

    initMetricScoreModals?.();
    return;
  }

  let html = null;

  // 1) Preferred: modern ES-module header builder (canonical scoring)
  try {
    if (typeof renderResultsHeaderModern === "function") {
      html = renderResultsHeaderModern(data);
    }
  } catch (e) {
    console.warn("[views/header] modern header failed, falling back:", e);
  }

  // 2) Fallback: legacy global header renderer (if still present)
  if (!html && typeof G.renderResultsHeader === "function") {
    try {
      html = G.renderResultsHeader(data);
    } catch (e) {
      console.warn("[views/header] legacy renderResultsHeader failed:", e);
    }
  }

  // 3) Final fallback: inline minimal header markup
  if (!html) {
    html = `
      <div id="resultHeader"></div>
      <table class="score-table collapsed-score collapsed-error">
        <thead>
          <tr>
            <th id="wordHeader">
              <span class="word-chip clickable">Word</span>
            </th>

            <th id="syllableHeader">
              <span class="word-chip syllable-chip">Syllable</span>
            </th>

            <th id="scoreHeader" class="toggle-col">
              Score ▸
            </th>
            <th id="errorHeader" class="toggle-col">
              Error ▸
            </th>
            <th id="phonemeHeader">
              <span
                class="word-chip phoneme-chip clickable"
                id="phonemeTitle"
              >
                Phoneme
              </span>
            </th>
          </tr>
        </thead>
        <tbody id="resultBody"></tbody>
      </table>
    `;
  }

  $out.insertAdjacentHTML("afterbegin", html);

  const refEl = document.getElementById("referenceText");
  const referenceText =
    (refEl && "value" in refEl ? refEl.value : refEl?.textContent) || "";
  setMetricModalData?.({ azureResult: data, referenceText });
  initMetricScoreModals?.();

  // Header slots + light UX (import-first; global fallback)
  callGlobal("fillProsodyAndContentSlots", data);
  setTimeout(() => animateMetricTips?.(), 0);
  initProsodyLegendToggle?.();
}

export function wirePostDom(data) {
  try {
    // Slots and tips
    callGlobal("fillProsodyAndContentSlots", data);

    // Canonical interaction boots
    setupYGHover?.();
    setupPhonemeHover?.();
    initPhonemeAudio?.();
    initScoreErrorCollapse?.();
    animateMetricTips?.();
    initProsodyLegendToggle?.();
    initProsodyTooltips?.();

    const refEl = document.getElementById("referenceText");
    const referenceText =
      (refEl && "value" in refEl ? refEl.value : refEl?.textContent) || "";
    setMetricModalData?.({ azureResult: data, referenceText });

    initMetricScoreModals?.();

    // Parked / optional features remain global-only for now
    callGlobal("initPhonemeClickPlay");
    callGlobal("initProsodyBarsUX");
  } catch (e) {
    console.warn("[views] post-DOM wiring error:", e);
  }
}
</file>

<file path="lux-layout.css">
/* lux-layout.css */
@import "./lux-layout.tokens.css";
@import "./lux-layout.core.css";
@import "./lux-layout.harvard.css";
@import "./lux-layout.nav-cta.css";
@import "./lux-layout.messaging.css";
@import "./lux-layout.interactions.css";
@import "./lux-layout.ai-feedback.css";
@import "./lux-layout.scrollbar.css";
@import "./lux-layout.top-banner.css";
/* ✅ My Words overlay */
@import "./features/my-words/my-words.css";
</file>

<file path="lux-results.legacy.css">
/* lux-results.legacy.css */
/* Old AI panel styles (legacy support) */

/* ============================================================
   OLD AI Panel Styles (Legacy support)
   ============================================================ */
/* We target :not(.ai-grid-container) to avoid conflicts */
#aiFeedback:not(.ai-grid-container) {
  background: #eef7fe; padding: 1.1em 1em; border: 1px solid #c9e2ff; border-radius: 1em;
  margin-top: 12px;
  font-size: 1.14em; line-height: 1.68; color: #223; box-shadow: 0 2px 16px rgba(60, 90, 155, 0.06);
}
#aiFeedback h2, #aiFeedback h3, #aiFeedback strong {
  color: #096; display: block; margin-top: 0.7em; margin-bottom: 0.25em; font-size: 1.1em;
  position: relative; overflow: hidden;
}
#aiFeedback h2::after, #aiFeedback h3::after, #aiFeedback strong::after {
  content: ""; position: absolute; bottom: 0; left: 0; height: 2px; width: 100%;
  background: currentColor; transform: scaleX(0); transform-origin: left; transition: transform 1.5s ease;
}
.underline-start::after { transform: scaleX(1); }

#aiFeedback ul { margin: 0.2em 0 1em 1.5em; padding: 0; list-style: disc inside; }
#aiFeedback li { margin: 0.14em 0; }
#aiFeedback em { color: #296aac; }

.ai-progress {
  position: relative; height: 4px; margin-top: 8px; background: #cfe5ff; overflow: hidden; border-radius: 2px;
}
.ai-progress::before {
  content: ""; position: absolute; inset: 0; width: 40%;
  background: linear-gradient(90deg, #0078d7 0%, #44a8ff 50%, #0078d7 100%);
  animation: aiLoad 1.2s linear infinite;
}
@keyframes aiLoad {
  from { left: -40%; }
  to { left: 100%; }
}

.toggle-en-btn {
  margin: 0.5em 0; padding: 0.35em 1em; font-size: 0.97em; cursor: pointer;
  background: #f6f6f6; border: 1px solid #ddd; border-radius: 6px; font-weight: 600; color: #222;
  transition: background 0.18s;
}
.toggle-en-btn:hover { background: #e0e0e0; }

/* Keep the result container permissive for hover/popovers */
#prettyResult {
  overflow-x: auto;
  overflow-y: visible !important;
  overflow: visible !important;
  max-height: none !important;
  height: auto !important;
  padding-bottom: 4px;
}
</file>

<file path="lux-results.table.css">
/* lux-results.table.css */
/* Word/Phoneme results table + column collapse + hover + previews */

/* ============================================================
   Collapsible Score & Error columns
   ============================================================ */
#prettyResult table { transition: width 0.35s ease; }

#scoreHeader, #errorHeader {
  width: 34px;
  text-align: center;
  position: relative;
  cursor: pointer;
  user-select: none;
}

.toggle-col { cursor: pointer; user-select: none; transition: color 0.2s; }
.toggle-col:hover { color: #0078d7; }
.toggle-col::after { content: "▸"; display: inline-block; transition: transform 0.35s ease; }

table:not(.collapsed-score) #scoreHeader::after,
table:not(.collapsed-error) #errorHeader::after { transform: rotate(90deg); }
table:not(.collapsed-score) th#scoreHeader::after,
table:not(.collapsed-error) th#errorHeader::after { content: "◂"; }

/* Collapsed States: keep ONLY the headers as the skinny clickable handles */
#prettyResult table.collapsed-score th#scoreHeader,
#prettyResult table.collapsed-error th#errorHeader {
  width: 26px !important;
  min-width: 26px !important;
  max-width: 26px !important;
  padding-left: 0 !important;
  padding-right: 0 !important;
  opacity: 0.2;
  pointer-events: auto !important;
  cursor: pointer;

  /* critical: stop the “S C O R E” vertical stacking */
  white-space: nowrap !important;
  overflow: hidden !important;
  text-overflow: clip !important;
}

/* ============================================================
   Score + Error collapse (CLASS-BASED = robust after new columns)
   ============================================================ */

/* Prevent that “vertical letter stacking” look */
#prettyResult td.score-cell,
#prettyResult td.error-cell,
#prettyResult th#scoreHeader,
#prettyResult th#errorHeader{
  white-space: nowrap !important;
}

/* COLLAPSED: hide the body cells */
#prettyResult table.collapsed-score td.score-cell,
#prettyResult table.collapsed-error td.error-cell{
  width: 0 !important;
  min-width: 0 !important;
  max-width: 0 !important;
  padding: 0 !important;
  opacity: 0 !important;
  pointer-events: none !important;
  font-size: 0 !important;
  border-left: none;
  border-right: none;
}

/* OPEN: restore the body cells */
#prettyResult table:not(.collapsed-score) td.score-cell,
#prettyResult table:not(.collapsed-score) th#scoreHeader{
  width: 110px !important;
  min-width: 85px !important;
  max-width: 140px !important;
  padding: 10px !important;
  opacity: 1 !important;
  font-size: 1em !important;
}

#prettyResult table:not(.collapsed-error) td.error-cell,
#prettyResult table:not(.collapsed-error) th#errorHeader{
  width: 170px !important;
  min-width: 140px !important;
  max-width: 220px !important;
  padding: 10px !important;
  opacity: 1 !important;
  font-size: 1em !important;
}

#prettyResult .score-table td.score-cell,
#prettyResult .score-table td.error-cell { cursor: pointer; }

/* ============================================================
   Collapsible Word & Phoneme columns (NEW)
   - Triggered ONLY by the dedicated header buttons (.lux-col-toggle)
   - Does not change Score/Error collapse behavior
   ============================================================ */

#prettyResult .lux-col-toggle {
  position: absolute;
  top: 6px;
  right: 6px;
  width: 18px;
  height: 18px;
  border-radius: 4px;
  border: 1px solid #cbd5e1;
  background: #fff;
  color: #334155;
  font-size: 12px;
  line-height: 1;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  padding: 0;
  z-index: 6; /* above chips/tooltips */
  user-select: none;

  /* base transform so rotation doesn’t fight other rules */
  transform: rotate(0deg);
}

#prettyResult .lux-col-toggle:hover { background: #e2e8f0; }
#prettyResult .lux-col-toggle:focus-visible { outline: 2px solid #1976d2; outline-offset: 2px; }

/* Optional “direction” cue: rotate when expanded */
#prettyResult table:not(.collapsed-word) th#wordHeader .lux-col-toggle[data-col="word"],
#prettyResult table:not(.collapsed-phoneme) th#phonemeHeader .lux-col-toggle[data-col="phoneme"] {
  transform: rotate(180deg);
}

/* Collapsed header width (keep thin so button remains clickable) */
#prettyResult table.collapsed-word th#wordHeader,
#prettyResult table.collapsed-phoneme th#phonemeHeader {
  width: 30px !important;
  min-width: 30px !important;
  max-width: 30px !important;
  padding-left: 0 !important;
  padding-right: 0 !important;
}

/* Collapse the body cells */
#prettyResult table.collapsed-word td:nth-child(1),
#prettyResult table.collapsed-phoneme td:nth-child(5) {
  width: 0 !important;
  min-width: 0 !important;
  max-width: 0 !important;
  padding-left: 0 !important;
  padding-right: 0 !important;
  overflow: hidden !important;
  opacity: 0.15;
  pointer-events: none;
}

/* Hide header content when collapsed (leave the button visible) */
#prettyResult table.collapsed-word th#wordHeader .word-chip { display: none !important; }

#prettyResult table.collapsed-phoneme th#phonemeHeader .phoneme-chip,
#prettyResult table.collapsed-phoneme th#phonemeHeader .tooltip { display: none !important; }


/* ============================================================
   Header cells and pills (Word / Phoneme)
   ============================================================ */
.lux-col-toggle {
  position: absolute;
  top: 6px;
  width: 18px;
  height: 18px;
  border-radius: 4px;
  border: 1px solid #cbd5e1;
  background: #e2e8f0;
  color: #475569;
  font-size: 12px;
  line-height: 1;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  padding: 0;
  z-index: 2;
  transition: transform 0.3s ease, background 0.15s ease;
}
.lux-col-toggle:hover { background: #d8e2ef; }
.lux-col-toggle:focus-visible { outline: 2px solid #1976d2; outline-offset: 2px; }

#prettyResult th#wordHeader .lux-col-toggle { left: 6px; right: auto; }

/* Phoneme open: on exterior RIGHT but points inward (rotate 180) */
#prettyResult th#phonemeHeader .lux-col-toggle { right: 6px; left: auto; transform: rotate(180deg); }

/* Word collapsed: move to interior RIGHT edge and point outward (rotate 180) */
#prettyResult table.collapsed-word th#wordHeader .lux-col-toggle {
  right: 6px;
  left: auto;
  transform: rotate(180deg);
}

/* Phoneme collapsed: move to interior LEFT edge and point outward (no rotate) */
#prettyResult table.collapsed-phoneme th#phonemeHeader .lux-col-toggle {
  left: 6px;
  right: auto;
  transform: rotate(0deg);
}

/* SAFE TABLE VERSION: keep headers as proper table-cells */
#wordHeader, #syllableHeader, #phonemeHeader{
  background: #f3f7fa;
  border: 1px solid #bbb;
  padding: 18px 0;
  position: relative;
  overflow: visible !important;
  z-index: 5;

  /* IMPORTANT: keep table-cell behavior */
  text-align: center;
  vertical-align: middle;
}

#prettyResult .score-table th {
  color: #223; text-align: center; font-weight: 700; vertical-align: middle;
  font-size: 1.14em; padding: 14px 0 12px 0;
  transition: background 0.16s, box-shadow 0.18s, transform 0.14s;
}

/* ============================================================
   Syllable column (expected stress glow)
   ============================================================ */

#syllableHeader{
  background: #f3f7fa;
  border: 1px solid #bbb;
  padding: 18px 0;
  position: relative;
  overflow: visible !important;
  z-index: 5;

  text-align: center;
  vertical-align: middle;
}

.word-chip.syllable-chip{
  background: #eef7fb;
  color: #205080;
  box-shadow: 0 2px 8px rgba(40, 120, 255, 0.13);
}

/* Column sizing */
#prettyResult th#syllableHeader,
#prettyResult td.syllable-cell{
  width: 240px;
  min-width: 170px;
  max-width: 340px;
}

/* Bracketed syllable chips */
#prettyResult .lux-sylStrip{
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  align-items: center;
  gap: 6px;
}

#prettyResult .lux-syl{
  position: relative;
  display: inline-flex;
  align-items: center;
  justify-content: center;

  font-weight: 900;
  font-size: 0.95em;
  padding: 3px 8px;
  border-radius: 999px;

  background: rgba(15, 23, 42, 0.05);
  color: #0f172a;
}

#prettyResult .lux-syl::before{
  content: "[";
  opacity: 0.55;
  margin-right: 2px;
}

#prettyResult .lux-syl::after{
  content: "]";
  opacity: 0.55;
  margin-left: 2px;
}

/* Expected-stress glow */
#prettyResult .lux-syl.is-stress{
  background: rgba(245, 158, 11, 0.20);
  box-shadow:
    0 0 0 1px rgba(245, 158, 11, 0.60),
    0 10px 26px rgba(245, 158, 11, 0.18);
}

/* Clickable Header Backgrounds */
#wordHeader.clickable { cursor: pointer; box-shadow: 0 1.5px 5px rgba(40, 120, 255, 0.08); position: relative; z-index: 1; }
#wordHeader.clickable:hover,
#wordHeader.clickable:focus {
  background: #e0f2fd; color: #1662b0;
  box-shadow: 0 5px 24px rgba(20, 90, 220, 0.14), 0 1.5px 5px rgba(40, 120, 255, 0.08);
  transform: scale(1.05);
}

#wordHeader .word-chip:focus-visible { outline: 2.5px solid #1976d2; outline-offset: 2px; }
#wordHeader .word-chip { display: inline-block; }

/* Stop scaling the whole tooltip box on header hover */
#prettyResult th#wordHeader:hover,
#prettyResult th#phonemeHeader:hover { transform: none !important; filter: none !important; }

/* Tooltip phoneme chip: match header-pill contract (lift+shadow hover, press active) */
#prettyResult .tooltip .phoneme-chip {
  display: inline-block;
  transition: transform 0.18s ease, box-shadow 0.18s ease;
}
#prettyResult .tooltip:hover .phoneme-chip {
  transform: translateY(-2px);
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.28);
}
#prettyResult .tooltip:active .phoneme-chip {
  transform: translateY(0);
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
}

/* Row phoneme chips: match header-pill contract (NO scale/brightness) */
#prettyResult tbody .phoneme-chip[data-hydrated],
#resultBody .phoneme-chip[data-hydrated] {
  display: inline-block;
  transition: transform 0.18s ease, box-shadow 0.18s ease;
}
#prettyResult tbody .phoneme-chip[data-hydrated]:hover,
#resultBody .phoneme-chip[data-hydrated]:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.28);
}
#prettyResult tbody .phoneme-chip[data-hydrated]:active,
#resultBody .phoneme-chip[data-hydrated]:active {
  transform: translateY(0);
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
}

/* Row word pills: lift + shadow only (NO darken) */
#prettyResult tbody a {
  transition: transform 140ms ease, box-shadow 140ms ease;
}
#prettyResult tbody a:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.28);
}
#prettyResult tbody a:active {
  transform: translateY(0);
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.20);
}

/* ============================================================
   Previews & Popovers
   ============================================================ */
#ygPreview, #phPreview {
  position: fixed; width: 560px; height: 390px; display: none; z-index: 9999;
  border: 1px solid #ccc; border-radius: 6px; background: #000;
  box-shadow: 0 4px 14px rgba(0, 0, 0, 0.25); overflow: hidden;
}
#phPreview > video {
  width: 100% !important; height: 100% !important; object-fit: contain !important;
  background: #000; transform: scale(0.96); transform-origin: center center;
}

.word-chip.phoneme-chip {
  display: inline-flex !important; align-items: center; gap: 4px;
  white-space: nowrap; overflow: visible !important; min-width: 0; padding: 4px 12px;
}
#phonemeHeader { max-width: none; min-width: 150px; }

/* ============================================================
   UNIFIED "GHOST EMOJI" LOGIC (Word + Phoneme)
   ============================================================ */

#wordHeader .word-chip,
#phonemeHeader .phoneme-chip {
  position: relative !important;
}

/* Collapsible Word/Phoneme columns */
#prettyResult table.collapsed-word th#wordHeader,
#prettyResult table.collapsed-phoneme th#phonemeHeader {
  width: 30px !important; min-width: 30px !important; max-width: 30px !important;
  padding-left: 0 !important; padding-right: 0 !important;
  transform: none !important;
}
#prettyResult table.collapsed-word td:nth-child(1),
#prettyResult table.collapsed-phoneme td:nth-child(5) {
  width: 0 !important; min-width: 0 !important; max-width: 0 !important;
  padding: 0 !important;
  overflow: hidden; opacity: 0.15; pointer-events: none;
  transform: none !important;
}
#prettyResult table.collapsed-word #wordHeader .word-chip,
#prettyResult table.collapsed-phoneme #phonemeHeader .phoneme-chip,
#prettyResult table.collapsed-phoneme #phonemeHeader .tooltip {
  display: none;
}

#wordHeader > .audio-hint,
#phonemeHeader .audio-hint {
  display: none !important;
}

#wordHeader .word-chip::after,
#phonemeHeader .phoneme-chip::after {
  content: "🔊";
  position: absolute;
  left: 50%;
  top: -14px;
  transform: translateX(-50%) scale(1);
  font-size: 1.1em;
  color: #205080;
  opacity: 0; /* Hidden by default */
  pointer-events: none;
  transition: opacity 0.18s, transform 0.25s;
}

#wordHeader .word-chip:hover::after,
#wordHeader .word-chip:focus-visible::after,
#phonemeHeader .phoneme-chip:hover::after,
#phonemeHeader .phoneme-chip:focus-visible::after {
  opacity: 1;
  animation:
    wordAudioNudge 0.7s ease-in-out 1,
    wordAudioPulse 1.2s ease-in-out 0.7s infinite alternate;
}

#wordHeader .word-chip.is-playing::after,
#phonemeHeader .phoneme-chip.is-playing::after {
  opacity: 1;
  filter: drop-shadow(0 0 2px #ffd54f) brightness(1.3);
  animation: wordAudioPulse 1.2s ease-in-out 0s infinite alternate;
}

@keyframes wordAudioPulse {
  from { transform: translateX(-50%) scale(1); }
  to { transform: translateX(-50%) scale(1.17) translateY(-1px); }
}
@keyframes wordAudioNudge {
  0% { transform: translateX(-50%) scale(1) rotate(0deg); }
  25% { transform: translateX(-50%) scale(1.25) rotate(-10deg); }
  50% { transform: translateX(-50%) scale(1) rotate(0deg); }
  75% { transform: translateX(-50%) scale(1.2) rotate(8deg); }
  100% { transform: translateX(-50%) scale(1.05) rotate(0deg); }
}

/* Tooltip playing state: NO brightness/scale; pulse box-shadow only */
#prettyResult .tooltip.is-playing {
  animation: pulseGlow 1s ease-in-out infinite alternate;
}
@keyframes pulseGlow {
  from { box-shadow: 0 0 0 rgba(30, 144, 255, 0.0); }
  to   { box-shadow: 0 0 12px rgba(30, 144, 255, 0.55); }
}
</file>

<file path="convo.html">
<!-- convo.html (AI Conversations) -->
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Lux — AI Conversations</title>

    <link rel="stylesheet" href="lux-layout.css" />
    <link rel="stylesheet" href="lux-results.css" />
    <link rel="stylesheet" href="lux-convo.css" />
    <link rel="stylesheet" href="lux-progress.css" />
    <link rel="stylesheet" href="lux-audio-mode.css" />


    <!-- ✅ TTS peekaboo only (overlay + core load lazily on open) -->
<link rel="stylesheet" href="/features/features/tts-peekaboo.css" />

    <!-- Wire warp nav (index ⇄ convo) -->
    <link rel="stylesheet" href="./ui/warp.css" />

    <!-- Match main page typography -->
    <link
      href="https://fonts.googleapis.com/css2?family=Montserrat:wght@700&display=swap"
      rel="stylesheet"
    />

    <style id="lux-tts-guard-style">
      #tts-controls {
        display: none !important;
      }
    </style>
  </head>

  <body>
    <audio id="playbackAudio" hidden></audio>
    <div id="tts-controls" data-luxHidden="1"></div>
    <div id="self-playback-drawer-target"></div>

    <!-- Match primary page layout structure -->
    <div id="container">
      <div id="convoApp"></div>

      <!-- AI Coach (collapsed on load; opens after first turn) -->
      <details id="aiCoachDrawer" class="lux-progress-drawer lux-ai-drawer">
        <summary class="lux-progress-drawer-summary">
          <div class="lux-progress-drawer-left">
            <div class="lux-progress-drawer-title">AI Coach</div>
            <div class="lux-progress-drawer-mini">Tap to open</div>
          </div>
        </summary>
        <div class="lux-progress-drawer-body">
          <div id="aiFeedbackSection">
            <div id="aiFeedback"></div>
          </div>
        </div>
      </details>
    </div>

    <script type="module" src="./src/convo.js"></script>

    <!-- Warp nav JS (near end of body) -->
    <script type="module" src="./ui/warp-nav.js"></script>
  </body>
</html>
</file>

<file path="features/progress/wordcloud/drawing-orchestrator.js">
/**
 * features/progress/wordcloud/drawing-orchestrator.js
 *
 * Commit 16: "The Drawing Orchestrator"
 * Encapsulates the draw coordination logic and dev logging wrappers.
 *
 * Owns:
 * - _renderSeq reference object
 * - waitTwoFrames()
 * - fmtDaysAgo()
 * - draw(forceFetch) function
 *
 * Must preserve:
 * - LOG B: "[wc] attempts in range: ..."
 * - LOG C: "[wc] items: ..."
 *
 * Exports:
 * - fmtDaysAgo(pos)
 * - createWordcloudDrawer({ ... }) -> { draw, reflow }
 */

import { drawWordcloud, renderWordcloudView } from "./render.js";
import { filterAttemptsByRange, idFromItem, lower } from "./compute.js";
import { computeItemsForView } from "./view-logic.js";

import { rangeLabel, sortLabel, mixLabel } from "./labels.js";

import { createWordcloudSheetController } from "./sheet-controller.js";

import {
  attemptOverallScore,
  attemptWhen,
  findRecentAttemptsForWord,
  findRecentAttemptsForPhoneme,
} from "./attempt-utils.js";

import { openDetailsModal } from "../attempt-detail-modal.js";

/**
 * Ensures the overlay becomes visible BEFORE heavy work starts
 */
export function waitTwoFrames() {
  return new Promise((resolve) => {
    requestAnimationFrame(() => requestAnimationFrame(resolve));
  });
}

/**
 * UI helper shared by multiple modules
 */
export function fmtDaysAgo(pos) {
  if (pos === 0) return "Now";
  return `${pos}d ago`;
}

/**
 * Factory that returns a draw() function.
 * It coordinates render.js with controllers (ui/data/strips) and preserves logs.
 */
export function createWordcloudDrawer({
  ctx,
  dom,
  ui,
  data,
  strips,

  attemptsAll,
  ensureWordCloudLibs,

  buildCloudPlan,
  saveNextActivityPlan,
  goToConvo,

  getState,
  topN = 40,
}) {
  if (!ctx) throw new Error("[wc/draw] ctx is required");
  if (!dom) throw new Error("[wc/draw] dom is required");
  if (!ui) throw new Error("[wc/draw] ui is required");
  if (!data) throw new Error("[wc/draw] data is required");
  if (!strips) throw new Error("[wc/draw] strips is required");

  if (!attemptsAll) throw new Error("[wc/draw] attemptsAll is required");
  if (typeof ensureWordCloudLibs !== "function")
    throw new Error("[wc/draw] ensureWordCloudLibs is required");
  if (typeof getState !== "function")
    throw new Error("[wc/draw] getState() is required");
  if (typeof buildCloudPlan !== "function")
    throw new Error("[wc/draw] buildCloudPlan is required");

  // Render sequencing guard (prevents old async layouts hiding new overlay)
  const _renderSeq = { value: 0 };

  // ✅ COMMIT 12C — sheet feature wiring stays within the draw orchestrator
  let sheetCtrl = null;

  // ✅ FIX 3 — timeline auto-heal (never start empty)
  let _timelineHealedOnce = false;

  async function draw(forceFetch = false) {
    const S = getState();

    // Wrap the two choke points so logs occur here (even though work is in render.js)

    const filterAttemptsByRangeLogged = (allAttempts, range, win, pos) => {
      // Reset heal flag anytime we’re not in timeline
      if (range !== "timeline") _timelineHealedOnce = false;

      let usedPos = pos;
      let attemptsInRange = filterAttemptsByRange(allAttempts, range, win, usedPos);

      // ✅ AUTO-HEAL: timeline can’t boot into an empty slice
      if (
        range === "timeline" &&
        Array.isArray(allAttempts) &&
        allAttempts.length &&
        attemptsInRange.length === 0 &&
        !_timelineHealedOnce
      ) {
        _timelineHealedOnce = true;

        usedPos = 0;
        try {
          ctx.set({ timelinePos: 0 });
        } catch (_) {}

        attemptsInRange = filterAttemptsByRange(allAttempts, range, win, 0);

        console.warn(
          "[wc] auto-heal: timeline slice empty → timelinePos reset to 0"
        );
      }

      // ✅ LOG B — right after range filter
      console.log(
        "[wc] attempts in range:",
        attemptsInRange?.length,
        "range=",
        range,
        "win=",
        win,
        "pos=",
        usedPos
      );

      return attemptsInRange;
    };

    const computeItemsForViewLogged = (attemptsInRange) => {
      const items = computeItemsForView({
        attemptsInRange,
        state: S,
        ctx,
        topN,
      });

      // ✅ LOG C — right after items computed
      console.log("[wc] items:", items?.length, "mode=", S.mode, "sort=", S.sort);

      return items;
    };

    // Init sheet controller once we have draw() closure available
    if (!sheetCtrl) {
      sheetCtrl = createWordcloudSheetController({
        ctx,
        attemptsAll,
        getState: () => getState(),
        strips,
        requestDraw: () => draw(false),

        // ✅ COMMIT 12D — plan build extracted
        buildCloudPlan: (state) => buildCloudPlan(ctx.refs.lastModel, state),

        saveNextActivityPlan,
        goToConvo,

        openDetailsModal,
        attemptOverallScore,
        attemptWhen,

        findRecentAttemptsForWord,
        findRecentAttemptsForPhoneme,

        filterAttemptsByRange,
        idFromItem,
        lower,
      });
    }

    await drawWordcloud({
      forceFetch,

      renderSeqRef: _renderSeq,

      setBusy: ui.setBusy,
      waitTwoFrames,

      metaEl: dom.meta,
      canvas: dom.canvas,

      mode: S.mode,
      range: S.range,
      timelineWin: S.timelineWin,
      timelinePos: S.timelinePos,
      query: S.query,
      sort: S.sort,
      mix: S.mix,
      clusterMode: S.clusterMode,

      attemptsAll,
      ensureWordCloudLibs,

      // ✅ COMMIT 15 — data loader supplies ensureData
      ensureData: data.ensureData,

      // ✅ pass wrappers (preserves dev logs)
      filterAttemptsByRange: filterAttemptsByRangeLogged,
      computeItemsForView: computeItemsForViewLogged,

      renderSavedStrip: strips.renderSavedStrip,
      renderTargetsStrip: strips.renderTargetsStrip,
      pinnedSet: strips.pinnedSetNow(),

      lower,
      rangeLabel,
      sortLabel,
      mixLabel,
      fmtDaysAgo,

      // ✅ context owns persistence+url now (keep keys identical)
      persist: () => ctx.persist(),
      syncUrl: () => ctx.syncUrl(),

      setActiveButtons: ui.setActiveButtons,
      setModeStory: ui.setModeStory,

      setLastItems: (items) => {
        ctx.setLastItems(items || []);
      },

      // ✅ COMMIT 12C — sheet controller owns hit-open behavior
      onSelect: (hit) => sheetCtrl?.openFromHit?.(hit),
    });
  }

  // ✅ FIX 2: True "reflow only" method (no recompute / no reshuffle)
  function reflow() {
    const items = ctx?.refs?.lastItems || [];
    if (!dom?.canvas || !items.length) return;

    const S = getState();
    const q = (S.query || "").trim().toLowerCase();

    const focusTest = q
      ? (idLower) => String(idLower || "").toLowerCase().includes(q)
      : null;

    // ✅ Repaint using cached layout (no reshuffle)
    renderWordcloudView({
      canvas: dom.canvas,
      items,
      focusTest,
      clusterMode: !!S.clusterMode,
      pinnedSet: strips.pinnedSetNow?.() || new Set(),
      onSelect: (hit) => sheetCtrl?.openFromHit?.(hit),
      onRenderEnd: () => {},
      reuseLayoutOnly: true,
    });
  }

  return {
    draw,
    reflow,
    renderSeqRef: _renderSeq, // exposed for debugging if needed
  };
}
</file>

<file path="features/progress/wordcloud/side-drawers.js">
// features/progress/wordcloud/side-drawers.js
// ✅ Drawer wiring (safe localStorage + NO redraw/reload on toggle)

const KEY = "lux_wc_drawers_v1";

function safeParse(json, fallback) {
  try {
    const v = JSON.parse(json);
    if (!v || typeof v !== "object") return fallback;
    return v;
  } catch {
    return fallback;
  }
}

function updateTabIcon(el, side, open) {
  const tab = el.querySelector("[data-wc-drawer-toggle]");
  if (!tab) return;

  // Arrow shows the direction it will MOVE when clicked
  // left open → will move right (collapse) → ▶
  // left closed → will move left (expand) → ◀
  if (side === "left") tab.textContent = open ? "▶" : "◀";
  else tab.textContent = open ? "◀" : "▶";
}

export function wireWordcloudSideDrawers(root, { onLayoutChange } = {}) {
  const left = root.querySelector('[data-wc-drawer="left"]');
  const right = root.querySelector('[data-wc-drawer="right"]');

  if (!left || !right) {
    console.warn("[wc] missing drawers", { left: !!left, right: !!right });
    return;
  }

  const fallbackState = { leftOpen: true, rightOpen: true };
  const saved = safeParse(localStorage.getItem(KEY), fallbackState);

  let state = {
    leftOpen: !!saved.leftOpen,
    rightOpen: !!saved.rightOpen,
  };

  function persist() {
    try {
      localStorage.setItem(KEY, JSON.stringify(state));
    } catch (_) {}
  }

  function setOpen(side, open, { silent = false } = {}) {
    const el = side === "left" ? left : right;

    el.classList.toggle("is-closed", !open);

    const tab = el.querySelector("[data-wc-drawer-toggle]");
    if (tab) tab.setAttribute("aria-expanded", open ? "true" : "false");

    updateTabIcon(el, side, open);

    if (side === "left") state.leftOpen = open;
    else state.rightOpen = open;

    persist();

    // ✅ CRITICAL FIX:
    // Drawer toggles are purely visual.
    // DO NOT call onLayoutChange() here.
    if (!silent) {
      try {
        root.dispatchEvent(
          new CustomEvent("wc:drawer-toggle", {
            detail: { side, open },
          })
        );
      } catch (_) {}
    }
  }

  // ✅ Init drawers (no spam, no double-redraw)
  setOpen("left", state.leftOpen, { silent: true });
  setOpen("right", state.rightOpen, { silent: true });

  // ✅ OPTIONAL: one layout call on init (safe)
  requestAnimationFrame(() => onLayoutChange?.());

  // Toggle clicks (NO redraw)
  root.querySelectorAll("[data-wc-drawer-toggle]").forEach((btn) => {
    btn.addEventListener("click", () => {
      const side = btn.getAttribute("data-wc-drawer-toggle");
      if (!side) return;

      const el = side === "left" ? left : right;
      const openNow = !el.classList.contains("is-closed");

      setOpen(side, !openNow); // ✅ purely visual toggle
    });
  });
}
</file>

<file path="features/progress/wordcloud/timeline.js">
// features/progress/wordcloud/timeline.js

function clamp(n, a, b) {
  return Math.max(a, Math.min(b, n));
}

/**
 * createTimelineController(config)
 * Config shape MUST match what index.js passes in.
 */
export function createTimelineController({
  dom,

  getRange,
  setRange,

  getWin,
  setWin,

  getPos,
  setPos,

  fmtDaysAgo,
  applyTimelineUI,
  requestDraw,
}) {
  let timer = null;

  const btnReplay = dom?.btnReplay;
  const posSlider = dom?.posSlider;

  function maxPos() {
    // prefer slider max if present
    const m = Number(posSlider?.max);
    return Number.isFinite(m) && m > 0 ? m : 90;
  }

  function isPlaying() {
    return !!timer;
  }

  // ✅ UI-only: must never start playback/timers
  function syncButton() {
    if (!btnReplay) return;

    // show only if in timeline mode
    const show = typeof getRange === "function" ? getRange() === "timeline" : true;
    btnReplay.style.display = show ? "inline-flex" : "none";

    btnReplay.textContent = isPlaying() ? "⏸ Stop" : "▶ Replay";
    btnReplay.title = isPlaying()
      ? "Stop timeline replay"
      : "Replay your progress over time";
  }

  function stop() {
    if (timer) clearInterval(timer);
    timer = null;
    syncButton();
  }

  function play({ stepDays = 1, intervalMs = 650 } = {}) {
    stop();

    // If user hits replay while not in timeline, switch them to it.
    if (typeof getRange === "function" && typeof setRange === "function") {
      if (getRange() !== "timeline") setRange("timeline");
    }

    syncButton();

    timer = setInterval(() => {
      try {
        const pos = Number(typeof getPos === "function" ? getPos() : 0) || 0;
        const next = clamp(pos + stepDays, 0, maxPos());

        if (typeof setPos === "function") setPos(next);

        // keep UI synced + redraw
        applyTimelineUI?.();
        requestDraw?.();

        if (next >= maxPos()) stop();
      } catch (err) {
        console.error("[wc/timeline] replay tick failed:", err);
        stop();
      }
    }, intervalMs);

    syncButton();
  }

  function toggle() {
    if (timer) stop();
    else play();
  }

  // Slider delegates (events.js calls these)
  function setWinSafe(val) {
    if (typeof setWin === "function") setWin(Number(val) || 14);
    applyTimelineUI?.();
    requestDraw?.();
  }

  function setPosSafe(val) {
    if (typeof setPos === "function") setPos(Number(val) || 0);
    applyTimelineUI?.();
    requestDraw?.();
  }

  // ✅ Force STOPPED on load: never auto-replay
  stop();
  syncButton();

  return {
    play,
    stop,
    toggle,
    syncButton,
    setWin: setWinSafe,
    setPos: setPosSafe,
  };
}
</file>

<file path="features/recorder/index.js">
// features/recorder/index.js
// The Orchestrator: Connects DOM <-> Media <-> API <-> State.
// STATUS: Complete + Quality Guardrails.

import { logError, debug as logDebug } from "../../app-core/lux-utils.js";
import * as DOM from "./ui.js";
import * as Mic from "./media.js";
import {
  currentPassageKey,
  currentPartIdx,
  getChosenLang,
  currentParts,
  getSessionId,
  pushPartResult,
} from "../../app-core/state.js";
import { assessPronunciation, saveAttempt, getUID, fetchHistory } from "/src/api/index.js";
import { showPrettyResults } from "../results/index.js";
import { markPartCompleted } from "../passages/index.js";
import { bringInputToTop } from "../../helpers/index.js";
import { promptUserForAI } from "../../ui/ui-ai-ai-logic.js";

import { mountAudioModeSwitch } from "./audio-mode-switch.js";
import { getAudioMode, initAudioModeDataset } from "./audio-mode-core.js";

let isInitialized = false;
let recordingStartTime = 0; // NEW: Track duration
const STOP_DELAY_MS = 800;

// --- Guardrail Config ---
const MIN_DURATION_MS = 1500; // Must record for at least 1.5s
const MIN_SCORE_TO_SAVE = 10; // Don't save if score is < 10% (garbage audio)

/* ===========================
   Workflow Logic
   =========================== */

async function startRecordingFlow() {
  DOM.setStatus("Recording...");
  DOM.setVisualState("recording");

  // Start the clock
  recordingStartTime = Date.now();

  const success = await Mic.startMic(handleRecordingComplete, {
    onMeter: DOM.setRecordVizLevels,
  });

  if (!success) {
    DOM.setStatus("Microphone Error");
    DOM.setVisualState("idle");
  } else {
    logDebug("Hybrid Recording Started");
  }
}

function stopRecordingFlow() {
  // Guardrail 1: Too Short?
  const duration = Date.now() - recordingStartTime;
  if (duration < MIN_DURATION_MS) {
    DOM.setStatus("Too short! Hold button longer.");
    Mic.stopMic(); // Stop but we might need to flag it to ignore in handle?
    // Actually, handleRecordingComplete will fire. We check duration there too?
    // For simplicity, we just let it stop, but we'll check valid audio in handle.
  }

  DOM.setStatus("Stopping...");
  DOM.setVisualState("processing");

  setTimeout(() => {
    Mic.stopMic();
  }, STOP_DELAY_MS);
}

async function handleRecordingComplete(audioBlob) {
  try {
    // ✅ Store latest recording globally so Self Playback can download it
    try {
      const mode = getAudioMode();
      window.LuxLastRecordingBlob = audioBlob;
      window.LuxLastRecordingMeta = {
        mode,
        type: audioBlob?.type || "",
        size: audioBlob?.size || 0,
        ts: Date.now(),
        scope: "practice",
      };

      window.dispatchEvent(
        new CustomEvent("lux:lastRecording", {
          detail: { blob: audioBlob, meta: window.LuxLastRecordingMeta },
        })
      );
    } catch {}

    // Guardrail 1 Check: Audio Size
    if (audioBlob.size < 1000) {
      // < 1kb is definitely silence/error
      DOM.setStatus("Recording too short/empty.");
      DOM.setVisualState("idle");
      return; // EXIT EARLY
    }

    DOM.setVisualState("analyzing");
    const text = DOM.ui.textarea ? DOM.ui.textarea.value.trim() : "";
    bringInputToTop();

    // 1. Audio Handoff
    const audioEl = document.getElementById("playbackAudio");
    if (audioEl) {
      if (audioEl.src) URL.revokeObjectURL(audioEl.src);
      audioEl.src = URL.createObjectURL(audioBlob);
    }

    if (window.__attachLearnerBlob) window.__attachLearnerBlob(audioBlob);

    DOM.setStatus("Analyzing...");

    // 2. Azure Analysis
    const lang = getChosenLang();
    const result = await assessPronunciation({
      audioBlob,
      text,
      firstLang: lang,
    });

    logDebug("AZURE RESULT RECEIVED", result);

    // ✅ expose word timings for SelfPB Expanded "karaoke"
    try {
      const timings = extractWordTimingsForKaraoke(result);

      window.LuxLastAzureResult = result;
      window.LuxLastWordTimings = timings;

      window.dispatchEvent(
        new CustomEvent("lux:lastAssessment", { detail: { result, timings } })
      );
    } catch {}

    // Guardrail 2: Bad Score / No Speech Detected?
    const score = result?.NBest?.[0]?.PronScore || 0;
    if (score < MIN_SCORE_TO_SAVE) {
      console.warn("[Lux] Score too low (" + score + "%). Not saving to history.");
      DOM.setStatus("No clear speech detected. Try again!");
      DOM.setVisualState("idle");

      // We still show results so user sees "0%" and knows why
      const prettyFn = showPrettyResults || window.showPrettyResults;
      if (prettyFn) prettyFn(result);
      return; // EXIT EARLY - DO NOT SAVE
    }

    // 3. Update State
    if (currentParts && currentParts.length > 0) {
      pushPartResult(currentPartIdx, result);
    }

    DOM.setStatus("Not recording");
    DOM.setVisualState("idle");

    // 5. Show Results
    const prettyFn = showPrettyResults || window.showPrettyResults;
    if (prettyFn) prettyFn(result);

    bringInputToTop();
    markPartCompleted();

    // 6. DB Save & Refresh
    await saveToDatabase(result, text, lang);

    // 7. AI Trigger
    promptUserForAI(result, text, lang);
  } catch (err) {
    logError("handleRecordingComplete failed", err);
    DOM.setStatus("Error: " + (err.message || "Analysis failed"));
    DOM.setVisualState("idle");
  }
}

async function saveToDatabase(result, text, lang) {
  try {
    window.lastAttemptId = null;
    const uid = getUID && getUID();
    const sessionId = getSessionId();
    const localTime = new Date().toISOString();

    if (uid) {
      const saved = await saveAttempt({
        uid,
        passageKey: currentPassageKey,
        partIndex: currentPartIdx,
        text,
        azureResult: result,
        l1: lang,
        sessionId,
        localTime,
      });

      if (saved && saved.id) {
        window.lastAttemptId = saved.id;
        console.log("[Lux] Saved Attempt ID:", window.lastAttemptId);

        // REFRESH DASHBOARD (keeps the drawer intact)
        if (window.refreshDashboard) {
          try {
            await window.refreshDashboard();
          } catch (_) {}
        }
      }
    }
  } catch (e) {
    console.warn("DB Save Error", e);
  }
}

function extractWordTimingsForKaraoke(result) {
  const words = result?.NBest?.[0]?.Words;
  if (!Array.isArray(words) || words.length === 0) return [];

  const out = [];

  for (const w of words) {
    const word = String(w?.Word ?? w?.word ?? "").trim();
    const off = Number(w?.Offset ?? w?.offset ?? NaN);
    const dur = Number(w?.Duration ?? w?.duration ?? NaN);

    if (!word) continue;
    if (!isFinite(off) || !isFinite(dur)) continue;

    // Azure Offset/Duration are 100ns ticks → seconds
    const start = off / 10_000_000;
    const end = (off + dur) / 10_000_000;

    const acc =
      w?.PronunciationAssessment?.AccuracyScore ??
      w?.PronunciationAssessment?.Accuracy ??
      null;

    out.push({ word, start, end, acc });
  }

  return out;
}

export function initLuxRecorder() {
  if (isInitialized) return;

  // ✅ Stamp dataset immediately (even before UI mounts)
  initAudioModeDataset(getAudioMode());

  DOM.ensureRefs();

  // ✅ Audio Mode Switch (Normal / Pro)
  mountAudioModeSwitch({ scope: "practice" });

  const found = DOM.wireButtons({
    onRecord: startRecordingFlow,
    onStop: stopRecordingFlow,
  });
  if (found) {
    DOM.setVisualState("idle");
    isInitialized = true;
    logDebug("Lux Recorder (Modular) Initialized");
  }
}
export const wireRecordingButtons = initLuxRecorder;
</file>

<file path="features/my-words/store.js">
// features/my-words/store.js

import { normalizeText, splitLines } from "./normalize.js";

const LS_KEY_PREFIX = "lux_my_words_v1:";
const LS_OPEN_PREFIX = "lux_my_words_open_v1:";

function safeParse(json, fallback) {
  try {
    return JSON.parse(json);
  } catch {
    return fallback;
  }
}

function nowISO() {
  return new Date().toISOString();
}

function makeId() {
  if (typeof crypto !== "undefined" && crypto.randomUUID) return crypto.randomUUID();
  return "mw_" + Math.random().toString(16).slice(2) + "_" + Date.now().toString(16);
}

export function createMyWordsStore({ uid, onMutation } = {}) {
  const key = LS_KEY_PREFIX + String(uid || "anon");
  const openKey = LS_OPEN_PREFIX + String(uid || "anon");

  const subs = new Set();

  let state = {
    uid,
    open: false,
    query: "",
    entries: [],
  };

  function emit() {
    subs.forEach((fn) => {
      try {
        fn(state);
      } catch (_) {}
    });
  }

  function persist() {
    try {
      localStorage.setItem(key, JSON.stringify(state.entries));
    } catch (_) {}
  }

  function persistOpen() {
    try {
      localStorage.setItem(openKey, state.open ? "1" : "0");
    } catch (_) {}
  }

  function load() {
    try {
      const raw = localStorage.getItem(key) || "[]";
      const arr = safeParse(raw, []);
      state.entries = Array.isArray(arr) ? arr : [];
    } catch (_) {}

    try {
      const rawOpen = localStorage.getItem(openKey) || "0";
      state.open = rawOpen === "1";
    } catch (_) {}
  }

  function mut(payload) {
    try {
      onMutation?.(payload);
    } catch (_) {}
  }

  function getState() {
    return state;
  }

  function setOpen(open) {
    state.open = !!open;
    persistOpen();
    emit();
  }

  function toggleOpen() {
    setOpen(!state.open);
  }

  function setQuery(q) {
    state.query = String(q || "");
    emit();
  }

  function visibleEntries() {
    const q = normalizeText(state.query);
    return state.entries
      .filter((e) => !e.archived)
      .filter((e) => (q ? normalizeText(e.text).includes(q) : true))
      .sort((a, b) => {
        const ap = a.pinned ? 1 : 0;
        const bp = b.pinned ? 1 : 0;
        if (ap !== bp) return bp - ap;

        const at = new Date(a.mw_lastAt || a.updated_at || a.created_at || 0).getTime();
        const bt = new Date(b.mw_lastAt || b.updated_at || b.created_at || 0).getTime();
        return bt - at;
      });
  }

  function replaceEntries(entries) {
    state.entries = Array.isArray(entries) ? entries : [];
    persist();
    emit();
  }

  function addMany(rawOrLines) {
    const lines = Array.isArray(rawOrLines) ? rawOrLines : splitLines(rawOrLines);
    if (!lines.length) return { added: 0, merged: 0, lines: [] };

    const byNorm = new Map();
    state.entries.forEach((e) => byNorm.set(normalizeText(e.normalized_text || e.text), e));

    let added = 0;
    let merged = 0;

    lines.forEach((text) => {
      const norm = normalizeText(text);
      if (!norm) return;

      const existing = byNorm.get(norm);
      if (existing) {
        existing.text = text;
        existing.normalized_text = norm;
        existing.archived = false;
        existing.updated_at = nowISO();
        merged++;
      } else {
        const entry = {
          id: makeId(),
          uid: state.uid,
          text,
          normalized_text: norm,
          pinned: false,
          archived: false,
          created_at: nowISO(),
          updated_at: nowISO(),
        };
        state.entries.push(entry);
        byNorm.set(norm, entry);
        added++;
      }
    });

    if (added || merged) persist();
    emit();

    mut({ type: "addMany", lines, added, merged });

    return { added, merged, lines };
  }

  function togglePin(id) {
    const e = state.entries.find((x) => x.id === id);
    if (!e) return;
    e.pinned = !e.pinned;
    e.updated_at = nowISO();
    persist();
    emit();
    mut({ type: "togglePin", id, pinned: e.pinned });
  }

  function archive(id) {
    const e = state.entries.find((x) => x.id === id);
    if (!e) return;
    e.archived = true;
    e.updated_at = nowISO();
    persist();
    emit();
    mut({ type: "archive", id });
  }

  // ✅ NEW: restore an archived entry
  function restore(id) {
    const e = state.entries.find((x) => x.id === id);
    if (!e) return;
    e.archived = false;
    e.updated_at = nowISO();
    persist();
    emit();
    mut({ type: "restore", id });
  }

  function hardDelete(id) {
    state.entries = state.entries.filter((x) => x.id !== id);
    persist();
    emit();
    mut({ type: "hardDelete", id });
  }

  function subscribe(fn) {
    subs.add(fn);
    fn(state);
    return () => subs.delete(fn);
  }

  load();

  return {
    getState,
    subscribe,

    setOpen,
    toggleOpen,
    setQuery,
    visibleEntries,

    replaceEntries,
    addMany,
    togglePin,
    archive,
    restore, // ✅ add this
    hardDelete,
  };
}
</file>

<file path="features/progress/wordcloud/render.js">
// features/progress/wordcloud/render.js
import { renderWordCloudCanvas } from "./render-canvas.js";

/**
 * Renders the wordcloud canvas + updates related UI bits.
 * Keep this module "dumb": it takes args and does render work.
 */
export function renderWordcloudView({
  canvas,
  items,
  focusTest,
  clusterMode,
  pinnedSet,
  onSelect,
  onRenderEnd,
  reuseLayoutOnly = false,
}) {
  // IMPORTANT: preserve your onRenderEnd hook
  renderWordCloudCanvas(canvas, items, {
    focusTest,
    clusterMode,
    pinnedSet,
    onSelect,
    onRenderEnd,
    reuseLayoutOnly,
  });
}

// ✅ FIX #3 — Prevent redraw overlaps (timer collision)
let drawing = false;

/**
 * Draw orchestration extracted from index.js.
 * This function stays UI-agnostic by receiving all dependencies/callbacks as args.
 */
export async function drawWordcloud({
  forceFetch = false,

  // sequencing guard (object ref: { value: 0 })
  renderSeqRef,

  // UI hooks
  setBusy,
  waitTwoFrames,

  // DOM
  metaEl,
  canvas,

  // state
  mode,
  range,
  timelineWin,
  timelinePos,
  query,
  sort,
  mix,
  clusterMode,

  // data + helpers
  attemptsAll,
  ensureWordCloudLibs,
  ensureData,
  filterAttemptsByRange,
  computeItemsForView,
  renderSavedStrip,
  renderTargetsStrip,
  pinnedSet,

  // formatting helpers
  lower,
  rangeLabel,
  sortLabel,
  mixLabel,
  fmtDaysAgo,

  // persistence + UI state sync
  persist,
  syncUrl,
  setActiveButtons,
  setModeStory,

  // keeps index.js model state correct
  setLastItems,

  // selection handler (delegated to index.js so it can call the sheet)
  onSelect,
}) {
  if (!canvas || !metaEl) return;

  // ✅ Prevent re-entrancy stampedes
  if (drawing) return;
  drawing = true;

  try {
    const seq = ++renderSeqRef.value;

    // Show overlay immediately so click feedback is instant
    setBusy(true, "Loading cloud…", "Preparing layout");
    await waitTwoFrames();

    try {
      metaEl.textContent = "Loading…";

      setBusy(true, "Loading cloud engine…", "D3 layout + canvas renderer");

      console.time("[wc] ensure libs");
      const ok = await ensureWordCloudLibs();
      console.timeEnd("[wc] ensure libs");

      if (seq !== renderSeqRef.value) return;

      if (!ok) {
        setBusy(false);
        metaEl.textContent =
          "Word Cloud libraries not found. Add /public/vendor/d3.v7.min.js + /public/vendor/d3.layout.cloud.js";
        return;
      }

      setBusy(true, "Loading your practice history…", "Fetching attempt data");

      console.time("[wc] ensure data");
      await ensureData(forceFetch);
      console.timeEnd("[wc] ensure data");

      if (seq !== renderSeqRef.value) return;

      console.time("[wc] compute items");
      const attemptsInRange = filterAttemptsByRange(
        attemptsAll,
        range,
        timelineWin,
        timelinePos
      );
      const items = computeItemsForView(attemptsInRange);
      console.timeEnd("[wc] compute items");

      // IMPORTANT: keep index.js top3 logic correct
      if (typeof setLastItems === "function") setLastItems(items);

      renderSavedStrip();
      renderTargetsStrip(attemptsInRange);

      // ✅ (used by BOTH branches, safe to clear even if null)
      let slowNote = null;

      if (!items.length) {
        metaEl.textContent =
          mode === "phonemes"
            ? "Not enough phoneme data yet — do a little more practice first."
            : "Not enough word data yet — do a little more practice first.";

        // Empty canvas + stop overlay
        console.time("[wc] render layout");

        await new Promise((resolve) => {
          let done = false;

          // safety escape hatch (prevents deadlock if something goes truly insane)
          const kill = setTimeout(() => {
            if (done) return;
            done = true;
            try {
              console.timeEnd("[wc] render layout");
            } catch (_) {}
            resolve();
          }, 8000);

          renderWordcloudView({
            canvas,
            items: [],
            focusTest: null,
            clusterMode,
            pinnedSet,

            onRenderEnd: ({ reason } = {}) => {
              if (done) return;
              done = true;
              clearTimeout(kill);

              console.log("[wc] render end:", reason);
              console.timeEnd("[wc] render layout");
              clearTimeout(slowNote);

              if (seq === renderSeqRef.value) setBusy(false);
              resolve();
            },

            onSelect,
          });
        });

        return;
      }

      // Keep overlay ON until D3 layout finishes and paint happens
      setBusy(true, "Building cloud…", "Placing targets on canvas");

      // ✅ Reassurance message if layout takes a while
      slowNote = setTimeout(() => {
        if (seq === renderSeqRef.value) {
          setBusy(true, "Building cloud…", "Still working… (large history)");
        }
      }, 1200);

      const q = lower(query);
      const focusTest = q ? (idLower) => String(idLower || "").includes(q) : null;

      console.time("[wc] render layout");

      await new Promise((resolve) => {
        let done = false;

        // safety escape hatch (prevents deadlock if something goes truly insane)
        const kill = setTimeout(() => {
          if (done) return;
          done = true;
          try {
            console.timeEnd("[wc] render layout");
          } catch (_) {}
          resolve();
        }, 8000);

        renderWordcloudView({
          canvas,
          items,
          focusTest,
          clusterMode,
          pinnedSet,

          onRenderEnd: ({ reason } = {}) => {
            if (done) return;
            done = true;
            clearTimeout(kill);

            console.log("[wc] render end:", reason);
            console.timeEnd("[wc] render layout");
            clearTimeout(slowNote);

            if (seq === renderSeqRef.value) setBusy(false);
            resolve();
          },

          onSelect,
        });
      });

      const label = mode === "phonemes" ? "Phonemes" : "Words";
      const tl =
        range === "timeline"
          ? ` · Window: ${timelineWin}d ending ${fmtDaysAgo(timelinePos)}`
          : "";

      metaEl.textContent =
        `Updated ${new Date().toLocaleString()} · ${label} · ${rangeLabel(
          range
        )}${tl} · Sort: ${sortLabel(sort)} · Mix: ${mixLabel(mix)}` +
        (q ? ` · Search: “${String(query || "").trim()}”` : "");

      persist();
      syncUrl();
      setActiveButtons();
      setModeStory();
    } catch (err) {
      console.error("[Cloud Visuals] draw failed:", err);
      if (seq === renderSeqRef.value) setBusy(false);
      metaEl.textContent = "Cloud load failed — check console for details.";
    }
  } finally {
    drawing = false;
  }
}
</file>

<file path="features/progress/wordcloud/template.js">
// features/progress/wordcloud/template.js
// ✅ Wordcloud HTML template extracted from index.js

export function wordcloudTemplateHtml() {
  return `
    <section class="lux-wc-shell" id="luxWcShell">
      <div class="lux-wc-head">
        <div>
          <div class="lux-wc-title">☁️ Cloud Visuals</div>
          <div class="lux-wc-sub" id="luxWcSub">
            Size = frequency · Color = difficulty (Lux scoring)
          </div>
        </div>
      </div>

      <div class="lux-wc-body">
        <div class="wcDock" data-wc-dock>

          <!-- =========================
               LEFT DRAWER (Explore)
          ========================== -->
          <aside class="wcDrawer wcDrawer--left" data-wc-drawer="left">
            <button
              class="wcDrawerTab"
              data-wc-drawer-toggle="left"
              data-tip="Show/hide filters"
              title="Show/hide filters"
              aria-expanded="true"
            >
              ◀
            </button>

            <div class="wcDrawerPanel">
              <div class="wcDrawerHeader">Explore</div>
              <div class="wcDrawerBody">

                <!-- Search -->
                <div class="lux-wc-search">
                  <input
                    id="luxWcSearch"
                    type="search"
                    placeholder="Search cloud…"
                    autocomplete="off"
                    data-tip="Filter targets by typing part of a word/phoneme."
                    title="Filter targets by typing part of a word/phoneme."
                  />
                  <button
                    class="lux-wc-clear"
                    id="luxWcClear"
                    data-tip="Clear search filter."
                    title="Clear search filter."
                  >✕</button>
                </div>

                <!-- Sort -->
                <div class="lux-wc-chipBar" aria-label="Sort">
                  <button
                    id="luxWcSortPriority"
                    class="lux-wc-chipBtn"
                    data-sort="priority"
                    data-tip="Best overall targets (difficulty + frequency + persistence)."
                    title="Best overall targets (difficulty + frequency + persistence)."
                  >Priority</button>

                  <button
                    id="luxWcSortFrequent"
                    class="lux-wc-chipBtn"
                    data-sort="freq"
                    data-tip="Most used targets (highest frequency)."
                    title="Most used targets (highest frequency)."
                  >Frequent</button>

                  <button
                    id="luxWcSortDifficult"
                    class="lux-wc-chipBtn"
                    data-sort="diff"
                    data-tip="Hardest targets (lowest score)."
                    title="Hardest targets (lowest score)."
                  >Difficult</button>

                  <button
                    id="luxWcSortRecent"
                    class="lux-wc-chipBtn"
                    data-sort="recent"
                    data-tip="Targets you struggled with most recently."
                    title="Targets you struggled with most recently."
                  >Recent</button>

                  <button
                    id="luxWcSortPersistent"
                    class="lux-wc-chipBtn"
                    data-sort="persist"
                    data-tip="Targets you keep missing over time."
                    title="Targets you keep missing over time."
                  >Persistent</button>
                </div>

                <!-- Range -->
                <div class="lux-wc-chipBar" aria-label="Time range">
                  <button
                    id="luxWcRangeAll"
                    class="lux-wc-chipBtn"
                    data-range="all"
                    data-tip="Use your full history."
                    title="Use your full history."
                  >All time</button>

                  <button
                    id="luxWcRange30d"
                    class="lux-wc-chipBtn"
                    data-range="30d"
                    data-tip="Only include the last 30 days."
                    title="Only include the last 30 days."
                  >30d</button>

                  <button
                    id="luxWcRange7d"
                    class="lux-wc-chipBtn"
                    data-range="7d"
                    data-tip="Only include the last 7 days."
                    title="Only include the last 7 days."
                  >7d</button>

                  <button
                    id="luxWcRangeToday"
                    class="lux-wc-chipBtn"
                    data-range="today"
                    data-tip="Only include today’s attempts."
                    title="Only include today’s attempts."
                  >Today</button>

                  <button
                    id="luxWcRangeTimeline"
                    class="lux-wc-chipBtn"
                    data-range="timeline"
                    data-tip="Replay your targets through time."
                    title="Replay your targets through time."
                  >Timeline</button>
                </div>

                <!-- Timeline controls -->
                <div class="lux-wc-timelineRow" id="luxWcTimelineRow">
                  <div class="lux-wc-timelineLabel"
                    data-tip="Timeline replay settings."
                    title="Timeline replay settings."
                  >Timeline</div>

                  <div class="lux-wc-timelineGroup">
                    <div class="lux-wc-tlineMini">Window</div>
                    <input id="luxWcWin" type="range" min="7" max="60" step="1"
                      data-tip="How many days to include in the replay window."
                      title="How many days to include in the replay window."
                    />
                    <div class="lux-wc-tlineVal" id="luxWcWinVal"></div>
                  </div>

                  <div class="lux-wc-timelineGroup">
                    <div class="lux-wc-tlineMini">Ends</div>
                    <input id="luxWcPos" type="range" min="0" max="90" step="1"
                      data-tip="How many days ago the replay window ends."
                      title="How many days ago the replay window ends."
                    />
                    <div class="lux-wc-tlineVal" id="luxWcPosVal"></div>
                  </div>

                  <button class="lux-pbtn lux-pbtn--ghost" id="luxWcReplay"
                    data-tip="Play/stop timeline replay."
                    title="Play/stop timeline replay."
                  >▶ Replay</button>
                </div>

              </div>
            </div>
          </aside>


          <!-- =========================
               CENTER STAGE (Square Cloud)
          ========================== -->
          <main class="wcStage">
            <div class="wcStageCard">
              <div class="lux-wc-canvasWrap wcStageSquare" id="luxWcCanvasWrap">
                <canvas id="luxWcCanvas" class="lux-wc-canvas wcCanvas"></canvas>

                <!-- Loading overlay (shows during layout + redraw) -->
                <div class="lux-wc-overlay" id="luxWcOverlay" aria-live="polite" aria-busy="true" hidden>
                  <div class="lux-wc-overlayCard">
                    <div class="lux-wc-spinner" aria-hidden="true"></div>
                    <div class="lux-wc-overlayText">
                      <div class="lux-wc-overlayTitle" id="luxWcOverlayTitle">Loading…</div>
                      <div class="lux-wc-overlaySub" id="luxWcOverlaySub">Building your cloud</div>
                    </div>
                  </div>
                </div>
              </div>

              <div class="wcStageFooter">
                <div class="lux-wc-legend">
                  <span><span class="lux-wc-dot" style="background:#2563eb;"></span>80+ (Good)</span>
                  <span><span class="lux-wc-dot" style="background:#d97706;"></span>60–79 (Warn)</span>
                  <span><span class="lux-wc-dot" style="background:#dc2626;"></span>&lt;60 (Needs work)</span>
                </div>

                <div id="luxWcMeta" style="margin-top:10px; color:#94a3b8; font-weight:900;"></div>
              </div>
            </div>
          </main>


          <!-- =========================
               RIGHT DRAWER (Actions)
          ========================== -->
          <aside class="wcDrawer wcDrawer--right" data-wc-drawer="right">
            <button
              class="wcDrawerTab"
              data-wc-drawer-toggle="right"
              data-tip="Show/hide actions"
              title="Show/hide actions"
              aria-expanded="true"
            >
              ▶
            </button>

            <div class="wcDrawerPanel">
              <div class="wcDrawerHeader">Actions</div>
              <div class="wcDrawerBody">

                <!-- Mode -->
                <div class="lux-wc-toggle" role="tablist" aria-label="Cloud mode">
                  <button
                    id="luxWcModeWords"
                    class="lux-wc-pill"
                    data-mode="words"
                    data-tip-pos="down"
                    data-tip="Show word targets (size = frequency, color = difficulty)."
                    title="Show word targets (size = frequency, color = difficulty)."
                  >Words</button>

                  <button
                    id="luxWcModePhonemes"
                    class="lux-wc-pill"
                    data-mode="phonemes"
                    data-tip-pos="down"
                    data-tip="Show sound targets (phonemes) instead of words."
                    title="Show sound targets (phonemes) instead of words."
                  >Phonemes</button>
                </div>

                <!-- Top actions -->
                <div class="lux-wc-actions">
                  <button class="lux-pbtn lux-pbtn--ghost" id="luxWcThemeToggle"
                    data-tip="Toggle theme."
                    title="Toggle theme."
                  >🌙</button>

                  <button class="lux-pbtn" id="luxWcRefresh"
                    data-tip="Reload history and redraw the cloud."
                    title="Reload history and redraw the cloud."
                  >Refresh</button>

                <!-- Power row -->
                <div class="lux-wc-powerRow">
                  <button class="lux-pbtn lux-wc-genTop" id="luxWcGenTop"
                    data-tip="Start a drill from your top 3 targets."
                    title="Start a drill from your top 3 targets."
                  >✨ Generate from Top 3</button>

                  <button class="lux-pbtn lux-pbtn--ghost lux-wc-powerBtn" id="luxWcCluster"
                    data-tip="Group targets into clusters."
                    title="Group targets into clusters."
                  >🧩 Cluster</button>

                  <button class="lux-pbtn lux-pbtn--ghost lux-wc-powerBtn" id="luxWcSnapshot"
                    data-tip="Save an image of the current cloud."
                    title="Save an image of the current cloud."
                  >📷 Snapshot</button>
                </div>

                <!-- Mix -->
                <div class="lux-wc-mixRow" aria-label="Top target mix">
                  <span class="lux-wc-mixLabel"
                    data-tip="How Top 3 is chosen."
                    title="How Top 3 is chosen."
                  >Top 3:</span>

                  <button class="lux-wc-chipBtn" id="luxWcMixView" data-mix="view"
                    data-tip="Pick Top 3 from what’s currently visible."
                    title="Pick Top 3 from what’s currently visible."
                  >View-based</button>

                  <button class="lux-wc-chipBtn" id="luxWcMixSmart" data-mix="smart"
                    data-tip="Pick Top 3 using your priority formula."
                    title="Pick Top 3 using your priority formula."
                  >Smart Mix</button>
                </div>

                <!-- Strips -->
                <div class="lux-wc-targetStrip" id="luxWcTargets"
                  data-tip="Your Top 3 targets (click one to open details)."
                  title="Your Top 3 targets (click one to open details)."
                ></div>

                <div class="lux-wc-savedStrip" id="luxWcSaved"
                  data-tip="Pinned targets you’ve saved for focus."
                  title="Pinned targets you’ve saved for focus."
                ></div>

                <!-- Coach lane -->
                <div class="lux-wc-coachLane" id="luxWcCoach">
                  <div class="lux-wc-coachTitle"
                    data-tip="Quick actions for targeted practice."
                    title="Quick actions for targeted practice."
                  >Coach Lane</div>

                  <div class="lux-wc-coachBtns">
                    <button class="lux-pbtn" id="luxWcCoachQuick"
                      data-tip="Generate a fast drill using pinned/top targets."
                      title="Generate a fast drill using pinned/top targets."
                    >⚡ Quick drill</button>

                    <button class="lux-pbtn lux-pbtn--ghost" id="luxWcCoachPinTop"
                      data-tip="Pin the current Top 3 targets."
                      title="Pin the current Top 3 targets."
                    >📌 Pin Top 3</button>
                  </div>

                  <div class="lux-wc-coachHint" id="luxWcCoachHint"></div>
                </div>

              </div>
            </div>
          </aside>

        </div>
      </div>
    </section>
  `;
}
</file>

<file path="features/recorder/audio-mode-switch.js">
// features/recorder/audio-mode-switch.js

import {
  AUDIO_MODES,
  getAudioMode,
  setAudioMode,
  initAudioModeDataset,
} from "./audio-mode-core.js";

const SELECTOR = {
  wrap: ".lux-audioModeWrap",
};

function kickBump(toggleEl) {
  // restart the CSS animation cleanly
  toggleEl.classList.remove("is-bump");
  void toggleEl.offsetWidth; // reflow
  toggleEl.classList.add("is-bump");
  window.setTimeout(() => toggleEl.classList.remove("is-bump"), 320);
}

/* ✅ Tooltip helper */
function attachAudioTooltip(btn, title, rows, envLine) {
  const tip = document.createElement("div");
  tip.className = "lux-audioTip";

  const t = document.createElement("div");
  t.className = "lux-audioTipTitle";
  t.textContent = title;

  const list = document.createElement("ul");
  list.className = "lux-audioTipList";

  rows.forEach((r) => {
    const li = document.createElement("li");
    li.textContent = r;
    list.appendChild(li);
  });

  const env = document.createElement("div");
  env.className = "lux-audioTipEnv";
  env.textContent = envLine;

  tip.appendChild(t);
  tip.appendChild(list);
  tip.appendChild(env);

  btn.appendChild(tip);
}

/* ✅ Fix #3 helper: float dock so Record/Stop stay centered */
let _dockResizeHandler = null;

function dockRightOfStop(ui, stopBtn) {
  const group = stopBtn.closest(".btn-group");
  if (!group) return;

  // Keep tooltips + knob overflow safe
  group.style.position = group.style.position || "relative";
  group.style.overflow = "visible";

  ui.classList.add("is-floatDock");
  ui.style.position = "absolute";

  const place = () => {
    const left = stopBtn.offsetLeft + stopBtn.offsetWidth + 14;
    const top =
      stopBtn.offsetTop +
      Math.round((stopBtn.offsetHeight - ui.offsetHeight) / 2);

    ui.style.left = `${left}px`;
    ui.style.top = `${top}px`;
  };

  requestAnimationFrame(place);

  // Avoid stacking resize listeners on remount
  if (_dockResizeHandler) window.removeEventListener("resize", _dockResizeHandler);
  _dockResizeHandler = () => requestAnimationFrame(place);
  window.addEventListener("resize", _dockResizeHandler);
}

function ensurePracticeActionsRow() {
  const btnGroup = document.querySelector(".btn-group");
  if (!btnGroup) return null;

  // Already wrapped?
  const existing = btnGroup.closest(".lux-rec-actions");
  if (existing) return existing;

  // Wrap btn-group in a row container so we can place the toggle to the right
  const row = document.createElement("div");
  row.className = "lux-rec-actions";

  const parent = btnGroup.parentElement;
  if (!parent) return null;

  parent.insertBefore(row, btnGroup);
  row.appendChild(btnGroup);

  return row;
}

function findPracticeAnchor() {
  // ✅ Dock to the right of Record/Stop (same row)
  return ensurePracticeActionsRow();
}

function findConvoAnchor() {
  // If you mount it in AI Convo header actions, keep existing behavior
  return document.querySelector(".lux-convo-actions") || null;
}

function buildUI(scope = "practice") {
  const wrap = document.createElement("div");
  wrap.className = "lux-audioModeWrap";

  const label = document.createElement("div");
  label.className = "lux-audioModeLabel";
  label.textContent = "Audio";

  const toggle = document.createElement("div");
  toggle.className = "lux-audioToggle";

  const btnNormal = document.createElement("button");
  btnNormal.className = "lux-audioOpt";
  btnNormal.type = "button";
  btnNormal.dataset.mode = "NORMAL";
  btnNormal.textContent = "Normal";

  const btnPro = document.createElement("button");
  btnPro.className = "lux-audioOpt";
  btnPro.type = "button";
  btnPro.dataset.mode = "PRO";
  btnPro.textContent = "Pro";

  // ✅ Replace data-tip tooltips with richer tooltip DOM
  attachAudioTooltip(
    btnNormal,
    "Balanced quality + smaller size",
    ["Echo cancellation: ON", "Noise suppression: ON", "Auto gain control: ON"],
    "Best in: everyday rooms (handles light background noise)."
  );

  attachAudioTooltip(
    btnPro,
    "Higher quality + slightly larger size",
    ["Echo cancellation: OFF", "Noise suppression: OFF", "Auto gain control: OFF"],
    "Best in: quiet rooms (cleanest, most natural audio)."
  );

  const knob = document.createElement("span");
  knob.className = "lux-audioKnob";

  toggle.appendChild(btnNormal);
  toggle.appendChild(btnPro);
  toggle.appendChild(knob);

  wrap.appendChild(label);
  wrap.appendChild(toggle);

  // scope styling hooks
  if (scope === "practice") wrap.classList.add("is-docked");
  if (scope === "convo") wrap.classList.add("is-compact");

  // initial dataset mode sync
  const mode = getAudioMode?.() || AUDIO_MODES?.NORMAL || "NORMAL";
  initAudioModeDataset?.(mode);

  toggle.addEventListener("click", (e) => {
    const b = e.target.closest("button[data-mode]");
    if (!b) return;

    const next = b.dataset.mode;
    setAudioMode?.(next);
    initAudioModeDataset?.(next);
    kickBump(toggle); // ✅ subtle “switch happened” feedback
  });

  return wrap;
}

export function mountAudioModeSwitch(scope = "practice") {
  // Kill duplicate mounts
  document.querySelectorAll(SELECTOR.wrap).forEach((n) => n.remove());

  const ui = buildUI(scope);

  let anchor = null;
  if (scope === "convo") anchor = findConvoAnchor();
  else anchor = findPracticeAnchor();

  if (!anchor) return null;

  // ✅ Practice: force the switch to live AFTER the Stop button
  if (scope === "practice") {
    const stopBtn = document.querySelector("#stop");
    if (stopBtn && stopBtn.parentElement) {
      // Insert immediately after Stop inside the same flex row
      stopBtn.insertAdjacentElement("afterend", ui);
      ui.classList.add("is-rightOfStop");

      // ✅ Float it so Record/Stop stay centered
      dockRightOfStop(ui, stopBtn);

      return ui;
    }
  }

  // fallback behavior (convo/header/etc.)
  anchor.prepend(ui);
  return ui;
}
</file>

<file path="src/main.js">
// src/main.js
// The Main Entry Point: Boots the app, handles the Typewriter, and wires the Dropdown.

import "../lux-audio-mode.css";

import { wirePassageSelect, wireNextBtn } from "../features/passages/index.js";

import { wireHarvardPicker } from "../features/harvard/index.js";

import { initLuxRecorder, wireRecordingButtons } from "../features/recorder/index.js";

import { mountAudioModeSwitch } from "../features/recorder/audio-mode-switch.js";

import { showSummary } from "../features/results/index.js";

import { allPartsResults, currentParts } from "../app-core/state.js";

import { initAudioSink } from "../app-core/audio-sink.js";
import { bootTTS } from "../features/features/tts/boot-tts.js";

// NEW: Import the language change handler for auto-updates
import { onLanguageChanged } from "../ui/ui-ai-ai-logic.js";

// Lazy-load controller for the Self-Playback drawer
import "../features/features/08-selfpb-peekaboo.js";

// Onboarding
import { maybeShowOnboarding } from "../features/onboarding/lux-onboarding.js";

// Dashboard
import { initDashboard } from "../features/dashboard/index.js";

// Authentication (NEW)
import { initAuthUI } from "../ui/auth-dom.js";

// Arrow trail (NEW)
import { initArrowTrail } from "../ui/ui-arrow-trail.js";

// ✅ My Words Lazy-Load Launcher (NEW)
import { bootMyWordsLauncher } from "../features/my-words/launcher.js";

// --- VISUALS: Typewriter Effect ---
let typewriterTimeout;

function startTypewriter() {
  const input = document.getElementById("referenceText");
  if (!input) return;

  const phrases = [
    "Paste or type everything you’ll read here...",
    "Try the Rainbow Passage to test all phonemes (sounds)...",
    "Focus on difficult words you struggle with...",
    "Select a passage from the menu above...",
    "Practice your elevator pitch...",
    "Rehearse your upcoming presentation script...",
    "Tricky phrase: “third thorough thought”",
    "Read an email draft out loud to check the tone...",
    "Prepare for a job interview answer...",
    "Practice your Zoom meeting introduction...",
    "Interview intro: “Thanks for having me...”",
    "Read your favorite poem aloud...",
    "Practice a movie monologue...",
    "Phone message: “Hi, this is Mark — please call me back”",
    "Try a difficult tongue twister...",
    "Read a recipe instruction clearly...",
    "Tell a short story...",
    "Practice ordering coffee clearly...",
    "Read a news headline...",
    "Audio note: “Schedule a sales demo for 10am”",
    "Practice explaining a complex idea simple...",
    "Work on your 'R' and 'L' sounds...",
    "Slow down and enunciate every syllable...",
    "Go over exactly what you'll say when you propose...",
    "Speech closer: “In short, here’s why...”",
  ];

  let i = 0;
  let charIndex = 0;
  let isDeleting = false;
  let currentPhrase = "";

  function type() {
    if (document.activeElement === input || input.value.length > 0) return;

    const fullPhrase = phrases[i];

    if (isDeleting) {
      currentPhrase = fullPhrase.substring(0, charIndex - 1);
      charIndex--;
    } else {
      currentPhrase = fullPhrase.substring(0, charIndex + 1);
      charIndex++;
    }

    input.setAttribute("placeholder", currentPhrase);

    let speed = 40;
    if (isDeleting) speed = 20;

    if (!isDeleting && charIndex === fullPhrase.length) {
      speed = 2000;
      isDeleting = true;
    } else if (isDeleting && charIndex === 0) {
      isDeleting = false;
      i = (i + 1) % phrases.length;
      speed = 500;
    }

    typewriterTimeout = setTimeout(type, speed);
  }

  type();
}

// --- MAIN BOOT SEQUENCE ---
async function bootApp() {
  console.log("[Lux] Booting features...");

  // 1. Initialize Audio Infrastructure
  initAudioSink();

  // ✅ Boot TTS panel (lazy player mount on open)
  bootTTS();

  // 2. Setup Passages
  wirePassageSelect();
  wireNextBtn();

  wireHarvardPicker(); // ✅ new

  // 3. Setup Dropdown Logic
  const passageSelect = document.getElementById("passageSelect");
  const textInput = document.getElementById("referenceText");

  // --- NEW: Wire up the Language Selector for Auto-Updates ---
  const langSelect = document.getElementById("l1Select");
  if (langSelect) {
    langSelect.addEventListener("change", (e) => {
      // Tell the AI logic that language changed immediately
      onLanguageChanged(e.target.value);
    });
  }
  // ----------------------------------------------------------

  if (passageSelect && textInput) {
    passageSelect.addEventListener("change", (e) => {
      const val = e.target.value;
      if (val === "write-own") {
        textInput.value = "";
        textInput.focus();
      } else if (val === "clear") {
        textInput.value = "";
        passageSelect.value = "";
        textInput.blur();
        startTypewriter();
      }
    });

    textInput.addEventListener("focus", () => {
      if (typewriterTimeout) clearTimeout(typewriterTimeout);
      textInput.setAttribute("placeholder", "Type whatever you like here...");
    });

    textInput.addEventListener("blur", () => {
      if (textInput.value.trim() === "") {
        startTypewriter();
      }
    });
  }

  // 4. Setup Recorder
  await initLuxRecorder();
  wireRecordingButtons();

  // ✅ Mount audio mode switch AFTER recorder DOM exists
  mountAudioModeSwitch("practice");

  // 5. Setup Summary Button
  const summaryBtn = document.getElementById("showSummaryBtn");
  if (summaryBtn) {
    summaryBtn.addEventListener("click", () => {
      showSummary({
        allPartsResults: allPartsResults,
        currentParts: currentParts,
      });
    });
  }

  // 6. Start Visuals
  startTypewriter();

  // 6.5 Arrow trail (NEW)
  initArrowTrail({
    targetSelector: "aside.lux-tts-panel > button.lux-tts-tab",
    autoRunMs: 7000,
    autoRunOnce: true,
    // debug: true, // optional for 30 seconds
  });

  setTimeout(() => {
    const banner = document.getElementById("lux-top-banner");
    const msg = document.getElementById("userMsg");

    if (banner) banner.classList.add("is-revealed");
    if (msg) msg.classList.add("show");

    requestAnimationFrame(() => {
      updateTopBannerLayout();
      setTimeout(updateTopBannerLayout, 460);
    });
  }, 2500);

  // 7. Boot Dashboard
  await initDashboard();

  // 8. Boot Authentication
  initAuthUI();

  // 9. Boot New Onboarding Deck (CSS is loaded via index.html <link>)
  maybeShowOnboarding();

  // ✅ 10. Boot My Words launcher (LAZY)
  bootMyWordsLauncher();

  console.log("[Lux] App fully initialized.");
}

// Add functionality to toggle the visibility of the banner using the collapse and tab buttons.
function updateTopBannerLayout() {
  const banner = document.getElementById("lux-top-banner");
  if (!banner) return;

  const panel = banner.querySelector(".lux-top-banner-panel");
  const handle = banner.querySelector(".lux-banner-handle");
  if (!panel || !handle) return;

  const collapsed = banner.classList.contains("is-collapsed");
  const revealed = banner.classList.contains("is-revealed");

  // Show the handle once the banner has revealed OR if user previously collapsed it
  const showHandle = revealed || collapsed;
  handle.style.opacity = showHandle ? "1" : "0";
  handle.style.pointerEvents = showHandle ? "auto" : "none";

  // Position handle: when open, hang off panel bottom; when collapsed, sit near top
  let handleTop = 16;
  if (!collapsed && revealed) {
    const panelRect = panel.getBoundingClientRect();
    handleTop = Math.max(16, Math.ceil(panelRect.bottom));
  }
  document.documentElement.style.setProperty(
    "--lux-banner-handle-top",
    handleTop + "px"
  );

  // Arrow + a11y
  handle.textContent = collapsed ? "Tips ▾" : "Tips ▴";
  handle.setAttribute("aria-label", collapsed ? "Show tips" : "Hide tips");
  handle.title = collapsed ? "Show tips" : "Hide tips";

  // Content offset: push past whichever is lowest (panel or handle)
  if (!revealed && !collapsed) {
    document.documentElement.style.setProperty("--lux-top-banner-offset", "0px");
    return;
  }

  const panelRect = panel.getBoundingClientRect();
  const handleRect = handle.getBoundingClientRect();
  const bottom = collapsed
    ? handleRect.bottom
    : Math.max(panelRect.bottom, handleRect.bottom);

  document.documentElement.style.setProperty(
    "--lux-top-banner-offset",
    Math.ceil(bottom) + "px"
  );
}

document.addEventListener("DOMContentLoaded", () => {
  const banner = document.getElementById("lux-top-banner");
  if (!banner) return;

  const panel = banner.querySelector(".lux-top-banner-panel");
  const handle = banner.querySelector(".lux-banner-handle");
  if (!panel || !handle) return;

  // Load state
  let collapsed = false;
  try {
    collapsed = localStorage.getItem("bannerCollapsed") === "true";
  } catch {}
  banner.classList.toggle("is-collapsed", collapsed);

  // If user previously collapsed it, we still want the handle visible immediately
  if (collapsed) banner.classList.add("is-revealed");

  const setCollapsed = (next) => {
    banner.classList.toggle("is-collapsed", !!next);
    try {
      localStorage.setItem("bannerCollapsed", next ? "true" : "false");
    } catch {}

    requestAnimationFrame(() => {
      updateTopBannerLayout();
      setTimeout(updateTopBannerLayout, 460);
    });
  };

  // Handle toggles both ways, always
  handle.addEventListener("click", (e) => {
    e.preventDefault();
    setCollapsed(!banner.classList.contains("is-collapsed"));
  });

  // Keep layout correct after animation and resizes
  panel.addEventListener("transitionend", () => updateTopBannerLayout());
  window.addEventListener("resize", () => updateTopBannerLayout(), {
    passive: true,
  });

  updateTopBannerLayout();
});

// Run Boot
if (document.readyState === "loading") {
  document.addEventListener("DOMContentLoaded", bootApp);
} else {
  bootApp();
}
</file>

<file path="features/progress/render/dashboard.js">
// features/progress/render/dashboard.js
// Main full-size Progress dashboard render functions live here.
// features/progress/render/dashboard.js

import { openDetailsModal } from "../attempt-detail-modal.js";

import {
  buildNextActivityPlanFromModel,
  saveNextActivityPlan,
} from "../../next-activity/next-activity.js";

import { scoreClass, fmtScore, fmtDate, titleFromPassageKey, esc } from "./format.js";
import { sparklineSvg } from "./sparkline.js";
import { downloadBlob } from "./export.js";

export function renderProgressDashboard(host, attempts, model, opts = {}) {
  const totals = model?.totals || {};
  const trouble = model?.trouble || {};
  const trend = model?.trend || [];
  const sessions = model?.sessions || [];

  const title = opts.title || "My Progress";
  const subtitle = opts.subtitle || "All practice (Pronunciation + AI Conversations)";
  const showActions = opts.showActions !== false; // default true
  const showCoach = !!opts.showCoach;

  // ✅ NEW (All Data-only): metric trends section (acc/flu/comp/pron)
  const showMetricTrends = !!opts.showMetricTrends && !!model?.metrics;

  const topPh = (trouble.phonemesAll || []).slice(0, 12);
  const topWd = (trouble.wordsAll || []).slice(0, 12);

  function pickAzure(a) {
    return a?.azureResult || a?.azure_result || a?.azure || a?.result || null;
  }
  function pickSummary(a) {
    return a?.summary || a?.summary_json || a?.sum || null;
  }
  function pickSessionId(a) {
    return a?.session_id || a?.sessionId || "";
  }
  function pickTS(a) {
    return a?.ts || a?.created_at || a?.createdAt || a?.time || a?.localTime || null;
  }

  // Pre-group attempts by session for History drill-in.
  function localDayKey(ts) {
    const d = new Date(ts);
    try {
      return d.toLocaleDateString("en-CA");
    } catch (_) {}
    const y = d.getFullYear();
    const m = String(d.getMonth() + 1).padStart(2, "0");
    const da = String(d.getDate()).padStart(2, "0");
    return `${y}-${m}-${da}`;
  }

  function sessionKeyForAttempt(a) {
    const sid = pickSessionId(a);
    if (sid) return sid;

    const ts = pickTS(a);
    if (!ts) return "";
    return `nosess:${localDayKey(ts)}`;
  }

  const bySession = new Map();
  for (const a of attempts || []) {
    const sid = sessionKeyForAttempt(a);
    if (!sid) continue;
    const arr = bySession.get(sid) || [];
    arr.push(a);
    bySession.set(sid, arr);
  }

  host.innerHTML = `
    <a id="lux-my-progress"></a>
    <section class="lux-progress-shell">
      <div class="lux-progress-head">
        <div>
          <h2 class="lux-progress-title">${esc(title)}</h2>
          <div class="lux-progress-sub">${esc(subtitle)}</div>
        </div>
        ${
          showActions
            ? `
          <div class="lux-progress-actions">
<button class="lux-pbtn" id="luxGenerateNextPractice" data-lux-generate-next>
  ✨ Generate my next practice
</button>
<button class="lux-pbtn lux-pbtn--ghost" id="luxOpenWordCloud">
  ☁️ Cloud Visuals
</button>
            <button class="lux-pbtn" id="luxDownloadReport">Download report</button>
            <button class="lux-pbtn lux-pbtn--ghost" id="luxDownloadTrouble">Download troubleshooting report</button>
          </div>
        `
            : ``
        }
      </div>

      <div class="lux-progress-cards">
        <div class="lux-pcard">
          <div class="lux-pcard-label">Sessions</div>
          <div class="lux-pcard-value">${totals.sessions ?? 0}</div>
          <div class="lux-pcard-mini">Attempts: ${totals.attempts ?? 0}</div>
        </div>

        <div class="lux-pcard">
          <div class="lux-pcard-label">Average score</div>
          <div class="lux-pcard-value">${fmtScore(totals.avgScore ?? 0)}</div>
          <div class="lux-pcard-mini">Last activity: ${fmtDate(totals.lastTS)}</div>
        </div>

        <div class="lux-pcard">
          <div class="lux-pcard-label">Trend (last 30 days)</div>
          ${sparklineSvg(trend)}
          <div class="lux-pcard-mini">Tap sections below for details</div>
        </div>
      </div>

      ${
        showMetricTrends
          ? `
      <details class="lux-progress-sec" open>
        <summary>📈 Score trends (by category)</summary>
        <div class="lux-sec-body">
          <div class="lux-metricTrendsGrid">
            ${renderMetricTrendCard(model.metrics.acc)}
            ${renderMetricTrendCard(model.metrics.flu)}
            ${renderMetricTrendCard(model.metrics.comp)}
            ${renderMetricTrendCard(model.metrics.pron)}
          </div>
          <div class="lux-metricTrendsNote">
            Prosody trend will be added once we store/compute it.
          </div>
        </div>
      </details>
      `
          : ``
      }

      <details class="lux-progress-sec" open>
        <summary>🎯 Snapshot</summary>
        <div class="lux-sec-body">
          <div class="lux-grid2">
            <div class="lux-kv">
              <div class="lux-k">Best day</div>
              <div class="lux-v">${fmtDate(totals.bestDayTS)} · ${
                totals.bestDayScore == null ? "—" : fmtScore(totals.bestDayScore)
              }</div>
            </div>
            <div class="lux-kv">
              <div class="lux-k">Most practiced</div>
              <div class="lux-v">${
                totals.topPassageKey
                  ? `${esc(titleFromPassageKey(totals.topPassageKey))}${
                      totals.topPassageCount
                        ? ` · ${totals.topPassageCount} attempt${
                            totals.topPassageCount === 1 ? "" : "s"
                          }`
                        : ""
                    }`
                  : "—"
              }</div>
            </div>
          </div>
        </div>
      </details>

      <details class="lux-progress-sec">
        <summary>⚠️ Trouble Sounds <span style="color:#94a3b8; font-weight:800">${
          (trouble.phonemesAll || []).length
        }</span></summary>
        <div class="lux-sec-body">
          <div class="lux-chiprow">
            ${
              topPh.length
                ? topPh
                    .map(
                      (p) => `
              <span class="lux-chip" title="${esc(
                `Seen ${p.count}× · ${p.days || 1} day(s) · priority ${
                  Number.isFinite(p.priority) ? p.priority.toFixed(2) : "—"
                }`
              )}">
                <span>${esc(p.ipa)}</span>
                <span class="lux-pill ${scoreClass(p.avg)}">${fmtScore(p.avg)}</span>
              </span>
            `
                    )
                    .join("")
                : `<span style="color:#64748b">Not enough data yet — keep practicing.</span>`
            }
          </div>
        </div>
      </details>

      <details class="lux-progress-sec">
        <summary>⚠️ Trouble Words <span style="color:#94a3b8; font-weight:800">${
          (trouble.wordsAll || []).length
        }</span></summary>
        <div class="lux-sec-body">
          <div class="lux-chiprow">
            ${
              topWd.length
                ? topWd
                    .map(
                      (w) => `
              <span class="lux-chip" title="${esc(
                `Seen ${w.count}× · ${w.days || 1} day(s) · priority ${
                  Number.isFinite(w.priority) ? w.priority.toFixed(2) : "—"
                }`
              )}">
                <span>${esc(w.word)}</span>
                <span class="lux-pill ${scoreClass(w.avg)}">${fmtScore(w.avg)}</span>
              </span>
            `
                    )
                    .join("")
                : `<span style="color:#64748b">Not enough data yet — keep practicing.</span>`
            }
          </div>
        </div>
      </details>

      <details class="lux-progress-sec">
        <summary>🕘 History</summary>
        <div class="lux-sec-body">
          <div class="lux-history">
            ${sessions
              .slice(0, 12)
              .map(
                (s) => `
              <div class="lux-hblock">
                <div class="lux-hrow" data-sid="${esc(s.sessionId)}" role="button" tabindex="0">
                  <div class="lux-hleft">
                    <div class="lux-htitle">${esc(titleFromPassageKey(s.passageKey))}</div>
                    <div class="lux-hmeta">${fmtDate(s.tsMax)} · ${s.count} attempt${
                  s.count === 1 ? "" : "s"
                }${s.hasAI ? " · 🤖 AI coaching" : ""}</div>
                  </div>
                  <div class="lux-hright">
                    <button class="lux-hbtn" type="button" data-sid="${esc(
                      s.sessionId
                    )}" aria-label="Show details">👉</button>
                    <div class="lux-pill ${scoreClass(s.avgScore)}">${fmtScore(s.avgScore)}</div>
                  </div>
                </div>
              </div>
            `
              )
              .join("")}
          </div>

          <div style="margin-top:10px; color:#64748b; font-size:0.9rem;">
            Showing your most recent sessions. Tip: click 👉 to open a saved-detail card (including any saved AI feedback).
          </div>
        </div>
      </details>

      ${
        showCoach
          ? `
      <!-- AI Coach (collapsed on load; opens after interaction) -->
      <details id="aiCoachDrawer" class="lux-progress-drawer lux-ai-drawer">
        <summary class="lux-progress-drawer-summary">
          <div class="lux-progress-drawer-left">
            <div class="lux-progress-drawer-title">AI Coach</div>
            <div class="lux-progress-drawer-mini">Tap to open</div>
          </div>
        </summary>
        <div class="lux-progress-drawer-body">
          <div id="aiFeedbackSection">
            <div id="aiFeedback"></div>
          </div>
        </div>
      </details>
      `
          : ``
      }
    </section>
  `;

  function renderAiFeedback(sum) {
    const secs =
      sum?.ai_feedback?.sections ||
      sum?.ai_feedback?.Sections ||
      sum?.aiFeedback?.sections ||
      sum?.sections ||
      [];
    if (!Array.isArray(secs) || !secs.length) return "";
    return `
      <details class="lux-hdetail-ai">
        <summary>🤖 Saved AI feedback (${secs.length})</summary>
        <div class="lux-hdetail-ai-body">
          ${secs
            .map((sec) => {
              const title = sec?.title || sec?.heading || "";
              const bullets = sec?.bullets || sec?.items || sec?.points || [];
              return `
              <div class="lux-ai-sec">
                ${title ? `<div class="lux-ai-sec-title">${esc(title)}</div>` : ``}
                ${
                  Array.isArray(bullets) && bullets.length
                    ? `
                  <ul class="lux-ai-bullets">
                    ${bullets.map((b) => `<li>${esc(b)}</li>`).join("")}
                  </ul>
                `
                    : ``
                }
              </div>
            `;
            })
            .join("")}
        </div>
      </details>
    `;
  }

  function attemptPills(a) {
    const sum = pickSummary(a) || {};
    const az = pickAzure(a);
    const nb = az?.NBest?.[0] || az?.nBest?.[0] || null;
    const pa =
      nb?.PronunciationAssessment ||
      nb?.pronunciationAssessment ||
      az?.PronunciationAssessment ||
      null;

    const pills = [];
    const pron = sum?.pron ?? nb?.PronScore ?? pa?.PronScore;
    const acc = sum?.acc ?? pa?.AccuracyScore;
    const flu = sum?.flu ?? pa?.FluencyScore;
    const pro = sum?.pros ?? sum?.pro ?? pa?.ProsodyScore;

    if (pron != null) pills.push(`Pron ${Math.round(Number(pron))}`);
    if (acc != null) pills.push(`Acc ${Math.round(Number(acc))}`);
    if (flu != null) pills.push(`Flu ${Math.round(Number(flu))}`);
    if (pro != null) pills.push(`Pro ${Math.round(Number(pro))}`);

    return pills.map((t) => `<span class="lux-mini-pill">${esc(t)}</span>`).join("");
  }

  function attemptOverallScore(a) {
    const sum = pickSummary(a) || {};
    if (sum.pron != null) return Number(sum.pron) || 0;

    const az = pickAzure(a);
    const v = az?.NBest?.[0]?.PronScore;
    return Number(v) || 0;
  }

  function attemptDateStr(a) {
    const ts = pickTS(a);
    const d = new Date(ts || Date.now());
    return d.toLocaleDateString(undefined, {
      month: "short",
      day: "numeric",
      hour: "2-digit",
      minute: "2-digit",
    });
  }

  host.querySelectorAll(".lux-hbtn").forEach((btn) => {
    btn.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();

      const sid = btn.getAttribute("data-sid") || "";
      if (!sid) return;

      const list = (bySession.get(sid) || [])
        .slice()
        .sort((a, b) => {
          const ta = new Date(pickTS(a) || 0).getTime();
          const tb = new Date(pickTS(b) || 0).getTime();
          return tb - ta;
        });

      const a = list[0];
      if (!a) {
        console.warn("[progress] No attempts found for sid:", sid);
        return;
      }

      const sess = (sessions || []).find((x) => String(x.sessionId) === String(sid)) || null;

      openDetailsModal(a, attemptOverallScore(a), attemptDateStr(a), {
        sid,
        list,
        session: sess,
      });
    });
  });

  // Downloads (optional)
  if (showActions) {
    const gen = document.getElementById("luxGenerateNextPractice");
    if (gen) {
      gen.addEventListener("click", () => {
        const plan = buildNextActivityPlanFromModel(model, { source: "global" });
        if (!plan) return;
        saveNextActivityPlan(plan);
        window.location.assign("./convo.html#chat");
      });
    }

    const wc = document.getElementById("luxOpenWordCloud");
    if (wc)
      wc.addEventListener("click", () => {
        window.location.assign("./wordcloud.html");
      });

    const dl = document.getElementById("luxDownloadReport");
    if (dl)
      dl.addEventListener("click", () => {
        const name = `lux-progress-${new Date().toISOString().slice(0, 10)}.json`;
        downloadBlob(name, JSON.stringify({ model }, null, 2), "application/json");
      });

    const dlT = document.getElementById("luxDownloadTrouble");
    if (dlT)
      dlT.addEventListener("click", () => {
        const name = `lux-troubleshooting-${new Date().toISOString().slice(0, 10)}.json`;
        downloadBlob(name, JSON.stringify({ attempts }, null, 2), "application/json");
      });
  }
}

function renderMetricTrendCard(m) {
  if (!m) return "";
  const fmtPct = (v) =>
    v == null || !Number.isFinite(+v) ? "—" : `${Math.round(+v)}%`;
  const best =
    m.bestDay?.avg != null ? `${m.bestDay.day} • ${fmtPct(m.bestDay.avg)}` : "—";

  return `
    <div class="lux-pcard lux-metricTrendCard">
      <div class="lux-metricTrendTop">
        <div class="lux-pcard-label">${esc(m.label)}</div>
        <div class="lux-metricTrendValue">${fmtPct(m.avg30)}</div>
      </div>
      <div class="lux-spark">${sparklineSvg(m.trend || [], { width: 240, height: 42 })}</div>
      <div class="lux-metricTrendMeta">
        <span>Last: <b>${fmtPct(m.last)}</b></span>
        <span>7d: <b>${fmtPct(m.avg7)}</b></span>
        <span>Best: <b>${best}</b></span>
      </div>
    </div>
  `;
}
</file>

<file path="index.html">
<!-- index.html (Practice Skills) -->
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Lux Pronunciation Tool</title>

    <link rel="stylesheet" href="lux-layout.css" />
    <link rel="stylesheet" href="lux-onboarding.css" />
    <link rel="stylesheet" href="lux-popover.css" />

    <link rel="stylesheet" href="lux-widgets.css" />
    <link rel="stylesheet" href="lux-results.css" />
    <link rel="stylesheet" href="lux-progress.css" />
    <link rel="stylesheet" href="lux-audio-mode.css" />


<link rel="stylesheet" href="/features/features/tts-peekaboo.css" />
<link rel="stylesheet" href="/features/my-words/my-words.css" />

    <link
      href="https://fonts.googleapis.com/css2?family=Montserrat:wght@700&display=swap"
      rel="stylesheet"
    />

    <!-- Keep only core page CSS here -->
    <link rel="stylesheet" href="./ui/ui-arrow-trail.css" />
    <link rel="stylesheet" href="./ui/warp.css" />

    <style id="lux-tts-guard-style">
      #tts-controls {
        display: none !important;
      }
    </style>

    <script type="importmap">
      {
        "imports": {
          "ai.js": "./api/ai.js",
          "./api.js": "/src/api/index.js"
        }
      }
    </script>

    <script src="lux-popover.js" defer></script>
  </head>

  <body>
    <!-- Top-of-viewport Tips Banner (fixed; tab remains clickable when collapsed) -->
    <div id="lux-top-banner" class="lux-top-banner" aria-label="Tips banner">
      <!-- This panel slides in/out -->
      <div class="lux-top-banner-panel">
        <div class="lux-top-banner-inner">
          <div id="userMsg" aria-live="polite">
            <ol>
              <li>
                We use and measure for standard American accents. Hear what it should sound like:
                <span class="lux-arrow-trail" data-arrow-trail="tts" aria-hidden="true"></span>
              </li>
              <li>
                The more recordings you make, the better the feedback will be 🤔 💭 💡 😮:
                <span class="lux-cta" tabindex="0" aria-haspopup="dialog" aria-expanded="false">
                  database tracking
                  <span class="lux-pop" role="dialog" aria-label="Database tracking details">
                    <strong style="display: block; margin-bottom: 6px">How tracking helps</strong>
                    <p style="margin: 0 0 8px; color: #444; font-size: 13px">
                      We save summaries of your practice so feedback improves over time.
                    </p>
                    <div class="lux-uidrow">
                      <span>Your UID:</span>
                      <code id="lux-uid">…</code>
                      <button id="lux-copy" class="lux-btn" type="button">Copy</button>
                      <small id="lux-copied" class="lux-copied" aria-live="polite"></small>
                    </div>
                    <div class="lux-links">
                      <a id="lux-link-attempts" target="_blank" rel="noopener">Attempts (admin)</a>
                      <a id="lux-link-progress" target="_blank" rel="noopener">User Progress (admin)</a>
                      <a id="lux-link-cohort" target="_blank" rel="noopener">Cohort (admin)</a>
                    </div>
                    <small class="lux-note">Admin token required for those pages.</small>
                  </span>
                </span>.
              </li>
              <li>Remember—mistakes are a necessary part of learning! :)</li>
            </ol>
          </div>
        </div>
      </div>

      <!-- This tab stays visible when collapsed -->
      <button type="button" class="lux-banner-handle" aria-label="Hide tips" title="Hide tips">
        <span class="lux-banner-label">Tips</span>
        <svg class="lux-banner-caret" viewBox="0 0 20 20" aria-hidden="true" focusable="false">
          <path
            d="M6 12l4-4 4 4"
            fill="none"
            stroke="currentColor"
            stroke-width="2.2"
            stroke-linecap="round"
            stroke-linejoin="round"
          />
        </svg>
      </button>
    </div>

    <div id="container">
      <h2>Practice Skills</h2>

      <div class="lux-toplinks lux-toplinks-cta">
        <a class="lux-toplink lux-toplink-cta lux-cta-same" href="./convo.html">AI Conversations</a>
      </div>

      <label>
        Select Passage:
        <select id="passageSelect" data-lux-browse-lessons>
          <option value="" disabled selected>Select Passage...</option>

          <!-- Standard Passages -->
          <option value="rainbow">Rainbow Passage</option>
          <option value="grandfather">Grandfather Passage</option>
          <option value="caterpillar">The Caterpillar</option>
          <option value="hunterScript">The Hunter Script</option>
          <option value="huntersStory">The Hunter’s Story</option>

          <option value="arthurTheRat_p1">Arthur the Rat (Part 1)</option>
          <option value="arthurTheRat_p2">Arthur the Rat (Part 2)</option>
          <option value="arthurTheRat_p3">Arthur the Rat (Part 3)</option>

          <option value="johnPassage">The John Passage</option>

          <option value="commaGetsACure_p1">Comma Gets a Cure (Part 1)</option>
          <option value="commaGetsACure_p2">Comma Gets a Cure (Part 2)</option>
          <option value="commaGetsACure_p3">Comma Gets a Cure (Part 3)</option>
          <option value="commaGetsACure_p4">Comma Gets a Cure (Part 4)</option>

          <option value="northWindAndSun">The North Wind and the Sun</option>
          <option value="bamboo">The Bamboo Passage</option>

          <option disabled>-------------------</option>

          <!-- Tests / Drills -->
          <option value="minLR">Phoneme Test: L vs R</option>
          <option value="minEEIH">Phoneme Test: EE vs IH</option>
          <option value="minAUAH">Phoneme Test: A vs U</option>
          <option value="wordList">Challenging Word List</option>
          <option value="sentences">Challenging Sentences</option>
          <option value="shortStory">Short Story Practice</option>

          <option disabled>-------------------</option>

          <option value="write-own">Write Your Own...</option>
          <option value="clear">Clear Text</option>
        </select>

        <span
          id="partsInfoTip"
          class="tooltip"
          style="margin-left: 10px; cursor: pointer; display: inline-block !important;"
        >
          (?)
          <span class="tooltiptext">These texts are designed to cover most sounds in English.</span>
        </span>
      </label>

      <!-- Harvard list picker (next to / below the main passage select) -->
      <div class="lux-harvard-picker" aria-label="Harvard sentence list picker">
        <span class="lux-harvard-label">The Harvard List</span>

        <button id="harvardPrev" type="button">◀</button>

        <label class="sr-only" for="harvardNum">Harvard list number</label>
        <input id="harvardNum" type="number" min="1" max="72" step="1" value="1" />

        <button id="harvardNext" type="button">▶</button>
        <button id="harvardLoad" type="button">Load</button>
        <button id="harvardRandom" type="button">🎲</button>

        <span id="harvardLoaded" style="margin-left: 10px; font-size: 13px; opacity: 0.75"></span>
      </div>

      <label style="display: block; margin-top: 14px">
        First language:
        <select id="l1Select" name="l1Select">
          <option value="universal" selected>Universal (English-only)</option>
          <option value="ar">Arabic – العربية</option>
          <option value="zh">Chinese – 中文</option>
          <option value="fr">French – Français</option>
          <option value="de">German – Deutsch</option>
          <option value="hi">Hindi – हिन्दी</option>
          <option value="ja">Japanese – 日本語</option>
          <option value="ko">Korean – 한국어</option>
          <option value="mr">Marathi – मराठी</option>
          <option value="pt">Portuguese – Português</option>
          <option value="ru">Russian – Русский</option>
          <option value="es">Spanish – Español</option>
        </select>
      </label>

      <span id="suggestedSentence" style="display: none"></span>

      <label style="margin-top: 20px">
        <span id="typewriterMsg" style="display: block; margin-bottom: 0.7em"></span>
        <textarea
          id="referenceText"
          placeholder="Paste or type everything you’ll read here."
          rows="3"
        ></textarea>
      </label>

      <div id="ghostControls">
        <button id="nextPartBtn">Next Part</button>
        <span id="nextPartMsg"></span>
        <button id="showSummaryBtn">Show Summary</button>
        <span id="passageLabel"></span>
        <span id="partProgress"></span>
      </div>

      <div class="btn-group">
        <button id="record" data-lux-record>
          <span class="lux-recLabel">Record</span>

          <!-- Mic level visualizer (shown only while recording) -->
          <span class="lux-recViz" aria-hidden="true">
            <span class="lux-recBar"></span>
            <span class="lux-recBar"></span>
            <span class="lux-recBar"></span>
            <span class="lux-recBar"></span>
            <span class="lux-recBar"></span>
            <span class="lux-recBar"></span>
            <span class="lux-recBar"></span>
            <span class="lux-recBar"></span>
            <span class="lux-recBar"></span>
            <span class="lux-recBar"></span>
          </span>
        </button>
        <button id="stop" disabled>Stop</button>
      </div>

      <button id="playbackBtn" style="display: none">▶ Play</button>
      <audio id="playbackAudio" hidden></audio>

      <p id="status">Not recording</p>
      <div id="prettyResult"></div>

      <details id="aiCoachDrawer" class="lux-progress-drawer lux-ai-drawer">
        <summary class="lux-progress-drawer-summary">
          <div class="lux-progress-drawer-left">
            <div class="lux-progress-drawer-title">AI Coach</div>
            <div class="lux-progress-drawer-mini">Tap to open</div>
          </div>
        </summary>

        <div class="lux-progress-drawer-body">
          <div id="aiFeedbackSection">
            <div id="aiFeedback"></div>
          </div>
        </div>
      </details>

      <button
        id="showMoreBtn"
        style="display: none; margin: 1em auto; padding: 0.7em 1.3em; font-size: 1em"
      >
        Show More
      </button>

      <!-- My Progress (mount target) -->
      <div id="dashboard-root"></div>

      <div id="ygPreview">
        <video
          id="ygDemo"
          src="https://video.wixstatic.com/video/0d5d6f_5ae77fc4972248b38eb63ea25e5068fb/720p/mp4/file.mp4"
          style="width: 100%; height: 100%; display: block; object-fit: cover"
          muted
          playsinline
          loop
          autoplay
        ></video>
        <div id="unmuteTip" style="display: none">🔊 Click to unmute</div>
      </div>

      <div id="phPreview">
        <video
          id="phDemo"
          src="https://video.wixstatic.com/video/0d5d6f_e100780f16524e51bd9c8e49f1c8c71c/480p/mp4/file.mp4"
          style="
            width: 100%;
            height: 100%;
            display: block;
            object-fit: contain;
            background: #000;
          "
          muted
          playsinline
          loop
          preload="metadata"
        ></video>
        <div id="phUnmuteTip" style="display: none">🔊 Click to toggle audio</div>
      </div>
    </div>

    <div id="tts-controls" data-luxHidden="1"></div>

    <script type="module" src="./src/main.js"></script>

    <script>
      window.typeWriter = window.typeWriter || function () {};
    </script>

    <!-- Lux FX: “Corona flare” for the AI Conversations halo (Edge-safe: use url(#filter) ONLY in CSS) -->
    <svg
      class="lux-fx"
      width="0"
      height="0"
      aria-hidden="true"
      focusable="false"
      style="position: absolute; width: 0; height: 0; overflow: hidden"
    >
      <filter
        id="luxCoronaFlare"
        x="-70%"
        y="-70%"
        width="240%"
        height="240%"
        color-interpolation-filters="sRGB"
      >
        <!-- Base “slow drift” noise -->
        <feTurbulence type="fractalNoise" baseFrequency="0.010" numOctaves="2" seed="9" result="n1">
          <animate attributeName="baseFrequency" dur="8.0s" values="0.008;0.014;0.010" repeatCount="indefinite" />
        </feTurbulence>

        <!-- Faster flicker noise (drives flare patches) -->
        <feTurbulence type="turbulence" baseFrequency="0.040" numOctaves="1" seed="4" result="n2">
          <animate attributeName="baseFrequency" dur="1.35s" values="0.028;0.055;0.034" repeatCount="indefinite" />
        </feTurbulence>

        <feComposite in="n1" in2="n2" operator="arithmetic" k1="0" k2="0.78" k3="0.38" k4="0" result="noise" />

        <!-- Thicken the ring a bit -->
        <feMorphology in="SourceGraphic" operator="dilate" radius="2.8" result="fat" />

        <!-- Extract just the outer rim so flares feel like they come from the edge -->
        <feMorphology in="fat" operator="erode" radius="4.4" result="inner" />
        <feComposite in="fat" in2="inner" operator="out" result="rim" />

        <!-- Turn noise into an alpha “flare mask” with high contrast (patchy, not uniform) -->
        <feColorMatrix in="noise" type="luminanceToAlpha" result="noiseA" />
        <feComponentTransfer in="noiseA" result="flareMask">
          <feFuncA type="table" tableValues="0 0 0 0.05 0.18 0.75 1 1" />
        </feComponentTransfer>

        <!-- Keep only rim segments selected by the flare mask -->
        <feComposite in="rim" in2="flareMask" operator="in" result="flareRim" />

        <!-- Throw those segments outward with stronger displacement -->
        <feDisplacementMap
          in="flareRim"
          in2="noise"
          scale="62"
          xChannelSelector="R"
          yChannelSelector="G"
          result="flareDisp"
        >
          <animate attributeName="scale" dur="1.55s" values="32;72;38;66;34" repeatCount="indefinite" />
        </feDisplacementMap>

        <!-- Base wobble for the whole halo (subtler than the flares) -->
        <feDisplacementMap
          in="fat"
          in2="noise"
          scale="22"
          xChannelSelector="R"
          yChannelSelector="G"
          result="baseDisp"
        >
          <animate attributeName="scale" dur="2.6s" values="14;28;18;24;16" repeatCount="indefinite" />
        </feDisplacementMap>

        <!-- Bloom layers -->
        <feGaussianBlur in="baseDisp" stdDeviation="10.5" result="baseGlow" />
        <feGaussianBlur in="flareDisp" stdDeviation="16.0" result="flareGlow">
          <animate attributeName="stdDeviation" dur="1.6s" values="12;19;13;18;12" repeatCount="indefinite" />
        </feGaussianBlur>

        <feMerge result="merged">
          <feMergeNode in="baseGlow" />
          <feMergeNode in="flareGlow" />
        </feMerge>

        <!-- Punch: saturation + alpha lift -->
        <feColorMatrix in="merged" type="saturate" values="1.75" result="sat" />
        <feColorMatrix
          in="sat"
          type="matrix"
          values="1 0 0 0 0
                  0 1 0 0 0
                  0 0 1 0 0
                  0 0 0 1.85 -0.24"
          result="out"
        />

        <feMerge>
          <feMergeNode in="out" />
          <feMergeNode in="sat" />
        </feMerge>
      </filter>
    </svg>

    <!-- Warp nav JS (near end of body) -->
    <script type="module" src="./ui/warp-nav.js"></script>
  </body>
</html>
</file>

<file path="lux-audio-mode.css">
/* lux-audio-mode.css */
/* Small Liquid-Glass Audio Mode Toggle (Normal / Pro)
   - Record/Stop stay centered
   - Toggle sits offset to the right of Stop
   - Transparent pill + sliding glass knob
*/

:root{
  --lux-blue: #0078d7;
}

/* ===============================
   Practice dock row wrapper
   (audio-mode-switch.js wraps .btn-group with this)
   =============================== */
.lux-rec-actions{
  display:flex;
  align-items:center;
  justify-content:center;
  gap:18px;
  margin: 10px auto 14px;
  flex-wrap:wrap;
}

/* Ensure the record/stop group stays clean */
.lux-rec-actions .btn-group{
  margin: 0 !important;
  position: relative;      /* allows floating toggle positioning */
  overflow: visible;       /* tooltips must not clip */
}

/* ===============================
   Wrapper + label
   =============================== */
.lux-audioModeWrap{
  display:flex;
  align-items:center;
  gap:8px;

  font: 900 11px/1 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
  letter-spacing: 0.02em;

  user-select:none;
  z-index: 50;
}

/* “Audio” label — subtle, not heavy */
.lux-audioModeLabel{
  opacity: 0.55;
  font-weight: 950;
}

/* When inserted after Stop */
.btn-group .lux-audioModeWrap.is-rightOfStop{
  margin-left: 12px;
}

/* When we float it (so it does NOT shift Record/Stop centering) */
.btn-group .lux-audioModeWrap.is-floatDock{
  position: absolute;
  margin-left: 0 !important;
}

/* ===============================
   Glass pill shell
   =============================== */
.lux-audioToggle{
  position: relative;
  display: inline-flex;
  align-items: center;

  padding: 2px;
  border-radius: 999px;

  /* ✅ transparent glass */
  background: rgba(255,255,255,0.12);
  border: 1px solid rgba(255,255,255,0.22);

  box-shadow:
    0 10px 24px rgba(0,0,0,0.14),
    inset 0 1px 0 rgba(255,255,255,0.22);

  backdrop-filter: blur(16px) saturate(1.25);
  -webkit-backdrop-filter: blur(16px) saturate(1.25);

  overflow: visible; /* ✅ bring tooltips back */
}

/* Optional tiny “premium” outline when in Pro mode */
html[data-lux-audio-mode="pro"] .lux-audioToggle{
  box-shadow:
    0 12px 28px rgba(0,0,0,0.16),
    inset 0 1px 0 rgba(255,255,255,0.22),
    0 0 0 1px rgba(0,120,215,0.10);
}

/* ===============================
   Sliding inner glass knob
   =============================== */
.lux-audioKnob{
  position:absolute;
  top: 2px;
  bottom: 2px;
  left: 2px;
  width: calc(50% - 2px);
  border-radius: 999px;
  z-index: 1;

  /* ✅ glass-on-glass (transparent) */
  background:
    radial-gradient(circle at 30% 25%,
      rgba(255,255,255,0.60),
      rgba(255,255,255,0.18) 58%,
      rgba(255,255,255,0.06)
    ),
    linear-gradient(180deg,
      rgba(255,255,255,0.34),
      rgba(255,255,255,0.10)
    );

  border: 1px solid rgba(255,255,255,0.30);

  box-shadow:
    0 8px 16px rgba(0,0,0,0.12),
    inset 0 1px 0 rgba(255,255,255,0.36);

  transition: transform 240ms cubic-bezier(.2,.9,.2,1);
  will-change: transform;

  overflow: hidden; /* keeps sheen neat */
}

/* knob slides right in pro mode */
html[data-lux-audio-mode="pro"] .lux-audioKnob{
  transform: translateX(100%);
}

/* subtle sheen streak on hover */
.lux-audioKnob::after{
  content:"";
  position:absolute;
  inset:-45% -70%;
  background: linear-gradient(
    110deg,
    rgba(255,255,255,0) 35%,
    rgba(255,255,255,0.55) 48%,
    rgba(255,255,255,0) 62%
  );
  transform: translateX(-45%) rotate(8deg);
  opacity: 0;
  pointer-events:none;
}

.lux-audioToggle:hover .lux-audioKnob::after{
  opacity: 0.70;
  animation: luxSheen 1.05s ease both;
}

@keyframes luxSheen{
  from { transform: translateX(-45%) rotate(8deg); }
  to   { transform: translateX(45%)  rotate(8deg); }
}

/* ===============================
   Buttons (must NOT look like big blue buttons)
   =============================== */
.lux-audioOpt{
  position:relative;
  z-index:2;

  appearance:none;
  border:0;
  background: transparent !important;
  box-shadow: none !important;

  padding: 6px 10px;
  border-radius: 999px;

  font-weight: 950;
  font-size: 11px;
  cursor:pointer;

  color: rgba(15,23,42,0.44); /* hollow/grey when inactive */
  transition: transform .12s ease, color .16s ease, opacity .14s ease;
}

.lux-audioOpt:hover{
  transform: translateY(-1px);
  color: rgba(15,23,42,0.70);
}

/* ✅ Active mode = Lux blue text */
html[data-lux-audio-mode="normal"] .lux-audioOpt[data-mode="NORMAL"],
html[data-lux-audio-mode="pro"] .lux-audioOpt[data-mode="PRO"]{
  color: var(--lux-blue);
  text-shadow:
    0 1px 0 rgba(255,255,255,0.25),
    0 10px 22px rgba(0,0,0,0.10);
}

/* dim the inactive one a bit */
html[data-lux-audio-mode="normal"] .lux-audioOpt[data-mode="PRO"],
html[data-lux-audio-mode="pro"] .lux-audioOpt[data-mode="NORMAL"]{
  opacity: 0.58;
}

/* ===============================
   Subtle bump confirmation
   =============================== */
.lux-audioToggle.is-bump .lux-audioKnob{
  animation: luxKnobBump 320ms ease;
}

@keyframes luxKnobBump{
  0%   { filter: brightness(1); }
  45%  { filter: brightness(1.18); }
  100% { filter: brightness(1); }
}

/* ===============================
   Tooltip bubbles (DOM version)
   =============================== */

.lux-audioOpt{
  position: relative; /* anchor tooltip */
}

.lux-audioTip{
  position: absolute;
  left: 50%;
  transform: translateX(-50%);
  bottom: calc(100% + 10px);

  width: min(340px, 64vw);
  padding: 10px 12px;
  border-radius: 14px;

  background: rgba(15, 23, 42, 0.92);
  color: rgba(255, 255, 255, 0.95);

  box-shadow: 0 14px 34px rgba(0,0,0,0.30);

  opacity: 0;
  pointer-events: none;
  transition: opacity 140ms ease, transform 140ms ease;

  z-index: 999;
}

.lux-audioOpt:hover .lux-audioTip{
  opacity: 1;
  transform: translateX(-50%) translateY(-1px);
}

/* headline line */
.lux-audioTipTitle{
  font-weight: 900;
  font-size: 13px;
  margin-bottom: 6px;
}

/* bullets slightly smaller */
.lux-audioTipList{
  margin: 0;
  padding-left: 18px;
  font-weight: 750;
  font-size: 11.5px;
  opacity: 0.95;
}

.lux-audioTipList li{
  margin: 2px 0;
}

/* environment line */
.lux-audioTipEnv{
  margin-top: 7px;
  font-weight: 750;
  font-size: 11.5px;
  opacity: 0.88;
}

/* motion accessibility */
@media (prefers-reduced-motion: reduce){
  .lux-audioKnob,
  .lux-audioOpt{
    transition: none !important;
  }
  .lux-audioToggle:hover .lux-audioKnob::after{
    animation: none !important;
  }
}
</file>

<file path="lux-widgets.css">
/* lux-widgets.css (entry wrapper) */
@import "./lux-widgets.core.css";
@import "./lux-widgets.table.css";              /* ✅ restores score-table grid */
@import "./lux-widgets.buttons.css";
@import "./lux-widgets.score-tiles.css";
@import "./lux-widgets.metric-modal.css";
@import "./lux-widgets.results-panels.css";
@import "./lux-widgets.record-viz.css";
</file>

<file path="features/features/selfpb/ui.js">
// features/features/selfpb/ui.js
// FINAL PIVOT: Using WaveSurfer.js for reliable waveforms.

import { initSelfPBCore } from "./core.js";
import { initWaveSurfer } from "./waveform-logic.js";
import { ensureStyles } from "./styles.js";
import { buildUI } from "./dom.js";

export function mountSelfPlaybackLite() {
  const { api, audio, refAudio, st } = initSelfPBCore();

  ensureStyles();
  const ui = buildUI();

  // Initialize WaveSurfer
  initWaveSurfer({
    learnerContainer: ui.waveLearner,
    refContainer: ui.waveRef,
    masterAudio: audio,
  });

  // ✅ Download Latest Recording button wiring
  const dlBtn = ui.dlBtn;
  let _lastBlob = null;
  let _lastMeta = null;

  function extFromBlob(blob) {
    const t = blob?.type || "";
    if (t.includes("wav")) return "wav";
    if (t.includes("webm")) return "webm";
    if (t.includes("ogg")) return "ogg";
    return "audio";
  }

  function downloadBlob(blob, meta) {
    if (!blob) return;

    const mode = (meta?.mode || "normal").toLowerCase();
    const ts = new Date(meta?.ts || Date.now())
      .toISOString()
      .replaceAll(":", "-")
      .replaceAll(".", "-");

    const ext = extFromBlob(blob);
    const name = `lux-recording_${mode}_${ts}.${ext}`;

    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = name;
    document.body.appendChild(a);
    a.click();
    a.remove();

    setTimeout(() => URL.revokeObjectURL(url), 1500);
  }

  function setLatest(blob, meta) {
    _lastBlob = blob || null;
    _lastMeta = meta || null;

    if (dlBtn) {
      dlBtn.disabled = !_lastBlob;
      dlBtn.title = _lastBlob
        ? "Download your latest recording"
        : "Record something first";
    }
  }

  if (dlBtn) {
    dlBtn.addEventListener("click", () => {
      if (!_lastBlob) return;
      downloadBlob(_lastBlob, _lastMeta);
    });
  }

  // Pull from global if it exists already
  if (window.LuxLastRecordingBlob) {
    setLatest(window.LuxLastRecordingBlob, window.LuxLastRecordingMeta || null);
  }

  // Listen for new recordings
  window.addEventListener("lux:lastRecording", (e) => {
    setLatest(e?.detail?.blob, e?.detail?.meta || null);
  });

  // --- Logic helpers ---
  const showToast = (msg, duration = 2000) => {
    ui.toast.textContent = msg;
    ui.toast.style.display = "inline-block";
    ui.host.animate(
      [
        { transform: "translateX(0)" },
        { transform: "translateX(-4px)" },
        { transform: "translateX(4px)" },
        { transform: "translateX(0)" },
      ],
      { duration: 200 }
    );
    setTimeout(() => {
      ui.toast.style.display = "none";
    }, duration);
  };

  const showLoopHint = () => {
    if (localStorage.getItem("spb-hint-seen") !== "true") {
      ui.loopTip.classList.add("visible");
      setTimeout(() => {
        ui.loopTip.classList.remove("visible");
        localStorage.setItem("spb-hint-seen", "true");
      }, 4000);
    }
  };

  const syncButtons = () => {
    ui.mainBtn.textContent = st.playing ? "⏸ Pause" : "▶ Play";

    if (st.a == null) {
      ui.loopAction.textContent = "⟳ Set Loop A";
      ui.loopAction.classList.remove("active");
      ui.abLabel.textContent = "Loop: Off";
    } else if (st.b == null) {
      ui.loopAction.textContent = "⟳ Set Loop B";
      ui.loopAction.classList.add("active");
      ui.abLabel.textContent = `A: ${api.fmt(st.a)} …`;
    } else {
      ui.loopAction.textContent = "× Clear Loop";
      ui.loopAction.classList.remove("active");
      ui.abLabel.textContent = `A: ${api.fmt(st.a)}  B: ${api.fmt(st.b)}`;
    }
  };

  const syncTime = () => {
    ui.timeLab.textContent = `${api.fmt(audio.currentTime || 0)} / ${api.fmt(
      audio.duration || 0
    )}`;
  };

  const syncScrub = () => {
    if (!st.scrubbing) {
      const dur = audio.duration || 0;
      const p = dur ? Math.floor((audio.currentTime / dur) * 1000) : 0;
      ui.scrub.value = String(api.clamp(p, 0, 1000));
    }
  };

  /* ============================================================
     ✅ Karaoke Timeline (Expanded-only)
     - words are positioned across time
     - fill + active highlight during playback
     - click word = seek
     - click lane = jump to time
     ============================================================ */

  let kWords = [];
  let kEls = [];
  let kDur = 0;
  let kLinesUsed = 1;

  let kCenterEls = [];
  let _centerActiveIdx = -1;

  const isExpandedOpen = () => {
    const shade = document.getElementById("spb-modalShade");
    if (shade?.classList?.contains("is-open")) return true;

    const float = document.getElementById("spb-float");
    if (float?.classList?.contains("is-open")) return true;

    return false;
  };

  const clamp01 = (v) => Math.max(0, Math.min(1, v));

  function getKaraokeDuration(words) {
    const ad = audio.duration || 0;
    if (ad > 0) return ad;
    const last = words?.[words.length - 1];
    return last?.end || 0;
  }

  function seekTo(sec) {
    if (!isFinite(sec)) return;
    const dur = audio.duration || kDur || 0;
    if (!dur) return;

    audio.currentTime = api.clamp(sec, 0, dur);
    syncTime();
    syncScrub();
  }

  function renderKaraokeCenter(words) {
    if (!ui.kCenterTrack) return;

    ui.kCenterTrack.innerHTML = "";
    kCenterEls = [];

    for (let i = 0; i < words.length; i++) {
      const w = words[i];

      const el = document.createElement("span");
      el.className = "spbKCWord";
      el.textContent = w.word;

      if (typeof w.acc === "number" && w.acc < 60) el.classList.add("is-bad");

      el.style.setProperty("--p", "0");

      el.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        seekTo((w.start || 0) + 0.001);
      });

      ui.kCenterTrack.appendChild(el);
      kCenterEls.push(el);
    }

    // center at current time initially
    _centerActiveIdx = -1;
    updateKaraokeCenterAt(audio.currentTime || 0);
  }

  function centerToWord(idx) {
    if (!ui.kCenterWrap || !ui.kCenterTrack) return;
    const el = kCenterEls[idx];
    if (!el) return;

    const wrapW = ui.kCenterWrap.clientWidth;
    const trackW = ui.kCenterTrack.scrollWidth;

    if (trackW <= wrapW) {
      // center whole track if short
      const mid = (wrapW - trackW) / 2;
      ui.kCenterTrack.style.transform = `translateX(${mid}px)`;
      return;
    }

    const wordCenter = el.offsetLeft + el.offsetWidth / 2;
    let target = wrapW / 2 - wordCenter;

    const min = wrapW - trackW; // most negative
    const max = 0;

    if (target < min) target = min;
    if (target > max) target = max;

    ui.kCenterTrack.style.transform = `translateX(${target}px)`;
  }

  function updateKaraokeCenterAt(t) {
    if (!kWords.length || !kCenterEls.length) return;

    let activeIdx = -1;

    for (let i = 0; i < kWords.length; i++) {
      const w = kWords[i];
      const el = kCenterEls[i];
      if (!el) continue;

      const span = Math.max(0.001, w.end - w.start);
      const p = clamp01((t - w.start) / span);
      el.style.setProperty("--p", String(p));

      if (t >= w.start && t < w.end) activeIdx = i;
    }

    for (let i = 0; i < kCenterEls.length; i++) {
      const el = kCenterEls[i];
      el.classList.toggle("is-active", i === activeIdx);
      el.classList.toggle("is-past", activeIdx !== -1 && i < activeIdx);
      el.classList.toggle("is-future", activeIdx !== -1 && i > activeIdx);
    }

    // smooth auto-center only when active word changes
    if (activeIdx !== -1 && activeIdx !== _centerActiveIdx) {
      _centerActiveIdx = activeIdx;
      centerToWord(activeIdx);
    }
  }

  function renderKaraoke(words) {
    if (!ui.karaokeLane || !ui.karaokeLaneWrap) return;

    ui.karaokeLane.innerHTML = "";
    kEls = [];

    kWords = Array.isArray(words) ? words : [];
    kDur = getKaraokeDuration(kWords);

    for (let i = 0; i < kWords.length; i++) {
      const w = kWords[i];

      const el = document.createElement("button");
      el.type = "button";
      el.className = "spbKWord";
      el.textContent = w.word;
      el.title = `${w.word} • ${w.start.toFixed(2)}s → ${w.end.toFixed(2)}s`;

      if (typeof w.acc === "number") {
        if (w.acc < 60) el.classList.add("is-bad");
        if (w.acc >= 90) el.classList.add("is-great");
      }

      el.style.setProperty("--p", "0");

      el.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();

        // keep play state; just move time
        seekTo((w.start || 0) + 0.001);
      });

      ui.karaokeLane.appendChild(el);
      kEls.push(el);
    }

    layoutKaraoke();
    updateKaraokeAt(audio.currentTime || 0);
    renderKaraokeCenter(kWords);
  }

  function layoutKaraoke() {
    if (!ui.karaokeLaneWrap || !ui.karaokeLane) return;
    if (!kWords.length || !kEls.length) return;

    const wrap = ui.karaokeLaneWrap;
    const lane = ui.karaokeLane;

    const W = wrap.clientWidth - 16; // inset padding
    if (W <= 10) return;

    const dur = kDur || audio.duration || 0;
    if (!dur) return;

    const ROW_H = 26;
    const GAP = 8;
    const MAX_LINES = 3;

    const lineEnds = new Array(MAX_LINES).fill(0);
    let maxLine = 0;

    for (let i = 0; i < kWords.length; i++) {
      const w = kWords[i];
      const el = kEls[i];
      if (!el) continue;

      const startP = clamp01(w.start / dur);
      const endP = clamp01(w.end / dur);

      let x = startP * W;
      let ww = Math.max(28, (endP - startP) * W); // min width

      // pick a line that doesn't overlap
      let line = 0;
      while (line < MAX_LINES && x < (lineEnds[line] + GAP)) line++;
      if (line >= MAX_LINES) line = MAX_LINES - 1;

      lineEnds[line] = x + ww;
      maxLine = Math.max(maxLine, line);

      el.style.left = `${8 + x}px`;
      el.style.top = `${8 + line * ROW_H}px`;
      el.style.width = `${ww}px`;
    }

    kLinesUsed = maxLine + 1;
    wrap.style.height = `${Math.max(76, 16 + kLinesUsed * ROW_H)}px`;
  }

  function updateKaraokeAt(t) {
    if (!ui.karaokeCursor || !kWords.length || !kEls.length) return;

    const dur = kDur || audio.duration || 0;
    if (!dur) return;

    // cursor
    const pct = clamp01(t / dur) * 100;
    ui.karaokeCursor.style.left = `${pct}%`;

    // word fill + active
    let active = -1;

    for (let i = 0; i < kWords.length; i++) {
      const w = kWords[i];
      const el = kEls[i];
      if (!el) continue;

      const span = Math.max(0.001, w.end - w.start);
      const p = clamp01((t - w.start) / span);
      el.style.setProperty("--p", String(p));

      if (t >= w.start && t < w.end) active = i;
    }

    for (let i = 0; i < kEls.length; i++) {
      kEls[i].classList.toggle("is-active", i === active);
    }
  }

  // click lane (empty space) to jump
  ui.karaokeLaneWrap?.addEventListener("click", (e) => {
    if (!isExpandedOpen()) return;
    const dur = kDur || audio.duration || 0;
    if (!dur) return;

    const r = ui.karaokeLaneWrap.getBoundingClientRect();
    const p = clamp01((e.clientX - r.left) / Math.max(1, r.width));
    seekTo(p * dur);
  });

  // refresh on expanded open
  window.addEventListener("lux:selfpbExpandedOpen", () => {
    const words = window.LuxLastWordTimings || [];
    renderKaraoke(words);
  });

  // refresh when a new assessment comes in (even if expanded is already open)
  window.addEventListener("lux:lastAssessment", (e) => {
    const words = e?.detail?.timings || window.LuxLastWordTimings || [];
    if (isExpandedOpen()) renderKaraoke(words);
  });

  // keep layout stable on resize
  window.addEventListener("resize", () => {
    if (!isExpandedOpen()) return;
    layoutKaraoke();

    if (isExpandedOpen() && _centerActiveIdx !== -1) centerToWord(_centerActiveIdx);
  });

  const syncRateUI = () => {
    ui.rateVal.textContent = `${Number(audio.playbackRate).toFixed(2)}×`;
    ui.rate.value = String(audio.playbackRate || 1);
  };

  const syncRefUI = () => {
    const ready = !!refAudio.src;
    const r = refAudio.playbackRate || 1;
    const d = isFinite(refAudio.duration) ? api.fmt(refAudio.duration) : "—:—";
    const meta = api.getRefMeta();
    const v = meta && (meta.voice || meta.style) ? ` ${meta.voice || ""}` : "";
    ui.refLabel.textContent = ready ? `Ref: ${r.toFixed(2)}× · ${d}${v}` : "Ref: —";
  };

  const handlePlayAction = async (isRestart = false) => {
    if (!audio.currentSrc && !audio.src) {
      showToast("No recording yet!");
      return;
    }
    if (audio.duration === 0 || isNaN(audio.duration)) {
      showToast("Audio empty/loading...");
      return;
    }

    try {
      if (isRestart) {
        audio.currentTime = st.looping && st.a != null ? st.a : 0;
        if (!st.playing) await api.play();
      } else {
        if (st.playing) {
          api.pause();
        } else {
          if (st.looping && st.a != null && st.b != null && st.b > st.a) {
            if (audio.currentTime < st.a || audio.currentTime > st.b)
              audio.currentTime = st.a;
          }
          await api.play();
        }
      }
    } catch (err) {
      console.warn("[selfpb] Play failed", err);
      showToast("Playback failed");
    } finally {
      syncButtons();
    }
  };

  const handleLoopClick = () => {
    if (!audio.duration) {
      showToast("No audio to loop!");
      return;
    }

    if (st.a == null) {
      st.a = audio.currentTime || 0;
      st.looping = false;
      showLoopHint();
    } else if (st.b == null) {
      st.b = audio.currentTime || 0;
      if (st.b < st.a) {
        const t = st.a;
        st.a = st.b;
        st.b = t;
      }
      st.looping = true;
      audio.currentTime = st.a;
      if (!st.playing) api.play();
    } else {
      api.clearAB();
    }

    syncButtons();
  };

  ui.mainBtn.addEventListener("click", (e) => {
    if (e.detail !== 2) handlePlayAction(false);
  });

  ui.mainBtn.addEventListener("dblclick", (e) => {
    e.preventDefault();
    handlePlayAction(true);
  });

  // 2.0 seconds skip
  ui.backBtn.addEventListener("click", () => {
    audio.currentTime = api.clamp(
      (audio.currentTime || 0) - 2.0,
      0,
      audio.duration || 0
    );
    syncTime();
    syncScrub();
  });

  ui.fwdBtn.addEventListener("click", () => {
    audio.currentTime = api.clamp(
      (audio.currentTime || 0) + 2.0,
      0,
      audio.duration || 0
    );
    syncTime();
    syncScrub();
  });

  // ✅ If user grabs scrubber while playing -> PAUSE (pro behavior)
  ui.scrub.addEventListener("pointerdown", () => {
    if (!audio.paused) {
      audio.pause();
    }
  });

  ui.scrub.addEventListener("input", () => {
    api._setScrubbingOn();
    const p = Number(ui.scrub.value) / 1000;
    audio.currentTime = api.clamp(p * (audio.duration || 0), 0, audio.duration || 0);
    syncTime();

    if (isExpandedOpen()) updateKaraokeAt(audio.currentTime || 0);
    if (isExpandedOpen()) updateKaraokeCenterAt(audio.currentTime || 0);
  });

  ui.scrub.addEventListener("change", () => api._setScrubbingOff());

  ui.rate.addEventListener("input", () => {
    const v = api.clamp(Number(ui.rate.value) || 1, 0.5, 1.5);
    api.setRate(v);
    syncRateUI();
  });

  ui.loopAction.addEventListener("click", handleLoopClick);

  audio.addEventListener("timeupdate", () => {
    syncTime();
    syncScrub();
    if (isExpandedOpen()) updateKaraokeAt(audio.currentTime || 0);
    if (isExpandedOpen()) updateKaraokeCenterAt(audio.currentTime || 0);
  });
  audio.addEventListener("play", () => {
    st.playing = true;
    syncButtons();
  });
  audio.addEventListener("pause", () => {
    st.playing = false;
    syncButtons();
  });
  audio.addEventListener("loadedmetadata", () => {
    syncTime();
    syncScrub();
  });
  audio.addEventListener("ratechange", syncRateUI);
  audio.addEventListener("ended", () => {
    st.playing = false;
    syncButtons();
  });

  refAudio.addEventListener("loadedmetadata", syncRefUI);
  refAudio.addEventListener("ratechange", syncRefUI);

  // Shortcuts logic (unchanged)
  window.addEventListener(
    "keydown",
    (e) => {
      if (
        e.target.tagName === "INPUT" ||
        e.target.tagName === "TEXTAREA" ||
        e.target.isContentEditable
      )
        return;

      if (e.code === "Space") {
        e.preventDefault();
        ui.mainBtn.click();
      } else if (e.key === ",") {
        e.preventDefault();
        ui.backBtn.click();
      } else if (e.key === ".") {
        e.preventDefault();
        ui.fwdBtn.click();
      } else if (e.key === "[") {
        e.preventDefault();
        api.setRate(api.clamp((audio.playbackRate || 1) - 0.05, 0.5, 1.5));
        syncRateUI();
      } else if (e.key === "]") {
        e.preventDefault();
        api.setRate(api.clamp((audio.playbackRate || 1) + 0.05, 1.5, 0.5));
        syncRateUI();
      } else if (e.key.toLowerCase() === "l") {
        e.preventDefault();
        ui.loopAction.click();
      }
    },
    { passive: false }
  );

  initialSync();
  window.LuxSelfPB = Object.assign(window.LuxSelfPB || {}, { el: ui.host });
  console.info("[self-pb] WaveSurfer UI Mounted");

  function initialSync() {
    syncTime();
    syncScrub();
    syncButtons();
    syncRefUI();
  }
}

export { mountSelfPlaybackLite as default };
</file>

<file path="features/my-words/my-words.css">
/* features/my-words/my-words.css */

.lux-mw-trigger{
  display:inline-flex;
  align-items:center;
  justify-content:center;
  gap:8px;
  padding:8px 12px;
  border-radius:999px;
  border:1px solid rgba(0,0,0,.10);
  background: rgba(255,255,255,.82);
  box-shadow: 0 6px 18px rgba(0,0,0,.08);
  cursor:pointer;
  font-weight:600;
  font-size:13px;
  line-height:1;
  white-space:nowrap;
  user-select:none;
}

.lux-mw-trigger:hover{
  background: rgba(255,255,255,.96);
}

.lux-mw-trigger.is-open{
  border-color: rgba(0,0,0,.18);
}

.lux-mw-panel{
  position: fixed;
  left: 18px;
  right: auto;
  bottom: 18px;
  top: auto;

  width: min(480px, 40vw);
  max-width: 92vw;
  height: 75vh;
  max-height: calc(100vh - 120px);

  border-radius: 18px;
  border: 1px solid rgba(0,0,0,.10);
  background: rgba(255,255,255,.86);
  backdrop-filter: blur(12px);
  -webkit-backdrop-filter: blur(12px);

  box-shadow: 0 18px 40px rgba(0,0,0,.16);
  overflow: hidden;
  z-index: 9999;

  opacity: 0;
  transform: translateX(22px);
  pointer-events: none;
  transition: opacity 160ms ease, transform 160ms ease;
}

.lux-mw-panel.is-open{
  opacity: 1;
  transform: translateX(0);
  pointer-events: auto;
}

.lux-mw-head{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
  padding:12px 12px 10px 12px;
  border-bottom:1px solid rgba(0,0,0,.08);
}

.lux-mw-title{
  font-weight:800;
  font-size:14px;
  letter-spacing:.2px;
}

.lux-mw-headRight{
  display:flex;
  align-items:center;
  gap:8px;
}

/* ✅ PHASE 5 — Active / Archived tabs (modal) */
.lux-mw-tabs{
  display:flex;
  align-items:center;
  gap:6px;
  padding:6px;
  border-radius:999px;
  background: rgba(255,255,255,.65);
  border: 1px solid rgba(0,0,0,.08);
}

.lux-mw-tab{
  border:0;
  background:transparent;
  font-weight:900;
  font-size:12px;
  padding:6px 10px;
  border-radius:999px;
  cursor:pointer;
}

.lux-mw-tab.is-active{
  background: rgba(0,0,0,.08);
}

/* ✅ NEW: badge count pill */
.lux-mw-badge{
  display:inline-flex;
  align-items:center;
  justify-content:center;
  min-width: 20px;
  height: 18px;
  padding: 0 6px;
  margin-left: 6px;
  border-radius: 999px;
  font-size: 11px;
  font-weight: 900;
  background: rgba(15,23,42,.10);
}

.lux-mw-search{
  width: 170px;
  max-width: 34vw;
  border-radius: 999px;
  border: 1px solid rgba(0,0,0,.10);
  padding: 7px 10px;
  font-size: 12px;
  outline: none;
  background: rgba(255,255,255,.85);
}

/* ✅ 10) Bigger, more prominent search in Library */
.lux-mw-panel.is-modal .lux-mw-search {
  width: 280px;
  font-size: 14px;
  padding: 9px 12px;
}

.lux-mw-iconBtn{
  width: 32px;
  height: 32px;
  border-radius: 10px;
  border: 1px solid rgba(0,0,0,.10);
  background: rgba(255,255,255,.85);
  cursor:pointer;
}

/* ✅ flex scroll fix: required for overflow children to behave */
.lux-mw-body{
  display:flex;
  flex-direction:column;
  height: calc(100% - 55px);
  min-height: 0;   /* ✅ critical for overflow children */
}

.lux-mw-add{
  padding: 12px;
  border-bottom: 1px solid rgba(0,0,0,.08);
}

.lux-mw-addLabel{
  font-weight:700;
  font-size:12px;
  margin-bottom:8px;
  opacity:.9;
}

/* ✅ UPDATED: textarea max-height + vertical resize + overflow */
.lux-mw-addBox{
  width:100%;
  resize: vertical;
  max-height: 140px;
  overflow: auto;

  border-radius: 14px;
  border:1px solid rgba(0,0,0,.10);
  background: rgba(255,255,255,.92);
  padding: 10px 12px;
  outline:none;
  font-size: 13px;
  line-height: 1.25;
}

.lux-mw-addRow{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
  margin-top:10px;
}

.lux-mw-addBtn{
  padding: 8px 12px;
  border-radius: 999px;
  border:1px solid rgba(0,0,0,.10);
  background: rgba(255,255,255,.92);
  cursor:pointer;
  font-weight:700;
  font-size: 12px;
}

.lux-mw-hint{
  font-size: 11px;
  opacity: .72;
}

/* ✅ allow scrolling to reach last items */
.lux-mw-list{
  padding: 10px 12px 12px 12px;
  overflow:auto;
  flex: 1;
  min-height: 0;   /* ✅ allows scrolling to bottom */
}

.lux-mw-empty{
  padding: 16px 12px;
  border-radius: 14px;
  border: 1px dashed rgba(0,0,0,.18);
  background: rgba(255,255,255,.62);
}

.lux-mw-empty strong{
  display:block;
  margin-bottom:6px;
}

.lux-mw-row{
  display:flex;
  gap:10px;
  padding: 10px 10px;
  border-radius: 14px;
  border: 1px solid rgba(0,0,0,.08);
  background: rgba(255,255,255,.78);
  margin-bottom: 10px;
}

.lux-mw-dot{
  width: 10px;
  height: 10px;
  border-radius: 999px;
  margin-top: 4px;
  background: rgba(100,100,100,.35);
  flex: 0 0 auto;
}

.lux-mw-main{
  flex:1 1 auto;
  min-width:0;
}

.lux-mw-text{
  font-weight:800;
  font-size: 13px;
  line-height:1.15;
  overflow:hidden;
  text-overflow:ellipsis;
  white-space:nowrap;
}

.lux-mw-meta{
  font-size: 11px;
  opacity: .72;
  margin-top: 4px;
}

/* --- My Words action buttons: compact + rounded, no jitter --- */
.lux-mw-actions{
  display:grid;
  grid-template-columns: repeat(var(--mw-cols, 2), 1fr);
  gap: 0;
  border-radius: 14px;
  overflow: hidden;
  border: 1px solid rgba(0,0,0,.08);
  background: rgba(255,255,255,.65);
  flex: 0 0 auto;
}

.lux-mw-act{
  appearance: none;
  border: 0;
  margin: 0;
  padding: 10px 10px;
  font-weight: 800;
  font-size: 12px;
  cursor: pointer;
  background: rgba(255,255,255,.82);
}

/* ✅ kill global hover transforms that cause flicker */
.lux-mw-act:hover{
  transform: none !important;
  filter: brightness(0.98);
}

.lux-mw-act:active{
  transform: scale(0.99) !important;
}

.lux-mw-act:nth-child(odd){
  border-right: 1px solid rgba(0,0,0,.08);
}

.lux-mw-act:nth-child(-n+2){
  border-bottom: 1px solid rgba(0,0,0,.08);
}

.lux-mw-flash{
  outline: 2px solid rgba(0,0,0,.18);
  box-shadow: 0 0 0 5px rgba(0,0,0,.06);
  transition: box-shadow 200ms ease;
}

/* --- Global corner launcher (triangle) --- */
.lux-mw-corner {
  position: fixed;
  left: 14px;
  bottom: 14px;
  width: 62px;
  height: 62px;
  z-index: 9999;
  border: none;
  background: transparent;
  cursor: pointer;
  padding: 0;
}

/* ✅ triangle-shaped shadow */
.lux-mw-corner::before {
  content: "";
  position: absolute;
  inset: 0;
  background: var(--lux-blue-primary, #0078d7);

  clip-path: polygon(0 0, 0 100%, 100% 100%);
  border-radius: 0;

  filter: drop-shadow(0 10px 22px rgba(2, 6, 23, 0.22));
}

.lux-mw-corner:hover::before {
  filter: drop-shadow(0 10px 22px rgba(2, 6, 23, 0.22)) brightness(1.05);
}

.lux-mw-corner.is-open::before {
  background: #1d4ed8;
}

.lux-mw-corner-ink {
  position: absolute;
  left: 14px;
  bottom: 14px;
  font-size: 20px;
  color: white;
  user-select: none;
}

/* --- Modal overlay library --- */
.lux-mw-modal {
  position: fixed;
  inset: 0;
  z-index: 10000;
  display: none;
  align-items: center;
  justify-content: center;
  background: rgba(15, 23, 42, 0.48);
}

.lux-mw-modal.is-open {
  display: flex;
  animation: luxMwOverlayIn 160ms ease;
}

@keyframes luxMwOverlayIn{
  from { opacity: 0; }
  to   { opacity: 1; }
}

.lux-mw-modal-card {
  width: min(920px, 92vw);
  height: 86vh;
  border-radius: 18px;
  background: white;
  box-shadow: 0 20px 60px rgba(2, 6, 23, 0.25);
  overflow: hidden;
  padding: 10px;

  animation: luxMwCardIn 180ms ease;
}

@keyframes luxMwCardIn{
  from { opacity: 0; transform: translateY(10px) scale(0.99); }
  to   { opacity: 1; transform: translateY(0) scale(1); }
}

/* ✅ NEW: modal head helper (if your modal uses a separate header wrapper) */
.lux-mw-modalHead{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:12px;
  padding:12px 12px 10px 12px;
  border-bottom:1px solid rgba(0,0,0,.08);
}

/* Make panel fill modal card cleanly */
.lux-mw-panel.is-modal {
  position: relative !important;
  inset: auto !important;
  width: 100% !important;
  height: 100% !important;
  max-height: none !important;
  box-shadow: none !important;
  border-radius: 16px !important;
}

/* --- Status dots (match Lux colors) --- */
.lux-mw-dot {
  width: 10px;
  height: 10px;
  border-radius: 99px;
  display: inline-block;
  flex: 0 0 auto;
  margin-top: 6px;
}

.lux-mw-dot.mw-good { background: #2563eb; }
.lux-mw-dot.mw-warn { background: #d97706; }
.lux-mw-dot.mw-bad { background: #dc2626; }
.lux-mw-dot.mw-new,
.lux-mw-dot.mw-unknown { background: #94a3b8; }

/* View all button */
.lux-mw-viewAllBtn {
  width: 100%;
  margin-top: 10px;
  padding: 10px 12px;
  border-radius: 12px;
  border: 1px solid rgba(148,163,184,.45);
  background: #f8fafc;
  font-weight: 700;
  cursor: pointer;
}
.lux-mw-viewAllBtn:hover { filter: brightness(1.01); }
</file>

<file path="features/my-words/panel.js">
// features/my-words/panel.js
// Phase 5: Library Modal + Active/Archived tabs + badge counts
// - Includes "View Library (N)" button in compact mode
// - Modal overlay
// - Tabs (Active / Archived) + badges
// - Archived actions: Send / WR / Restore / Delete
// - NO Copy (removed)

import { applyMyWordsStats } from "./stats.js";
import { normalizeText } from "./normalize.js";

function esc(s) {
  return String(s ?? "")
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#39;");
}

function relTime(iso) {
  if (!iso) return "—";
  const t = new Date(iso).getTime();
  if (!Number.isFinite(t)) return "—";
  const d = Date.now() - t;

  const sec = Math.floor(d / 1000);
  if (sec < 60) return `${sec}s ago`;

  const min = Math.floor(sec / 60);
  if (min < 60) return `${min}m ago`;

  const hr = Math.floor(min / 60);
  if (hr < 48) return `${hr}h ago`;

  const day = Math.floor(hr / 24);
  return `${day}d ago`;
}

function openWordReference(text) {
  const q = String(text || "").trim();
  if (!q) return;
  const url = `https://www.wordreference.com/definition/${encodeURIComponent(q)}`;
  window.open(url, "_blank", "noopener,noreferrer");
}

// ✅ 1) Youglish helper
function openYouglish(text) {
  const q = String(text || "").trim();
  if (!q) return;
  const url = `https://youglish.com/pronounce/${encodeURIComponent(q)}/english`;
  window.open(url, "_blank", "noopener,noreferrer");
}

export function mountMyWordsPanel({
  store,
  getAttempts,
  onSendToInput,

  mode = "compact", // "compact" | "library"
  maxPreview = 5,

  mountTo = document.body,
  asModal = false,

  onOpenLibrary,
  onCloseLibrary,
  onCoach,
} = {}) {
  // ------------------------------------------------------------
  // Root panel
  // ------------------------------------------------------------
  const root = document.createElement("div");
  root.className = "lux-mw-panel" + (asModal ? " is-modal" : "");
  mountTo.appendChild(root);

  // Local UI state (tab mode)
  let tab = "active"; // "active" | "archived"

  root.innerHTML = `
    <div class="${asModal ? "lux-mw-modalHead" : "lux-mw-head"}">
      <div class="lux-mw-title">My Words</div>

      <div class="lux-mw-headRight">
        <div class="lux-mw-tabs">
          <button class="lux-mw-tab is-active" data-tab="active" type="button">
            Active <span class="lux-mw-badge" data-badge="active">0</span>
          </button>
          <button class="lux-mw-tab" data-tab="archived" type="button">
            Archived <span class="lux-mw-badge" data-badge="archived">0</span>
          </button>
        </div>

        <input class="lux-mw-search" type="text" placeholder="Search…" />
        <button class="lux-mw-iconBtn" data-act="close" type="button" title="Close">×</button>
      </div>
    </div>

    <div class="lux-mw-body">
      <div class="lux-mw-add" data-zone="composer">
        <div class="lux-mw-addLabel">Add words/phrases (one per line)</div>
        <textarea class="lux-mw-addBox" rows="3" spellcheck="false"></textarea>

        <div class="lux-mw-addRow">
          <button class="lux-mw-addBtn" type="button">Add</button>
          <div class="lux-mw-hint">Tip: Tap <b>Send</b> to push into the input instantly.</div>
        </div>
      </div>

      <div class="lux-mw-list"></div>
    </div>
  `;

  const elTitle = root.querySelector(".lux-mw-title");
  const elSearch = root.querySelector(".lux-mw-search");
  const elClose = root.querySelector('button[data-act="close"]');
  const elTa = root.querySelector(".lux-mw-addBox");
  const elAdd = root.querySelector(".lux-mw-addBtn");
  const elList = root.querySelector(".lux-mw-list");
  const elTabs = root.querySelector(".lux-mw-tabs");
  const elBadgeActive = root.querySelector('[data-badge="active"]');
  const elBadgeArchived = root.querySelector('[data-badge="archived"]');
  const elComposerZone = root.querySelector('[data-zone="composer"]');

  function buildMeta(e) {
    const attempts = e.mw_attempts || 0;
    const score = e.mw_lastScore;
    const lastScoreStr = score == null ? "—" : `${Math.round(score)}%`;
    const lastAtStr = relTime(e.mw_lastAt);
    const trend = e.mw_trend || "—";
    return `Practiced ${attempts}× · Last ${lastScoreStr} ${trend} · ${lastAtStr}`;
  }

  function computeCountsAll() {
    const all = store.getState().entries || [];
    const activeTotal = all.filter((e) => !e.archived).length;
    const archivedTotal = all.filter((e) => !!e.archived).length;
    return { activeTotal, archivedTotal, total: all.length };
  }

  function setTab(nextTab) {
    tab = nextTab === "archived" ? "archived" : "active";

    root.querySelectorAll(".lux-mw-tab").forEach((b) => {
      const is = b.dataset.tab === tab;
      b.classList.toggle("is-active", is);
    });

    // Composer only makes sense on Active (and never in modal/library)
    const isModal = root.classList.contains("is-modal");
    if (elComposerZone) {
      if (isModal) elComposerZone.style.display = "none";
      else elComposerZone.style.display = tab === "active" ? "" : "none";
    }

    render();
  }

  function entryRowHTML(e, isArchived, opts = {}) {
    const isModal = !!opts.isModal;

    const dotCls = `lux-mw-dot ${esc(e.mw_cls || "mw-new")}`;
    const titleText = `${e.pinned ? "📌 " : ""}${e.text || ""}`;

    // ✅ Modal “Added” timestamp line (only in library)
    let addedLine = "";
    if (isModal) {
      const added = e.created_at || e.updated_at;
      const addedStr = added ? new Date(added).toLocaleString() : "";
      if (addedStr) {
        addedLine = `<div class="lux-mw-meta">Added ${esc(addedStr)}</div>`;
      }
    }

    // ✅ Actions differ depending on modal vs sidecar
    // Sidecar (non-modal): Active gets Archive.
    // Modal (library): Active gets Delete only (no Archive).
    const actions = isArchived
      ? `
        ${
          onSendToInput
            ? `<button class="lux-mw-act" data-act="send">Send</button>`
            : ""
        }
        <button class="lux-mw-act" data-act="wr">WR</button>
        <button class="lux-mw-act" data-act="yg">YG</button>
        <button class="lux-mw-act" data-act="coach">Coach</button>
        <button class="lux-mw-act" data-act="restore">Restore</button>
        <button class="lux-mw-act danger" data-act="delete">Delete</button>
      `
      : `
        ${
          onSendToInput
            ? `<button class="lux-mw-act" data-act="send">Send</button>`
            : ""
        }
        <button class="lux-mw-act" data-act="wr">WR</button>
        <button class="lux-mw-act" data-act="yg">YG</button>
        <button class="lux-mw-act" data-act="coach">Coach</button>
        <button class="lux-mw-act" data-act="pin">${e.pinned ? "Unpin" : "Pin"}</button>
        ${
          isModal
            ? `<button class="lux-mw-act danger" data-act="delete">Delete</button>`
            : `<button class="lux-mw-act danger" data-act="archive">Archive</button>`
        }
      `;

    return `
      <div class="lux-mw-row" data-id="${esc(e.id)}">
        <span class="${dotCls}"></span>

        <div class="lux-mw-main">
          <div class="lux-mw-text">${esc(titleText)}</div>
          <div class="lux-mw-meta">${esc(buildMeta(e))}</div>
          ${addedLine}
        </div>

        <div class="lux-mw-actions">
          ${actions}
        </div>
      </div>
    `;
  }

  function getFilteredListForTab() {
    const attempts = (typeof getAttempts === "function" ? getAttempts() : []) || [];
    const all = store.getState().entries || [];

    // Stats are applied to whichever list we’re showing
    const q = normalizeText(store.getState().query || "");

    if (tab === "archived") {
      const archived = all
        .filter((e) => !!e.archived)
        .filter((e) => (q ? normalizeText(e.text).includes(q) : true));

      return applyMyWordsStats(archived, attempts);
    }

    // Active tab uses visibleEntries (already excludes archived + applies store query)
    const active = store.visibleEntries();
    return applyMyWordsStats(active, attempts);
  }

  function renderBackButton(total) {
    // ✅ If panel is currently living inside the modal, show "Back to My Words"
    const isModal = root.classList.contains("is-modal");

    // Remove any existing footer button before adding a new one
    const existing = elList.querySelector(".lux-mw-viewAllBtn");
    if (existing) existing.remove();

    // In modal: always show back
    // In sidecar: show view library only when it makes sense
    if (isModal || total > 0) {
      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "lux-mw-viewAllBtn";

      btn.textContent = isModal ? "Back to My Words" : `View Library (${total})`;

      btn.addEventListener("click", () => {
        if (isModal) {
          onCloseLibrary?.();
          window.LuxMyWords?.closeLibrary?.();
        } else {
          onOpenLibrary?.();
          window.LuxMyWords?.openLibrary?.();
        }
      });

      elList.appendChild(btn);
    }
  }

  function render() {
    const isModal = root.classList.contains("is-modal");

    // ✅ Title: Library vs My Words
    if (elTitle) elTitle.textContent = isModal ? "Library" : "My Words";

    const { activeTotal, archivedTotal, total } = computeCountsAll();

    if (elBadgeActive) elBadgeActive.textContent = String(activeTotal);
    if (elBadgeArchived) elBadgeArchived.textContent = String(archivedTotal);

    const listAll = getFilteredListForTab();

    // ✅ Library should NOT show composer/add box
    if (elComposerZone) {
      if (isModal) {
        elComposerZone.style.display = "none";
      } else {
        elComposerZone.style.display = tab === "active" ? "" : "none";
      }
    }

    // If moved into modal, behave like library mode automatically
    const effectiveMode = isModal ? "library" : mode;

    // compact mode only previews ACTIVE tab (sidecar only)
    if (effectiveMode === "compact") {
      // Force active view in compact
      tab = "active";
      root.querySelectorAll(".lux-mw-tab").forEach((b) => {
        const is = b.dataset.tab === "active";
        b.classList.toggle("is-active", is);
      });
      if (elComposerZone) elComposerZone.style.display = "";

      const preview = listAll.slice(0, Math.max(0, maxPreview));

      if (!preview.length) {
        elList.innerHTML = `
          <div class="lux-mw-empty">
            <strong>No saved words yet.</strong>
            Add a few above 👆
          </div>
        `;
      } else {
        elList.innerHTML = preview
          .map((e) => entryRowHTML(e, false, { isModal: false }))
          .join("");
      }

      // ✅ Sidecar: show View Library (N) only when it makes sense
      if (total > 0 && (total > maxPreview || archivedTotal > 0)) {
        renderBackButton(total);
      }

      return;
    }

    // Library mode: active OR archived (includes modal-moved panel)
    if (!listAll.length) {
      elList.innerHTML = `
        <div class="lux-mw-empty">
          <strong>${
            tab === "archived" ? "No archived words." : "No active words yet."
          }</strong>
          ${
            tab === "archived"
              ? "Archive something first."
              : isModal
              ? "Try searching your history above."
              : "Add a few above 👆"
          }
        </div>
      `;

      // ✅ Modal still gets a Back button
      if (isModal) renderBackButton(total);
      return;
    }

    const isArchived = tab === "archived";
    elList.innerHTML = listAll
      .map((e) => entryRowHTML(e, isArchived, { isModal }))
      .join("");

    // ✅ Modal gets Back button (never “View Library”)
    if (isModal) renderBackButton(total);
  }

  function focusComposer() {
    try {
      elTa?.focus();
    } catch {}
  }

  function focusSearch() {
    try {
      elSearch?.focus();
    } catch {}
  }

  // ------------------------------------------------------------
  // Events
  // ------------------------------------------------------------
  elTabs?.addEventListener("click", (e) => {
    const btn = e.target.closest("button[data-tab]");
    if (!btn) return;
    setTab(btn.dataset.tab);
  });

  elSearch?.addEventListener("input", (e) => {
    store.setQuery(e.target.value);
  });

  elClose?.addEventListener("click", () => {
    // If we're inside the modal → go “back”
    if (root.classList.contains("is-modal")) {
      onCloseLibrary?.();
      window.LuxMyWords?.closeLibrary?.();
      return;
    }

    // Sidecar closes store open state.
    store.setOpen(false);
  });

  elAdd?.addEventListener("click", () => {
    // Composer hidden in modal/library, but keep safe anyway
    if (root.classList.contains("is-modal")) return;

    const raw = elTa.value || "";
    const res = store.addMany(raw);
    if (res.added || res.merged) elTa.value = "";
  });

  // ✅ ENTER = Add (Shift+Enter = newline)
  elTa?.addEventListener("keydown", (e) => {
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      elAdd.click();
    }
  });

  root.addEventListener("click", (e) => {
    const btn = e.target.closest("button[data-act]");
    if (!btn) return;

    const row = e.target.closest("[data-id]");
    const id = row?.dataset?.id;
    if (!id) return;

    const entry = store.getState().entries.find((x) => x.id === id);
    if (!entry) return;

    const act = btn.dataset.act;

    if (act === "send") {
      onSendToInput?.(entry.text);
      return;
    }

    if (act === "wr") {
      openWordReference(entry.text);
      return;
    }

    if (act === "yg") {
      openYouglish(entry.text);
      return;
    }

    if (act === "coach") {
      onCoach?.(entry.text);
      return;
    }

    if (act === "pin") {
      store.togglePin(id);
      return;
    }

    if (act === "archive") {
      // ✅ Never archive inside the library modal
      if (root.classList.contains("is-modal")) return;
      store.archive(id);
      return;
    }

    if (act === "restore") {
      store.restore(id);
      return;
    }

    if (act === "delete") {
      store.hardDelete(id);
      return;
    }
  });

  // Re-render on store updates
  store.subscribe(() => render());

  // initial render
  render();

  return {
    el: root,
    render,
    focusComposer,
    focusSearch,
    setTab,
  };
}

// ------------------------------------------------------------
// Phase 5 Modal Controller
// ------------------------------------------------------------
export function ensureMyWordsLibraryModal({
  store,
  getAttempts,
  onSendToInput,
} = {}) {
  let modalEl = document.querySelector(".lux-mw-modal");
  let panelMount = null;
  let panelApi = null;

  function ensure() {
    if (modalEl) return modalEl;

    modalEl = document.createElement("div");
    modalEl.className = "lux-mw-modal";
    modalEl.innerHTML = `
      <div class="lux-mw-modal-card"></div>
    `;

    document.body.appendChild(modalEl);

    // Click outside card closes
    modalEl.addEventListener("click", (e) => {
      if (e.target === modalEl) close();
    });

    // Esc closes
    window.addEventListener("keydown", (e) => {
      if (e.key === "Escape" && modalEl.classList.contains("is-open")) {
        close();
      }
    });

    return modalEl;
  }

  function open() {
    const el = ensure();
    const card = el.querySelector(".lux-mw-modal-card");

    // Mount panel once
    if (!panelMount) {
      panelMount = card;

      panelApi = mountMyWordsPanel({
        store,
        getAttempts,
        onSendToInput,
        mode: "library",
        mountTo: panelMount,
        asModal: true,
        onOpenLibrary: null,
        onCloseLibrary: close,
        onCoach: null,
      });

      // Default tab Active when opening
      panelApi?.setTab?.("active");
    }

    el.classList.add("is-open");

    // Focus search for fast browsing
    try {
      panelApi?.focusSearch?.();
    } catch {}
  }

  function close() {
    if (!modalEl) return;
    modalEl.classList.remove("is-open");
  }

  return { open, close, el: modalEl };
}
</file>

<file path="features/features/tts-peekaboo.css">
/* ==========================================================================
   Text-to-Speech “Peekaboo” Panel (top-right corner drawer)
   File: features/features/tts-peekaboo.css
   Scope: only layout/UX chrome for the panel + tab
   ========================================================================== */

/* ---- Safety: if inline guard fails, keep the host hidden until adopted ---- */
#tts-controls[data-luxHidden="1"] {
  display: none !important;
}

:root {
  --lux-tts-panel-w: 360px;
  --lux-tts-panel-max-w: min(92vw, 380px);
  --lux-tts-panel-max-h: min(520px, 70vh);
  --lux-tts-radius: 14px;
  --lux-tts-shadow: 0 10px 30px rgba(0, 0, 0, 0.18);
  --lux-tts-border: 1px solid rgba(0, 0, 0, 0.06);
  --lux-tts-tab-bg: #1082ff;
  --lux-tts-tab-bg-hover: #0d6ad1;
  --lux-tts-tab-ink: #ffffff;

  --lux-drawer-dur: 440ms;
  --lux-tab-dur: 420ms;
  --lux-arrow-dur: 420ms;
  --lux-arrow-delay: 90ms;

  --lux-ease-drawer: cubic-bezier(0.18, 0.9, 0.2, 1);
  --lux-ease-pop: cubic-bezier(0.18, 1.25, 0.2, 1);

  /* ==========================================================================
     FIX 2 — Closed “white card stub” reveal
     - Matches Self Playback behavior
     ========================================================================== */
  --lux-tts-shell-h: 420px;        /* makes the blank card tall */
  --lux-tts-shell-reveal: 88px;    /* makes the visible stub feel intentional */

  --lux-tts-top-gap: 64px;        /* leaves space for Save Progress */
  --lux-tts-tab-h: 34px;
  --lux-tts-tab-protrude: 150px;  /* how far the tab sticks into the page */
}

/* ==========================================================================
   CORNER DRAWER PANEL
   ========================================================================== */
.lux-tts-panel {
  position: fixed;
  top: calc(env(safe-area-inset-top, 0) + var(--lux-tts-top-gap)) !important;
  right: env(safe-area-inset-right, 0) !important;
  left: auto !important;
  bottom: auto !important;
  z-index: 9999;

  height: var(--lux-tts-shell-h);
  max-height: var(--lux-tts-panel-max-h);

  width: var(--lux-tts-panel-w);
  max-width: var(--lux-tts-panel-max-w);

  background: #fff;
  border-left: var(--lux-tts-border);
  border-bottom: var(--lux-tts-border);
  border-top-left-radius: var(--lux-tts-radius);
  border-bottom-left-radius: var(--lux-tts-radius);
  box-shadow: var(--lux-tts-shadow);

  overflow: visible;

  /* CLOSED: slide out, but leave a visible “stub” behind */
  transform: translate3d(calc(100% - var(--lux-tts-shell-reveal)), 0, 0);

  transition: transform var(--lux-drawer-dur) var(--lux-ease-drawer);
  will-change: transform;
}

.lux-tts-open .lux-tts-panel {
  transform: translate3d(0, 0, 0);
}

/* --- CLOSED peek must have physical presence (blank white card) --- */
html:not(.lux-tts-open) .lux-tts-panel{
  min-height: 340px; /* tune: 300–420 depending on your open height */
}

.lux-tts-shell{
  height: 100%;
  overflow: hidden;
  position: relative;
  z-index: 1;
}

.lux-tts-panel #tts-controls {
  display: block;

  /* ✅ match SPB: tab height + 10px, and symmetric bezel */
  padding: calc(var(--lux-tts-tab-h) + 10px) 6px 6px;

  max-height: calc(var(--lux-tts-panel-max-h) - 8px);
  overflow: auto;
}



/* Inner card gets its own shadow (stacked effect like Self Playback) */
.lux-tts-panel #tts-controls .tts-box{
  margin: 0;
  border-radius: 14px;
  box-shadow: 0 10px 24px rgba(0,0,0,0.14);
  border: 1px solid rgba(0,0,0,0.05);
}

.lux-tts-panel .tts-box { gap: 10px; }
.lux-tts-panel,
.lux-tts-panel * { box-sizing: border-box; }

/* ==========================================================================
   FLOATING “PEEKABOO” TAB (Matched to SPB 0.18s)
   ========================================================================== */
.lux-tts-tab{
  position: absolute;
  top: 6px;
  right: 6px;
  left: auto;

  /* ✅ BAR like self-playback — but mirrored (extends LEFT into page) */
  width: calc(100% + var(--lux-tts-tab-protrude));
  height: var(--lux-tts-tab-h);
  z-index: 2;

  display: inline-flex;
  align-items: center;
  justify-content: center;

  padding: 0 14px;
  border: 0;
  border-radius: 999px;
  background: var(--lux-tts-tab-bg);
  color: var(--lux-tts-tab-ink);

  /* match SPB feel */
  font: 600 0.92rem/1 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
  cursor: pointer;

  box-shadow: 0 8px 22px rgba(16, 130, 255, 0.30);
  transition: transform 0.18s ease, filter 0.18s ease;

  transform: translateZ(0);
  will-change: transform;

  overflow: hidden;
}

.lux-tts-tab-inner{
  display: inline-flex;
  align-items: center;
  gap: 10px;
  justify-content: center;

  width: 100%;
  white-space: nowrap;

  transition: transform var(--lux-tab-dur) var(--lux-ease-pop);
  will-change: transform;
  box-sizing: border-box;

  /* like SPB */
  padding: 0 22px;
}

/* ✅ MIRROR ordering: arrow goes on OUTSIDE cap for right-side drawer */
.lux-tts-tab-icon { order: 1; }
.lux-tts-tab-label{ order: 2; }

/* OPEN => centered */
html.lux-tts-open .lux-tts-tab-inner{
  transform: translateX(0);
}

/* CLOSED => shift content toward the visible side (LEFT for right drawer) */
html:not(.lux-tts-open) .lux-tts-tab-inner{
  transform: translateX(calc(-44% + 22px));
}


.lux-tts-tab-icon {
  display: inline-block;
  will-change: transform;
  transform-origin: 50% 50%;
}

@keyframes luxTTSArrowOpen {
  0%   { transform: rotate(0deg); }
  60%  { transform: rotate(220deg); }  /* tiny overshoot */
  100% { transform: rotate(180deg); }
}

@keyframes luxTTSArrowClose {
  0%   { transform: rotate(180deg); }
  60%  { transform: rotate(-40deg); }  /* tiny overshoot */
  100% { transform: rotate(0deg); }
}

/* Right-side drawer:
   CLOSED = ◀ (0deg), OPEN = ▶ (180deg)
   Force both directions to animate (wins against other rules). */
html.lux-tts-open .lux-tts-tab .lux-tts-tab-icon,
.lux-tts-tab[aria-expanded="true"] .lux-tts-tab-icon {
  transform: rotate(180deg) !important;
  animation: luxTTSArrowOpen var(--lux-arrow-dur) var(--lux-ease-pop) both !important;
  animation-delay: var(--lux-arrow-delay) !important;
}

html:not(.lux-tts-open) .lux-tts-tab .lux-tts-tab-icon,
.lux-tts-tab[aria-expanded="false"] .lux-tts-tab-icon {
  transform: rotate(0deg) !important;
  animation: luxTTSArrowClose var(--lux-arrow-dur) var(--lux-ease-pop) both !important;
  animation-delay: var(--lux-arrow-delay) !important;
}

.lux-tts-tab:hover,
.lux-tts-tab:focus-visible {
  transform: translateX(-1px);
  filter: brightness(1.05); /* Match SPB brightness */
  outline: none;
}

.lux-tts-tab:active {
  transform: translateX(0);
  filter: brightness(0.98);
}

.lux-tts-open .lux-tts-tab[aria-expanded="true"] {
  opacity: 0.95;
}

/* ==========================================================================
   NUDGE ANIMATION
   ========================================================================== */
@keyframes luxTTSGlow {
  0%, 40%, 100% { box-shadow: 0 0 0 0 rgba(16,130,255,0); }
  20%, 60% { box-shadow: 0 0 0 10px rgba(16,130,255,0.12), 0 0 22px rgba(16,130,255,0.45); }
}

@keyframes luxTTSWiggle {
  0%, 100% { transform: translateX(0) rotate(0); }
  15% { transform: translateX(-3px) rotate(-2deg); }
  30% { transform: translateX(2px) rotate(1.5deg); }
  45% { transform: translateX(-2px) rotate(-1.2deg); }
  60% { transform: translateX(1px) rotate(0.8deg); }
  75% { transform: translateX(-1px) rotate(-0.6deg); }
}

.lux-tts-tab.lux-tts-nudge {
  animation: luxTTSGlow 1.4s ease-in-out, luxTTSWiggle 0.7s ease-in-out;
}

@media (prefers-reduced-motion: reduce) {
  .lux-tts-panel, .lux-sp-panel,
  .lux-tts-tab-inner, .lux-sp-tab-inner {
    transition: none !important;
  }
  .lux-tts-tab-icon, .lux-sp-tab-icon {
    animation: none !important;
  }
}

/* Closed peek size: only before the user ever opens TTS */
html:not(.lux-tts-booted) .lux-tts-panel{
  height: var(--lux-tts-shell-h);
}

/* After first open, keep the full-size drawer always */
html.lux-tts-booted .lux-tts-panel{
  height: auto;
  min-height: 0;
}

/* Responsive */
@media (max-width: 480px) {
  :root {
    --lux-tts-panel-w: 92vw;
    --lux-tts-panel-max-w: 92vw;
    --lux-tts-panel-max-h: min(82vh, 640px);
  }
  .lux-tts-tab {
    right: 12px;
    top: 10px;
    padding: 8px 12px;
    font-size: 0.95rem;
  }
}

@media print {
  .lux-tts-panel,
  .lux-tts-tab {
    display: none !important;
  }
}
</file>

<file path="features/my-words/index.js">
// features/my-words/index.js

import { fetchHistory } from "/src/api/index.js";
import { ensureUID } from "../../api/identity.js";

import { createMyWordsStore } from "./store.js";
import { mountMyWordsPanel } from "./panel.js";
import { mountMyWordsCornerLauncher } from "./launcher.js";

import {
  getAuthedUID,
  fetchMyWords,
  upsertManyMyWords,
  setPinned,
  setArchived,
  deleteEntry,
} from "./service.js";

/**
 * Layout: bottom-left “lane”
 * - Top hugs bottom of Self Playback drawer (".lux-sp-panel")
 * - Right edge hugs LEFT edge of the practice input (#referenceText)
 */
function layoutPanel(panelEl, inputEl) {
  if (!panelEl) return;

  const GAP = 12;
  const LEFT = 18;
  const BOTTOM = 18;

  panelEl.style.left = LEFT + "px";
  panelEl.style.right = "auto";
  panelEl.style.bottom = BOTTOM + "px";

  // top = bottom of Self Playback panel (if present)
  let top = 92;
  const sp = document.querySelector(".lux-sp-panel");
  if (sp) {
    const r = sp.getBoundingClientRect();
    top = Math.ceil(r.bottom + GAP);
  }

  const maxTop = Math.max(92, window.innerHeight - 260);
  top = Math.min(top, maxTop);
  panelEl.style.top = top + "px";

  // Width ends near the left edge of input (if present)
  let width = 420;
  if (inputEl) {
    const inputRect = inputEl.getBoundingClientRect();
    const targetRight = Math.ceil(inputRect.left - GAP);
    width = targetRight - LEFT;
  }

  width = Math.max(300, Math.min(width, 560));
  width = Math.min(width, Math.floor(window.innerWidth - LEFT - GAP));

  panelEl.style.width = width + "px";
  panelEl.style.height = `calc(100vh - ${top}px - ${BOTTOM}px)`;
  panelEl.style.maxHeight = `calc(100vh - ${top}px - ${BOTTOM}px)`;
}

export function initMyWordsGlobal({ uid, inputEl } = {}) {
  // ✅ Hide on AI landing page (convo.html)
  if (location.pathname.endsWith("convo.html")) return null;

  if (!uid) return null;

  let authedUID = null;

  // --- attempts cache for stats ---
  let attemptsLoaded = false;
  let attemptsCache = [];

  async function ensureAttempts() {
    if (attemptsLoaded) return attemptsCache;
    attemptsLoaded = true;

    try {
      const all = await fetchHistory(uid);
      attemptsCache = Array.isArray(all) ? all : [];
    } catch (e) {
      console.warn("[my-words] fetchHistory failed:", e);
      attemptsCache = [];
    }

    return attemptsCache;
  }

  // ============================================================
  // ✅ FIX — Real AI Coach handler (Coach button)
  // ============================================================
  async function sendToAICoach(text) {
    const t = String(text || "").trim();
    if (!t) return;

    // open the AI coach drawer
    const drawer = document.querySelector("#aiCoachDrawer");
    if (drawer) drawer.open = true;

    // Scroll so AI section is visible and low in viewport
    requestAnimationFrame(() => {
      try {
        drawer?.scrollIntoView({ behavior: "smooth", block: "end" });
      } catch (_) {}
    });

    // show loading feedback
    const box = document.querySelector("#aiFeedback");
    if (box)
      box.innerHTML = `<div style="padding:12px;opacity:.8;">Thinking…</div>`;

    // Persona (default tutor)
    const persona =
      document.querySelector(".ai-voice-btn.active")?.dataset?.value || "tutor";

    // Default to Quick Tip (placeholder until backend call)
    if (box) {
      box.innerHTML = `
        <div style="padding:14px;">
          <strong>Quick Tip for:</strong> ${t}<br/><br/>
          <em>Persona:</em> ${persona}<br/><br/>
          (placeholder until API call is wired)
        </div>`;
    }
  }

  const store = createMyWordsStore({
    uid,
    onMutation: async (evt) => {
      // Only sync to Supabase if logged in
      if (!authedUID) return;

      try {
        if (evt.type === "addMany") {
          await upsertManyMyWords(authedUID, evt.lines || []);
          const remote = await fetchMyWords(authedUID);
          if (remote?.length) store.replaceEntries(remote);
        }

        if (evt.type === "togglePin") {
          await setPinned(authedUID, evt.id, evt.pinned);
        }

        // ✅ Archive / Restore via setArchived()
        if (evt.type === "archive") {
          await setArchived(authedUID, evt.id, true);
        }

        if (evt.type === "restore") {
          await setArchived(authedUID, evt.id, false);
        }

        if (evt.type === "hardDelete") {
          await deleteEntry(authedUID, evt.id);
        }
      } catch (e) {
        console.warn("[my-words] supabase sync failed:", e);
      }
    },
  });

  // --- sidecar panel ---
  const panel = mountMyWordsPanel({
    store,
    getAttempts: () => attemptsCache,
    onSendToInput: inputEl
      ? (text) => {
          inputEl.value = text;
          inputEl.focus();
          inputEl.dispatchEvent(new Event("input", { bubbles: true }));
        }
      : null,
    mode: "compact",
    maxPreview: 5,
    onOpenLibrary: () => openLibrary(), // ✅ wire to reliable modal
    onCoach: (text) => sendToAICoach(text), // ✅ Coach button now works
  });

  // ✅ Alias for older code that expects "sidecar"
  const sidecar = panel;

  // ============================================================
  // ✅ FIX 1 — Make Library Modal open reliably (View Library)
  // ============================================================

  // --- Library Modal (View Library) ---
  let _mwModal = null;
  let _mwHome = null;

  function ensureLibraryModal() {
    if (_mwModal) return _mwModal;

    const m = document.createElement("div");
    m.id = "luxMwModal";
    m.className = "lux-mw-modal";
    m.innerHTML = `<div class="lux-mw-modal-card" role="dialog" aria-modal="true"></div>`;
    document.body.appendChild(m);

    // click outside closes
    m.addEventListener("click", (e) => {
      if (e.target === m) closeLibrary();
    });

    _mwModal = m;
    return m;
  }

  function openLibrary() {
    const m = ensureLibraryModal();
    const card = m.querySelector(".lux-mw-modal-card");
    if (!card) return;

    // Create a "home marker" so we can put the panel back where it came from
    if (!_mwHome) {
      _mwHome = document.createElement("div");
      _mwHome.id = "luxMwPanelHome";
      _mwHome.style.display = "none";

      // home marker goes right before panel.el
      panel.el.parentNode.insertBefore(_mwHome, panel.el);
    }

    // ✅ force panel visible (important if your CSS uses display:none by default)
    store.setOpen(true);
    panel.el.classList.add("is-open", "is-modal");

    // Move panel into the modal card
    card.appendChild(panel.el);

    // Show modal
    m.classList.add("is-open");
  }

  function closeLibrary() {
    if (!_mwModal || !_mwHome) return;

    _mwModal.classList.remove("is-open");

    // Put panel back to its original spot
    panel.el.classList.remove("is-modal");
    _mwHome.parentNode.insertBefore(panel.el, _mwHome);

    // Re-layout if still open (sidecar mode)
    if (store.getState().open) {
      requestAnimationFrame(() => layoutPanel(panel.el, inputEl));
    }
  }

  // ✅ Make available globally
  window.LuxMyWords = window.LuxMyWords || {};
  window.LuxMyWords.openLibrary = openLibrary;
  window.LuxMyWords.closeLibrary = closeLibrary;

  // --- launcher button (triangle) ---
  const launcher = mountMyWordsCornerLauncher({
    onClick: async () => {
      const isOpen = store.getState().open;
      store.setOpen(!isOpen);

      if (!isOpen) {
        // opening: load stats + layout + focus composer
        await ensureAttempts();
        requestAnimationFrame(() => {
          // ✅ don’t run sidecar layout when panel is inside modal
          if (!panel.el.classList.contains("is-modal")) {
            layoutPanel(panel.el, inputEl);
          }
          panel.focusComposer?.();
          panel.render?.();
        });
      }
    },
  });

  // Keep it aligned on resize (when open)
  window.addEventListener(
    "resize",
    () => {
      if (!store.getState().open) return;
      if (panel.el.classList.contains("is-modal")) return; // ✅ modal handles its own sizing
      layoutPanel(panel.el, inputEl);
    },
    { passive: true }
  );

  // When opened through store state
  store.subscribe(async (s) => {
    launcher.classList.toggle("is-open", !!s.open);
    panel.el.classList.toggle("is-open", !!s.open);

    if (s.open) {
      await ensureAttempts();
      requestAnimationFrame(() => {
        // ✅ don’t run sidecar layout when panel is inside modal
        if (!panel.el.classList.contains("is-modal")) {
          layoutPanel(panel.el, inputEl);
        }
        panel.render?.();
      });
    }
  });

  // --- Remote hydration when logged in ---
  (async () => {
    authedUID = await getAuthedUID();
    if (!authedUID) return;

    const remote = await fetchMyWords(authedUID);
    if (remote?.length) {
      store.replaceEntries(remote);
      return;
    }

    // If remote empty but local has data, upload local once
    const localTexts = store
      .getState()
      .entries.filter((e) => !e.archived)
      .map((e) => e.text);

    if (localTexts.length) {
      await upsertManyMyWords(authedUID, localTexts);
      const after = await fetchMyWords(authedUID);
      if (after?.length) store.replaceEntries(after);
    }
  })();

  // Global hook for Progress page button + external calls
  window.LuxMyWords = {
    ...(window.LuxMyWords || {}),
    toggle: () => store.toggleOpen(),
    open: () => store.setOpen(true),
    close: () => store.setOpen(false),
    openLibrary, // ✅ reliable open
    closeLibrary,
  };

  return { store, panel, sidecar, launcher };
}

/**
 * ✅ FIX 2 — always produce a UID (correct import)
 * This is what launcher.js lazy-imports and uses.
 */
export function initMyWordsEverywhere() {
  const uid = ensureUID(); // ✅ always returns a stable local UID
  const inputEl = document.getElementById("referenceText") || null;
  return initMyWordsGlobal({ uid, inputEl });
}
</file>

<file path="features/progress/wordcloud/wordcloud-dock.css">
/* features/progress/wordcloud/wordcloud-dock.css */

/* ---------------------------
   Tiny 1-line tooltip
--------------------------- */
[data-tip] { position: relative; }

[data-tip]::after {
  content: attr(data-tip);
  position: absolute;
  left: 50%;
  bottom: calc(100% + 10px);
  transform: translateX(-50%) translateY(4px);
  opacity: 0;
  pointer-events: none;
  white-space: nowrap;
  max-width: 320px;
  overflow: hidden;
  text-overflow: ellipsis;
  font-size: 12px;
  line-height: 1.2;
  padding: 6px 10px;
  border-radius: 10px;
  background: rgba(10, 14, 20, 0.92);
  color: rgba(255, 255, 255, 0.92);
  box-shadow: 0 10px 24px rgba(0, 0, 0, 0.25);
  transition: opacity 160ms ease, transform 160ms ease;
  z-index: 50;
}

[data-tip]:hover::after,
[data-tip]:focus-visible::after {
  opacity: 1;
  transform: translateX(-50%) translateY(0);
}

/* ✅ FIX: allow drawers to slide OUTSIDE the shell (shell clips by default) */
.lux-wc-shell,
.lux-wc-body {
  overflow: visible !important;
}

/* ---------------------------
   Dock layout: drawers + stage
--------------------------- */
.wcDock {
  --wc-side-col: 44px;
  --wc-drawer-w: 260px;
  --wc-gap: 18px;

  position: relative;
  overflow: visible;

  display: grid;
  grid-template-columns: var(--wc-side-col) minmax(0, 1fr) var(--wc-side-col);
  gap: var(--wc-gap);

  /* ✅ FIX: drawers stretch to match the stage height */
  align-items: stretch;
}

/* ===========================
   ✅ FIX 5A: Stage ABOVE panels
   Panels slide BEHIND stage
=========================== */

/* --- Dock layout: stage must sit ABOVE panels so panels can hide behind it --- */
.wcStage{
  position: relative;
  z-index: 5; /* ✅ stage above panels */
}

.wcStageCard{
  position: relative;
  z-index: 5;
  background: rgba(255,255,255,0.97);  /* ✅ hides anything behind */
  border: 1px solid rgba(15,23,42,.10);
  border-radius: 18px;
  overflow: hidden;                   /* ✅ clips panels behind */
}

.wcStageFooter {
  padding-top: 10px;
}

/* ---------------------------
   Drawers (tab gutter + outside panels)
--------------------------- */

/* drawers should NOT sit above stage by default */
.wcDrawer{
  width: var(--wc-side-col);
  position: relative;
  z-index: 1;

  /* ✅ drawers stretch vertically so panels can fill height */
  align-self: stretch;
  height: 100%;

  /* ✅ UX: sky blue, cloud-friendly */
  background: linear-gradient(180deg, #d9f1ff 0%, #bfe6ff 100%);
  color: #0f172a;

  /* ✅ allow drawer panels to escape the 44px gutter */
  overflow: visible !important;
  overflow-x: visible !important;
}

/* ✅ Remove horizontal scrollbars entirely */
.wcDrawerInner,
.wcDrawerContent{
  overflow-x: hidden !important;
}

/* drawer panels can slide “into” the stage area (behind it) */
.wcDrawerPanel{
  position: absolute;
  top: 0;
  bottom: 0;
  width: var(--wc-drawer-w);

  border-radius: 16px;

  overflow-x: hidden !important; /* ✅ no sideways scroll */
  overflow-y: auto;              /* ✅ vertical is allowed */

  /* ✅ UX: SKY BLUE panel, not harsh dark */
  background: linear-gradient(180deg, #d9f1ff 0%, #bfe6ff 100%);
  color: #0f172a;

  box-shadow: 0 14px 28px rgba(0,0,0,0.18);

  /* ✅ allow header + scrollable body */
  display: flex;
  flex-direction: column;
  min-height: 0;

  transition: transform 220ms ease;
  will-change: transform;

  /* ✅ OPEN panels behave normally */
  transform: translateX(0);
  pointer-events: auto;

  /* ✅ Optional reinforcement: panels always visible in the gap */
  z-index: 2;
}

/* closed panels should not intercept clicks */
.wcDrawer.is-closed .wcDrawerPanel{
  pointer-events: none;
}

/* OPEN state = panel is outside, not stealing center */
.wcDrawer--left .wcDrawerPanel { right: 0; }
.wcDrawer--right .wcDrawerPanel { left: 0; }

/* ✅ KEY: closed = slide INTO the stage (behind it), not away from it */
.wcDrawer--left.is-closed .wcDrawerPanel{
  transform: translateX(100%);
}

.wcDrawer--right.is-closed .wcDrawerPanel{
  transform: translateX(-100%);
}

.wcDrawerHeader {
  padding: 12px 12px 6px;
  font-weight: 900;
  font-size: 12px;
  opacity: 0.9;
}

.wcDrawerBody {
  padding: 10px 12px 14px;
  display: grid;
  gap: 10px;

  /* ✅ CRITICAL: allow drawer panels to slide OUTSIDE the 44px dock column */
  overflow: visible !important;
  min-height: 0;
}

/* ✅ allow children to shrink instead of overflow */
.wcDrawerBody > *{
  min-width: 0;
  max-width: 100%;
}

/* prevents “weird sideways push” */
.wcDrawerPanel *{
  box-sizing: border-box;
}

/* ✅ Buttons: white, readable, full-width, wrap text (no sideways push) */
.wcDrawer button{
  background: rgba(255,255,255,0.9);
  color: #0f172a;

  width: 100%;
  max-width: 100%;

  white-space: normal;
}

/* Tabs always stay clickable + premium contrast */
.wcDrawerTab{
  position: absolute;
  top: 16px;
  width: 34px;
  height: 46px;

  display: grid;
  place-items: center;

  border-radius: 12px;

  z-index: 10;
  background: rgba(15, 23, 42, 0.92);
  color: rgba(255,255,255,0.95);
  box-shadow: 0 10px 28px rgba(0,0,0,0.28);
  transition: transform .18s ease, filter .18s ease;

  cursor: pointer;
}

.wcDrawerTab:hover{
  filter: brightness(1.06);
}

.wcDrawerTab:focus-visible {
  outline: 3px solid rgba(37, 99, 235, 0.50);
  outline-offset: 3px;
}

/* aria-expanded=true means OPEN → clicking will CLOSE (move inward),
   so the arrow should point inward */
.wcDrawerTab[aria-expanded="true"]{
  transform: rotate(180deg);
}

.wcDrawer--left .wcDrawerTab { right: -12px; }
.wcDrawer--right .wcDrawerTab { left: -12px; }

/* Timeline sliders: stack label ABOVE slider to save horizontal space */
.wcDrawerPanel .lux-wc-timelineGroup{
  display: grid;
  grid-template-columns: 1fr;
  gap: 6px;
}

.wcDrawerPanel .lux-wc-timelineGroup input[type="range"]{
  width: 100%;
}

/* ---------------------------
   Mobile fallback: stack everything
--------------------------- */
@media (max-width: 560px) {
  .wcDock { grid-template-columns: 1fr; }

  .wcDrawer {
    width: 100%;
    height: auto;
  }

  .wcDrawerTab { display: none; }

  .wcDrawerPanel {
    position: relative;
    width: 100%;
    transform: none !important;
    pointer-events: auto;
    z-index: 4;
  }
}

/* ---------------------------
   HARD OVERRIDES: make stage square
   (beats any older wordcloud CSS)
--------------------------- */
#luxWcCanvasWrap.wcStageSquare {
  width: 100% !important;
  height: auto !important;
  aspect-ratio: 1 / 1 !important;
  min-height: 520px;
}

/* canvas must fill the square */
#luxWcCanvas {
  width: 100% !important;
  height: 100% !important;
  display: block;
}
/* =========================
   ✅ Drawer Tooltip Un-Clip Fix
   Tooltips are CSS pseudo-elements and can get clipped by scroll/overflow.
   Keep them INSIDE the drawer width so they’re always readable.
========================= */

.wcDrawerPanel [data-tip]::after{
  /* pin tooltip inside the panel instead of centering past the edges */
  left: 12px !important;
  right: 12px !important;

  /* cancel the horizontal centering transform */
  transform: translateY(4px) !important;

  /* allow wrapping instead of ellipsis */
  white-space: normal !important;
  overflow: visible !important;
  text-overflow: initial !important;

  max-width: none !important;
}

/* keep your hover reveal animation */
.wcDrawerPanel [data-tip]:hover::after,
.wcDrawerPanel [data-tip]:focus-visible::after{
  transform: translateY(0) !important;
}
/* =========================
   ✅ Tooltip: force DOWN for top mode pills
========================= */
.wcDrawerPanel [data-tip-pos="down"]::after{
  bottom: auto !important;
  top: calc(100% + 10px) !important;

  /* our drawer tooltip override removes translateX already,
     so we only animate Y */
  transform: translateY(-4px) !important;
}
</file>

<file path="lux-wordcloud.css">
/* lux-wordcloud.css */

.lux-wc-shell{
  background: rgba(255,255,255,0.86);
  border: 1px solid rgba(0,0,0,0.08);
  border-radius: 16px;
  box-shadow: 0 14px 42px rgba(0,0,0,0.10);

  overflow: visible !important; /* ✅ allow drawers to slide out beyond container */
}

.lux-wc-head{
  display:flex;
  align-items:flex-start;
  justify-content:space-between;
  gap: 12px;
  padding: 14px 14px 12px;
  border-bottom: 1px solid rgba(0,0,0,0.06);
  background: linear-gradient(to bottom, rgba(255,255,255,0.9), rgba(248,250,252,0.85));
}

.lux-wc-title{
  font-weight: 900;
  color: #0f172a;
  letter-spacing: 0.2px;
}

.lux-wc-sub{
  margin-top: 4px;
  color: #64748b;
  font-weight: 800;
  font-size: 0.92rem;
}

.lux-wc-actions{
  display:flex;
  gap: 10px;
  align-items:center;
  flex-wrap: wrap;
}

.lux-wc-body{
  padding: 14px;

  /* ✅ allow drawers beyond body */
  overflow: visible !important;
}

.lux-wc-canvasWrap{
  position: relative;
  width: 100%;
  height: min(520px, 62vh);
  border: 1px solid rgba(0,0,0,0.08);
  border-radius: 14px;
  background: radial-gradient(circle at 30% 20%, rgba(219,234,254,0.55), rgba(255,255,255,0.92) 55%, rgba(254,243,199,0.25));
  overflow: visible !important; /* ✅ do not clip side drawers */
}

/* ✅ Increase canvas usage: ensure wrap fills container */
#luxWcCanvasWrap{
  width: 100%;
  height: 100%;
}

.lux-wc-canvas{
  width: 100%;
  height: 100%;
  display:block;
}

/* =========================
   Loading Overlay (Canvas)
========================= */

.lux-wc-overlay{
  position: absolute;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;

  /* keep it premium + subtle */
  background: rgba(255,255,255,0.35);
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);

  pointer-events: none;
  z-index: 5;
}

.lux-wc-overlayCard{
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 12px 14px;
  border-radius: 16px;

  background: rgba(255,255,255,0.92);
  border: 1px solid rgba(0,0,0,0.08);
  box-shadow: 0 18px 44px rgba(0,0,0,0.14);

  transform: translateY(0);
  animation: luxWcOverlayPop 240ms ease-out both;
}

@keyframes luxWcOverlayPop{
  from { transform: translateY(6px); opacity: 0; }
  to   { transform: translateY(0); opacity: 1; }
}

.lux-wc-spinner{
  width: 18px;
  height: 18px;
  border-radius: 999px;
  border: 3px solid rgba(37,99,235,0.22);
  border-top-color: rgba(37,99,235,0.95);
  animation: luxWcSpin 850ms linear infinite;
}

@keyframes luxWcSpin{
  to { transform: rotate(360deg); }
}

.lux-wc-overlayTitle{
  font-weight: 950;
  color: #0f172a;
  line-height: 1.1;
}

.lux-wc-overlaySub{
  margin-top: 2px;
  font-weight: 900;
  color: rgba(100,116,139,0.92);
  font-size: 0.9rem;
}

/* Night theme overlay */
.lux-wc--night .lux-wc-overlay{
  background: rgba(0,0,0,0.28);
}

.lux-wc--night .lux-wc-overlayCard{
  background: rgba(20,30,58,0.70);
  border: 1px solid rgba(255,255,255,0.10);
}

.lux-wc--night .lux-wc-overlayTitle{
  color: rgba(255,255,255,0.92);
}

.lux-wc--night .lux-wc-overlaySub{
  color: rgba(255,255,255,0.70);
}

.lux-wc--night .lux-wc-spinner{
  border: 3px solid rgba(148,163,184,0.28);
  border-top-color: rgba(255,255,255,0.92);
}

.lux-wc-legend{
  margin-top: 12px;
  display:flex;
  gap: 10px;
  flex-wrap: wrap;
  align-items:center;
  color:#64748b;
  font-weight: 900;
  font-size: 0.88rem;
}

.lux-wc-dot{
  width: 10px;
  height: 10px;
  border-radius: 999px;
  display:inline-block;
  margin-right: 6px;
  transform: translateY(1px);
}
.lux-wc-toggle{
  display:flex;
  gap: 8px;
  align-items:center;
  padding: 6px;
  border-radius: 999px;
  background: rgba(15,23,42,0.05);
  border: 1px solid rgba(0,0,0,0.06);
}

.lux-wc-pill{
  appearance:none;
  border: none;
  background: transparent;
  padding: 8px 12px;
  border-radius: 999px;
  font-weight: 900;
  color: #334155;
  cursor: pointer;
  transition: transform 160ms ease, background 160ms ease, box-shadow 160ms ease;
}

.lux-wc-pill:hover{
  transform: translateY(-1px);
  background: rgba(255,255,255,0.75);
}

.lux-wc-pill.is-active{
  background: rgba(255,255,255,0.95);
  box-shadow: 0 10px 22px rgba(0,0,0,0.10);
  color: #0f172a;
}
/* =========================
   Phase B: Controls Bar
========================= */

.lux-wc-controls{
  margin-top: 12px;
  display:flex;
  flex-direction:column;
  gap: 10px;
}

.lux-wc-search{
  display:flex;
  align-items:center;
  gap: 10px;
  padding: 10px 12px;
  border-radius: 14px;
  border: 1px solid rgba(0,0,0,0.08);
  background: rgba(255,255,255,0.88);
}

.lux-wc-search input{
  flex: 1;
  border: none;
  outline: none;
  background: transparent;
  font-weight: 900;
  color: #0f172a;
  font-size: 0.98rem;
}

.lux-wc-search input::placeholder{
  color: rgba(100,116,139,0.85);
  font-weight: 850;
}

.lux-wc-clear{
  width: 34px;
  height: 34px;
  border-radius: 12px;
  border: 1px solid rgba(0,0,0,0.08);
  background: rgba(248,250,252,0.92);
  cursor: pointer;
  font-weight: 950;
  transition: transform 160ms ease, filter 160ms ease;

  /* ✅ FIX: ensure the ✕ is visible */
  color: #0f172a;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  font-size: 18px;
  line-height: 1;
}

.lux-wc-clear:hover{
  transform: translateY(-1px);
  filter: brightness(1.06);
}

.lux-wc-chipBar{
  display:flex;
  gap: 8px;
  flex-wrap: wrap;
  align-items:center;
}

.lux-wc-chipBtn{
  border: 1px solid rgba(0,0,0,0.08);
  background: rgba(255,255,255,0.78);
  padding: 7px 10px;
  border-radius: 999px;
  font-weight: 950;
  color: #334155;
  cursor: pointer;
  transition: transform 160ms ease, filter 160ms ease, box-shadow 160ms ease;
}

.lux-wc-chipBtn:hover{
  transform: translateY(-1px);
  filter: brightness(1.05);
}

.lux-wc-chipBtn.is-on{
  background: rgba(255,255,255,0.95);
  color: #0f172a;
  box-shadow: 0 10px 22px rgba(0,0,0,0.10);
}
/* =========================
   Phase C: Micro Delight
========================= */

.lux-wc-canvasWrap{
  transition: transform 220ms ease, filter 220ms ease, box-shadow 220ms ease;
}

.lux-wc-canvasWrap:hover{
  transform: translateY(-1px);
  filter: brightness(1.03);
  box-shadow: 0 22px 60px rgba(0,0,0,0.16);
}

/* Night: add a little “constellation” texture */
.lux-wc--night .lux-wc-canvasWrap{
  position: relative;
  overflow: visible !important; /* ✅ do not clip drawers */
}

.lux-wc--night .lux-wc-canvasWrap::before{
  content:"";
  position:absolute;
  inset: 0;
  pointer-events:none;
  opacity: 0.55;
  background:
    radial-gradient(1px 1px at 10% 18%, rgba(255,255,255,0.55), transparent 55%),
    radial-gradient(1px 1px at 22% 64%, rgba(255,255,255,0.38), transparent 55%),
    radial-gradient(1px 1px at 36% 32%, rgba(255,255,255,0.48), transparent 55%),
    radial-gradient(1px 1px at 52% 74%, rgba(255,255,255,0.30), transparent 55%),
    radial-gradient(1px 1px at 70% 22%, rgba(255,255,255,0.40), transparent 55%),
    radial-gradient(1px 1px at 85% 58%, rgba(255,255,255,0.35), transparent 55%);
  mix-blend-mode: screen;
}
/* =========================
   Phase D: Power Row + Strips
========================= */

.lux-wc-powerRow{
  margin-top: 10px;
  display:flex;
  gap: 10px;
  flex-wrap: wrap;
  align-items:center;
}

.lux-wc-genTop{
  font-weight: 950;
}

.lux-wc-powerBtn.is-on{
  box-shadow: 0 0 0 2px rgba(37,99,235,0.22);
}

.lux-wc-targetStrip,
.lux-wc-savedStrip{
  margin-top: 10px;
}

.lux-wc-stripLabel{
  font-weight: 950;
  color: #0f172a;
  margin: 2px 0 8px;
}

.lux-wc-stripRow{
  display:flex;
  gap: 8px;
  flex-wrap: wrap;
}

.lux-wc-chipTarget,
.lux-wc-chipSaved{
  border: 1px solid rgba(0,0,0,0.08);
  background: rgba(255,255,255,0.82);
  border-radius: 999px;
  padding: 7px 12px;
  font-weight: 950;
  cursor: pointer;
  transition: transform 160ms ease, filter 160ms ease;

  /* ✅ FIX: prevent white-on-white from global button styles */
  color: #0f172a;
  font-size: 0.95rem;
  line-height: 1.1;
}

.lux-wc-chipTarget:hover,
.lux-wc-chipSaved:hover{
  transform: translateY(-1px);
  filter: brightness(1.05);
}

.lux-wc-chipTarget{
  display:inline-flex;
  align-items:center;
  gap: 8px;
}

.lux-wc-chipPct{
  font-size: 12px;
  font-weight: 950;
  color: rgba(51,65,85,0.85);
}

/* Night versions */
.lux-wc--night .lux-wc-stripLabel{
  color: rgba(255,255,255,0.90);
}
.lux-wc--night .lux-wc-chipTarget,
.lux-wc--night .lux-wc-chipSaved{
  background: rgba(20,30,58,0.62);
  border: 1px solid rgba(255,255,255,0.08);
  color: rgba(255,255,255,0.92);
}
.lux-wc--night .lux-wc-chipPct{
  color: rgba(255,255,255,0.72);
}
/* =========================
   Phase E: Smart Mix + Coach Lane
========================= */

.lux-wc-mixRow{
  margin-top: 8px;
  display:flex;
  gap: 8px;
  flex-wrap: wrap;
  align-items:center;
}

.lux-wc-mixLabel{
  font-weight: 950;
  color: #64748b;
  margin-right: 6px;
}

.lux-wc-coachLane{
  margin-top: 10px;
  padding: 12px;
  border-radius: 18px;
  border: 1px solid rgba(0,0,0,0.08);
  background: rgba(255,255,255,0.86);
}

.lux-wc-coachTitle{
  font-weight: 950;
  color: #0f172a;
  margin-bottom: 8px;
}

.lux-wc-coachBtns{
  display:flex;
  gap: 10px;
  flex-wrap: wrap;
}

.lux-wc-coachHint{
  margin-top: 8px;
  font-weight: 900;
  color: rgba(100,116,139,0.85);
  font-size: 0.92rem;
}

/* Night */
.lux-wc--night .lux-wc-mixLabel{
  color: rgba(255,255,255,0.70);
}
.lux-wc--night .lux-wc-coachLane{
  background: rgba(20,30,58,0.62);
  border: 1px solid rgba(255,255,255,0.10);
}
.lux-wc--night .lux-wc-coachTitle{
  color: rgba(255,255,255,0.92);
}
.lux-wc--night .lux-wc-coachHint{
  color: rgba(255,255,255,0.68);
}
/* =========================
   Phase F: Timeline Scrub + Replay
========================= */

.lux-wc-timelineRow{
  margin-top: 10px;
  display: none; /* only shows in Timeline mode */
  gap: 14px;
  flex-wrap: wrap;
  align-items: center;
  padding: 10px 12px;
  border-radius: 18px;
  border: 1px solid rgba(0,0,0,0.08);
  background: rgba(255,255,255,0.78);
}

.lux-wc-timelineLabel{
  font-weight: 950;
  color: #0f172a;
  margin-right: 6px;
}

.lux-wc-timelineGroup{
  display:flex;
  align-items:center;
  gap: 8px;
}

.lux-wc-tlineMini{
  font-weight: 900;
  color: rgba(100,116,139,0.9);
  font-size: 0.92rem;
  min-width: 52px;
}

.lux-wc-tlineVal{
  font-weight: 950;
  color: #0f172a;
  min-width: 62px;
  text-align: right;
}

.lux-wc-timelineRow input[type="range"]{
  width: 210px;
  accent-color: #2563eb;
}

/* Night */
.lux-wc--night .lux-wc-timelineRow{
  background: rgba(20,30,58,0.55);
  border: 1px solid rgba(255,255,255,0.10);
}
.lux-wc--night .lux-wc-timelineLabel{
  color: rgba(255,255,255,0.92);
}
.lux-wc--night .lux-wc-tlineMini{
  color: rgba(255,255,255,0.70);
}
.lux-wc--night .lux-wc-tlineVal{
  color: rgba(255,255,255,0.88);
}

/* =========================
   Night Theme — full surface pass
========================= */

.lux-wc--night{
  background: rgba(10,14,28,0.88);
  border: 1px solid rgba(255,255,255,0.10);
  box-shadow: 0 20px 70px rgba(0,0,0,0.45);
}

.lux-wc--night .lux-wc-head{
  background: linear-gradient(
    to bottom,
    rgba(12,18,36,0.92),
    rgba(16,24,48,0.72)
  );
  border-bottom: 1px solid rgba(255,255,255,0.08);
}

.lux-wc--night .lux-wc-title{
  color: rgba(255,255,255,0.92);
}

.lux-wc--night .lux-wc-sub{
  color: rgba(255,255,255,0.65);
}

.lux-wc--night .lux-wc-toggle{
  background: rgba(255,255,255,0.08);
  border: 1px solid rgba(255,255,255,0.10);
}

.lux-wc--night .lux-wc-pill{
  color: rgba(255,255,255,0.78);
}

.lux-wc--night .lux-wc-pill:hover{
  background: rgba(255,255,255,0.10);
}

.lux-wc--night .lux-wc-pill.is-active{
  background: rgba(255,255,255,0.16);
  color: rgba(255,255,255,0.92);
}

.lux-wc--night .lux-wc-search{
  background: rgba(20,30,58,0.55);
  border: 1px solid rgba(255,255,255,0.10);
}

.lux-wc--night .lux-wc-search input{
  color: rgba(255,255,255,0.92);
}

.lux-wc--night .lux-wc-search input::placeholder{
  color: rgba(255,255,255,0.55);
}

.lux-wc--night .lux-wc-clear{
  background: rgba(255,255,255,0.10);
  border: 1px solid rgba(255,255,255,0.10);
  color: rgba(255,255,255,0.90);
}

.lux-wc--night .lux-wc-chipBtn{
  background: rgba(255,255,255,0.08);
  border: 1px solid rgba(255,255,255,0.10);
  color: rgba(255,255,255,0.80);
}

.lux-wc--night .lux-wc-chipBtn.is-on{
  background: rgba(255,255,255,0.16);
  color: rgba(255,255,255,0.92);
  box-shadow: 0 10px 22px rgba(0,0,0,0.35);
}

.lux-wc--night .lux-wc-canvasWrap{
  border: 1px solid rgba(255,255,255,0.10);
  background:
    radial-gradient(circle at 30% 20%,
      rgba(59,130,246,0.20),
      rgba(10,16,32,0.92) 55%,
      rgba(245,158,11,0.10)
    );
}

.lux-wc--night .lux-wc-legend{
  color: rgba(255,255,255,0.60);
}

/* ✅ CRITICAL: hidden attribute must always win */
.lux-wc-overlay[hidden]{
  display: none !important;
}

/* =========================
   Drawer Escape Hatches
   (defeat clipping from outer containers)
========================= */

.wcStageCard{
  overflow: visible !important;
}

.lux-wc-shell,
.lux-wc-body,
.lux-wc-canvasWrap,
#luxWcCanvasWrap{
  overflow: visible !important;
}
/* =========================
   ✅ FINAL Drawer Un-Clipping Fix
   Wordcloud is inside lux-progress containers that clip via overflow:hidden.
   Scope to #wordcloud-root ONLY.
========================= */

#wordcloud-root .lux-progress-sec,
#wordcloud-root .lux-pcard{
  overflow: visible !important;
  position: relative;
}
</file>

<file path="features/progress/wordcloud/render-canvas.js">
// features/progress/wordcloud/render-canvas.js
import { getColorConfig } from "../progress-utils.js";

function clamp(n, a, b) {
  return Math.max(a, Math.min(b, n));
}

function lower(s) {
  return String(s || "").trim().toLowerCase();
}

function idOfWord(d) {
  const meta = d?.meta || {};
  return String(meta.word ?? meta.ipa ?? d?.text ?? "").trim().toLowerCase();
}

function hexToRgba(hex = "#000000", a = 0.2) {
  const h = String(hex).replace("#", "").trim();
  if (h.length !== 6) return `rgba(0,0,0,${a})`;
  const r = parseInt(h.slice(0, 2), 16);
  const g = parseInt(h.slice(2, 4), 16);
  const b = parseInt(h.slice(4, 6), 16);
  return `rgba(${r},${g},${b},${a})`;
}

/**
 * renderWordCloudCanvas(canvas, items, opts?)
 * opts:
 *  - focusTest(idLower) => boolean
 *  - onSelect(hit)
 *  - clusterMode: boolean
 *  - pinnedSet: Set<string lower>
 *  - onRenderEnd({ reason })
 *  - reuseLayoutOnly: boolean (✅ reflow-only repaint using cached layout)
 */
export function renderWordCloudCanvas(canvas, items = [], opts = {}) {
  if (!canvas) return;

  // ✅ Controller callback (overlay off signal)
  let _endFired = false;

  // If layout is slow, keep the overlay ON (no blank-screen confusion).
  // We'll just log once after ~2.5s instead of ending the render early.
  let slowTimer = 0;
  const clearSlowTimer = () => {
    if (slowTimer) {
      clearTimeout(slowTimer);
      slowTimer = 0;
    }
  };

  const fireEnd = (reason = "ok") => {
    if (_endFired) return;
    _endFired = true;
    clearSlowTimer();
    if (typeof opts?.onRenderEnd === "function") {
      try {
        opts.onRenderEnd({ reason });
      } catch (_) {}
    }
  };

  const wrap = canvas.parentElement;
  const w = Math.max(320, wrap?.clientWidth || 800);
  const h = Math.max(280, wrap?.clientHeight || 460);

  // HiDPI
  const dpr = window.devicePixelRatio || 1;
  canvas.width = Math.floor(w * dpr);
  canvas.height = Math.floor(h * dpr);
  canvas.style.width = `${w}px`;
  canvas.style.height = `${h}px`;

  const ctx = canvas.getContext("2d");
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

  ctx.clearRect(0, 0, w, h);
  if (!items.length) {
    fireEnd("empty");
    return;
  }

  const pinnedSet = opts?.pinnedSet instanceof Set ? opts.pinnedSet : new Set();

  const counts = items.map((x) => Number(x.count || 0));
  const maxC = Math.max(1, ...counts);
  const minC = Math.min(...counts);

  // ✅ Stronger contrast curve for font sizing
  const MIN_FONT = 16; // ✅ bigger tiny words
  const MAX_FONT = 118; // ✅ bigger big words
  const SPREAD_EXP = 1.35;

  const sizeForCount = (c) => {
    const t = (Number(c || 0) - minC) / Math.max(1, maxC - minC);
    const eased = Math.pow(clamp(t, 0, 1), SPREAD_EXP);
    const s = MIN_FONT + (MAX_FONT - MIN_FONT) * eased;
    return clamp(s, MIN_FONT, MAX_FONT);
  };

  const PIN_BOOST = 1.16; // pinned appear bigger
  const PIN_CENTER = 0.86; // pinned float toward center (cloud-like)

  const words = items.map((x) => {
    const text = String(x.word ?? x.ipa ?? x.text ?? "").trim();
    const id = lower(String(x.word ?? x.ipa ?? x.text ?? ""));
    const baseSize = sizeForCount(x.count);

    return {
      text,
      count: Number(x.count || 0),
      avg: Number.isFinite(Number(x.avg)) ? Number(x.avg) : 0,
      size: baseSize,
      meta: x,
      _id: id,
      _pinned: pinnedSet.has(id),
    };
  });

  // ✅ stable layout signature (prevents shuffle-reset on drawer reflow)
  const layoutSig = items.map((it) => it.id).join("\u001f");

  const d3 = window.d3;
  const cloudFactory = d3?.layout?.cloud || window.cloud;
  if (!cloudFactory) {
    ctx.font = "800 18px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillStyle = "#334155";
    ctx.fillText("Word cloud library missing.", 20, 40);
    fireEnd("libs-missing");
    return;
  }

  // ✅ GLOBAL sizing boost (you want BIG + readable)
  const SIZE_MULT = 1.35;

  // ✅ Fit-to-canvas helper (fill the square more)
  function fitToCanvas(layoutWords) {
    if (!layoutWords?.length) return layoutWords;

    let minX = Infinity,
      maxX = -Infinity,
      minY = Infinity,
      maxY = -Infinity;

    for (const d of layoutWords) {
      const base = (d._pinned ? d.size * PIN_BOOST : d.size) * SIZE_MULT;
      ctx.font = `${Math.max(8, Math.round(base))}px system-ui`;

      const m = ctx.measureText(d.text);
      const left = m.actualBoundingBoxLeft ?? m.width / 2;
      const right = m.actualBoundingBoxRight ?? m.width / 2;
      const ascent = m.actualBoundingBoxAscent ?? base * 0.55;
      const descent = m.actualBoundingBoxDescent ?? base * 0.45;

      minX = Math.min(minX, d.x - left);
      maxX = Math.max(maxX, d.x + right);
      minY = Math.min(minY, d.y - ascent);
      maxY = Math.max(maxY, d.y + descent);
    }

    const bw = maxX - minX;
    const bh = maxY - minY;
    if (!Number.isFinite(bw) || !Number.isFinite(bh) || bw < 20 || bh < 20)
      return layoutWords;

    const s = Math.min((w * 0.92) / bw, (h * 0.92) / bh);
    const cx0 = (minX + maxX) / 2;
    const cy0 = (minY + maxY) / 2;

    return layoutWords.map((d) => ({
      ...d,
      x: (d.x - cx0) * s,
      y: (d.y - cy0) * s,
      size: d.size * s,
    }));
  }

  // Phase C state
  let placed = null;
  let boxes = [];
  let hoverIdx = -1;
  let mouse = { x: 0, y: 0 };
  let ripple = null;
  let rafId = 0;

  let fadeStart = performance.now();
  const FADE_MS = 220;

  function stopRAF() {
    if (rafId) cancelAnimationFrame(rafId);
    rafId = 0;
  }

  function paint() {
    if (!placed?.length) return;

    ctx.clearRect(0, 0, w, h);

    const cx = w / 2;
    const cy = h / 2;

    const isDark = window.matchMedia?.("(prefers-color-scheme: dark)")?.matches;

    // search focus
    const focusFn = typeof opts?.focusTest === "function" ? opts.focusTest : null;
    let focusActive = false;
    if (focusFn) {
      for (const d of placed) {
        const id = idOfWord(d);
        if (id && focusFn(id)) {
          focusActive = true;
          break;
        }
      }
    }

    // fade thaw
    const tNow = performance.now();
    const fadeAlpha = clamp((tNow - fadeStart) / FADE_MS, 0, 1);

    // ripple progress
    let rippleP = 0;
    if (ripple) {
      rippleP = clamp((tNow - ripple.t0) / ripple.dur, 0, 1);
      if (rippleP >= 1) ripple = null;
    }

    boxes = [];

    for (let i = 0; i < placed.length; i++) {
      const d = placed[i];

      const col = getColorConfig(d.avg).color;
      const glow = hexToRgba(col, 0.22);

      const id = idOfWord(d);
      const isMatch = focusActive && focusFn ? !!focusFn(id) : true;

      const isHover = i === hoverIdx;
      const isPinned = !!d._pinned;

      let alpha = 1;
      if (focusActive) alpha = isMatch || isHover ? 1 : 0.16;
      alpha *= fadeAlpha;

      // magnetic pull
      let pullX = 0;
      let pullY = 0;
      if (isHover) {
        const wx = cx + d.x;
        const wy = cy + d.y;
        const vx = mouse.x - wx;
        const vy = mouse.y - wy;
        const dist = Math.max(1, Math.hypot(vx, vy));
        const strength = 10 * (1 - clamp(dist / 180, 0, 1));
        pullX = (vx / dist) * strength;
        pullY = (vy / dist) * strength;
      }

      // Phase D cluster drift (optional)
      let driftX = 0;
      let driftY = 0;

      if (opts?.clusterMode) {
        const avg = Number(d.avg || 0);
        const dx = w * 0.17;
        const dy = h * 0.06;

        if (avg >= 80) {
          driftX = -dx;
          driftY = -dy;
        } else if (avg >= 60) {
          driftX = 0;
          driftY = dy * 1.2;
        } else {
          driftX = dx;
          driftY = -dy;
        }

        driftX *= 0.65;
        driftY *= 0.65;
      }

      // Phase E pinned dominance: closer to center
      const pinMul = isPinned ? PIN_CENTER : 1;

      ctx.save();

      const centerX = cx + d.x * pinMul + pullX + driftX;
      const centerY = cy + d.y * pinMul + pullY + driftY;

      ctx.translate(centerX, centerY);

      const baseSize = d.size;
      const size =
        ((isPinned ? baseSize * PIN_BOOST : baseSize) * SIZE_MULT) *
        (isHover ? 1.08 : 1);

      ctx.font = `900 ${size}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";

      // pinned halo ring behind text (subtle)
      if (isPinned) {
        ctx.globalAlpha = 0.22 * fadeAlpha;
        ctx.beginPath();
        ctx.arc(0, 0, size * 0.72, 0, Math.PI * 2);
        ctx.fillStyle = hexToRgba(col, 0.10);
        ctx.fill();
      }

      // ✅ stronger, more visible halo on hover
      ctx.shadowColor = isHover
        ? hexToRgba(col, isDark ? 0.42 : 0.34)
        : hexToRgba(col, isDark ? 0.18 : 0.14);

      ctx.shadowBlur = isHover ? (isDark ? 28 : 22) : 10;

      ctx.globalAlpha = alpha;
      ctx.fillStyle = col;
      ctx.fillText(d.text, 0, 0);

      if (isHover) {
        ctx.shadowBlur = 0;
        ctx.globalAlpha = Math.max(alpha, 0.55);
        ctx.lineWidth = 3;

        ctx.strokeStyle = isDark
          ? "rgba(255,255,255,0.65)"
          : "rgba(15,23,42,0.70)";

        ctx.strokeText(d.text, 0, 0);
        ctx.globalAlpha = alpha;
        ctx.fillStyle = col;
        ctx.fillText(d.text, 0, 0);
      }

      // bbox (tight) ✅ drastically reduces the “invisible halo” blocking clicks
      ctx.shadowBlur = 0;

      const m = ctx.measureText(d.text);
      const left = m.actualBoundingBoxLeft ?? m.width / 2;
      const right = m.actualBoundingBoxRight ?? m.width / 2;
      const ascent = m.actualBoundingBoxAscent ?? size * 0.55;
      const descent = m.actualBoundingBoxDescent ?? size * 0.45;

      const bw = left + right;
      const bh = ascent + descent;

      // tiny padding so it’s still easy to click (but not huge)
      const padPx = Math.max(1, Math.round(size * 0.045));

      boxes.push({
        text: d.text,
        avg: d.avg,
        count: d.count,
        meta: d.meta,

        x: centerX - left - padPx,
        y: centerY - ascent - padPx,
        w: bw + padPx * 2,
        h: bh + padPx * 2,

        cx: centerX,
        cy: centerY,
        col,
      });

      ctx.restore();
    }

    // ripple ring
    if (ripple && ripple.idx != null && boxes[ripple.idx]) {
      const b = boxes[ripple.idx];
      const ease = 1 - Math.pow(1 - rippleP, 2);
      const rr = 10 + (44 - 10) * ease;
      const a = 0.32 * (1 - rippleP);

      ctx.save();
      ctx.beginPath();
      ctx.arc(b.cx, b.cy, rr, 0, Math.PI * 2);
      ctx.strokeStyle = hexToRgba(b.col || "#ffffff", a);
      ctx.lineWidth = 3;
      ctx.stroke();
      ctx.restore();

      if (!rafId) {
        rafId = requestAnimationFrame(() => {
          rafId = 0;
          paint();
        });
      }
    }
  }

  function hitTest(mx, my) {
    // ✅ scan from topmost (last drawn) to bottom
    for (let i = boxes.length - 1; i >= 0; i--) {
      const b = boxes[i];
      if (mx >= b.x && mx <= b.x + b.w && my >= b.y && my <= b.y + b.h) return i;
    }
    return -1;
  }

  function startRipple(idx) {
    ripple = { idx, t0: performance.now(), dur: 520 };
    stopRAF();
    rafId = requestAnimationFrame(() => {
      rafId = 0;
      paint();
    });
  }

  function layoutAndDraw(layoutWords) {
    placed = fitToCanvas(layoutWords);

    // ✅ cache last layout so drawer reflow doesn't reshuffle
    canvas.__lux_wc_layout = {
      sig: layoutSig,
      w,
      h,
      placed: layoutWords.map((d) => ({ ...d })),
    };

    fadeStart = performance.now() - FADE_MS; // ✅ show immediately (no invisible first frame)
    hoverIdx = -1;
    ripple = null;
    paint();
    fireEnd("ok"); // ✅ IMPORTANT
  }

  // ✅ Cloud should occupy more space: reduce padding
  const pad = 1;

  // ✅ Drawer slide reflow: reuse existing placed words (no recompute)
  if (opts.reuseLayoutOnly) {
    const prev = canvas.__lux_wc_layout;
    if (prev && prev.placed && prev.sig === layoutSig) {
      const s = Math.min(w / prev.w, h / prev.h) || 1;

      const scaled = prev.placed.map((d) => ({
        ...d,
        x: d.x * s,
        y: d.y * s,
        size: d.size * s,
      }));

      layoutAndDraw(scaled);
      return;
    }
  }

  // If layout is slow, log once (but DO NOT hide overlay early).
  slowTimer = setTimeout(() => {
    console.log("[wc] layout still running…");
  }, 2500);

  try {
    cloudFactory()
      .size([w, h])
      .words(words)
      .padding(pad)
      .rotate(() => 0)
      .font("system-ui")
      .fontSize((d) =>
        (d._pinned ? d.size * PIN_BOOST : d.size) * SIZE_MULT
      )
      .on("end", layoutAndDraw)
      .start();
  } catch (err) {
    console.error("[wc] cloud start failed:", err);
    fireEnd("error");
  }

  canvas.onmousemove = (e) => {
    const r = canvas.getBoundingClientRect();
    mouse.x = e.clientX - r.left;
    mouse.y = e.clientY - r.top;

    const idx = hitTest(mouse.x, mouse.y);
    const hit = idx >= 0 ? boxes[idx] : null;

    canvas.style.cursor = hit ? "pointer" : "default";
    canvas.title = hit
      ? `${hit.text} · ${Math.round(hit.avg)}% · seen ${hit.count}×`
      : "";

    if (idx !== hoverIdx) {
      hoverIdx = idx;
      stopRAF();
      paint();
    } else if (hoverIdx >= 0) {
      stopRAF();
      rafId = requestAnimationFrame(() => {
        rafId = 0;
        paint();
      });
    }
  };

  canvas.onmouseleave = () => {
    hoverIdx = -1;
    canvas.style.cursor = "default";
    canvas.title = "";
    stopRAF();
    paint();
  };

  canvas.onclick = (e) => {
    const r = canvas.getBoundingClientRect();
    const mx = e.clientX - r.left;
    const my = e.clientY - r.top;

    const idx = hitTest(mx, my);
    if (idx < 0) return;

    startRipple(idx);

    const hit = boxes[idx];
    if (!hit) return;

    if (typeof opts?.onSelect === "function") {
      opts.onSelect(hit);
    }
  };
}
</file>

<file path="features/progress/wordcloud/index.js">
// features/progress/wordcloud/index.js
import { ensureWordCloudLibs } from "./libs.js";

import { savedListForMode, FAV_KEY, PIN_KEY } from "./state-store.js";
import { mixLabel } from "./labels.js";
import { lower, idFromItem, smartTop3 } from "./compute.js";

import { wordcloudTemplateHtml } from "./template.js";
import { bindWordcloudEvents } from "./events.js";

import { saveNextActivityPlan } from "../../next-activity/next-activity.js";

// ✅ COMMIT 10: extract DOM querying into dom.js
import { getWordcloudDom } from "./dom.js";

// ✅ COMMIT 11: replay/timeline controller extracted
import { createTimelineController } from "./timeline.js";

// ✅ COMMIT 12A: real shared context object
import { createWordcloudContext } from "./context.js";

// ✅ COMMIT 12B: strips + coach lane extracted
import { createWordcloudStrips } from "./strips.js";

// ✅ COMMIT 12D: Next Activity Plan build extracted
import { buildCloudPlan } from "./plan.js";

// ✅ COMMIT 14: UI sync layer extracted
import { createWordcloudUIManager } from "./ui-manager.js";

// ✅ COMMIT 15: data loader extracted
import { createWordcloudDataLoader } from "./data-loader.js";

// ✅ COMMIT 16: drawing orchestrator extracted
import { createWordcloudDrawer, fmtDaysAgo } from "./drawing-orchestrator.js";

// ✅ COMMIT 17: event handler factory extracted
import { createWordcloudEventHandlers } from "./event-handlers.js";

import "./wordcloud-dock.css";

// ✅ FIX C: drawer arrows must work even if something else crashes later
import { wireWordcloudSideDrawers } from "./side-drawers.js";

const ROOT_ID = "wordcloud-root";
const TOP_N = 50; // ✅ was 40

export async function initWordCloudPage() {
  const root = document.getElementById(ROOT_ID);
  if (!root) return;

  // ✅ shared context owns all state + persistence + URL + theme
  const ctx = createWordcloudContext();

  // Snapshot of state for easy reads (updated via onChange)
  let S = ctx.get();
  ctx.onChange((next) => {
    S = next;
  });

  // Stable refs are owned by ctx (NOT by index.js)
  const attemptsAll = ctx.refs.attemptsAll;

  // Mount template FIRST, then grab DOM once
  root.innerHTML = wordcloudTemplateHtml();
  const dom = getWordcloudDom(root);
  console.log("[wc] dom missing:", dom.missing());

  // ✅ FIX 1: drawer toggle should NOT reset the cloud (no redraw)
  // wire early so arrows never "die" even if later setup crashes
  wireWordcloudSideDrawers(root, {
    // ✅ resizing drawers should NOT recompute the cloud
    onLayoutChange: () => drawer.reflow?.() ?? drawer.draw(false),
  });

  // UI sync layer
  const ui = createWordcloudUIManager({
    dom,
    getState: () => S,
    fmtDaysAgo,
  });

  // data loader owns backend communication + refresh scheduling
  const data = createWordcloudDataLoader({ attemptsAll });

  // strips UI controller
  const strips = createWordcloudStrips({
    ctx,
    dom,
    getState: () => S,
    mixLabel,
    smartTop3,
    idFromItem,
    lower,
    savedListForMode,
    PIN_KEY,
    FAV_KEY,
  });

  // draw orchestration
  // NOTE: drawer is declared with `const` BUT referenced by the earlier onLayoutChange callback via closure.
  // That callback won't execute until user clicks the arrows, by which time drawer will exist (unless init crashes).
  const drawer = createWordcloudDrawer({
    ctx,
    dom,
    ui,
    data,
    strips,

    attemptsAll,
    ensureWordCloudLibs,

    buildCloudPlan,
    saveNextActivityPlan,
    goToConvo: () => window.location.assign("./convo.html#chat"),

    getState: () => S,
    topN: TOP_N,
  });

  // timeline controller delegates + requests redraw
  const timeline = createTimelineController({
    dom,

    getRange: () => S.range,
    setRange: (nextRange) => {
      ctx.set({ range: nextRange });
      ui.setActiveButtons();
      ui.applyTimelineUI();
    },

    getWin: () => S.timelineWin,
    setWin: (val) => {
      ctx.set({ timelineWin: val });
      ui.applyTimelineUI();
      drawer.draw(false);
    },

    getPos: () => S.timelinePos,
    setPos: (val) => {
      ctx.set({ timelinePos: val });
      ui.applyTimelineUI();
      drawer.draw(false);
    },

    fmtDaysAgo,
    applyTimelineUI: ui.applyTimelineUI,

    requestDraw: () => drawer.draw(false),
  });

  // bind events (now created by factory)
  bindWordcloudEvents(
    root,
    createWordcloudEventHandlers({
      dom,
      ctx,
      ui,
      drawer,
      timeline,
      strips,
      saveNextActivityPlan,
      getState: () => S,
    })
  );

  // initial UI state
  ctx.applyTheme(dom);
  ui.setActiveButtons();
  ui.setModeStory();
  ui.applyTimelineUI();
  timeline.syncButton?.();

  await drawer.draw(false);

  // auto refresh scheduling (owned by data loader)
  data.startAutoRefresh({
    rootId: ROOT_ID,
    onRefresh: () => drawer.draw(false),
  });
}
</file>

</files>
